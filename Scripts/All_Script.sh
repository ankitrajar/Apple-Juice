############################################################ Author: Parmil Kumar ##########################################################
################################################ Auto Generated By Intelligent Script Maker ################################################
run_as=$(whoami)
if [ "$run_as" == "root" ]; then
    echo "Can not run with root priviledge";
    exit;
fi
your_scripts_path=""; if [ "$your_scripts_path" == "" ];then your_scripts_path="$HOME/myscripts"; fi
my_mobile_no="7411199851"; if [ "$my_mobile_no" == "" ];then echo "Please fill value of my_mobile_no"; exit; fi
your_pc_username=""; if [ "$your_pc_username" == "" ];then your_pc_username="$(whoami)"; fi
your_pc_password="iltwat"; if [ "$your_pc_password" == "" ];then echo "Please fill value of your_pc_password"; exit; fi
parent_path_of_checkout_path=""; if [ "$parent_path_of_checkout_path" == "" ];then parent_path_of_checkout_path="$HOME"; fi
your_cm_utils_path=""; if [ "$your_cm_utils_path" == "" ];then your_cm_utils_path="$HOME"; fi
way2sms_username="7411199851"; if [ "$way2sms_username" == "" ];then echo "Please fill value of way2sms_username"; exit; fi
way2sms_password="903191219a"; if [ "$way2sms_password" == "" ];then echo "Please fill value of way2sms_password"; exit; fi

#Please enter the values in above declartion then run the script
generated_scripts_output_path="./generated_scripts"
#^^^^ END OF DEFINATION SECTION ^^^^#
mkdir -p $generated_scripts_output_path/myscripts
echo -n "#!/usr/bin/env expect 
##########################################################Generic Auto SSH (gas)###########################################################
if {[llength \$argv] < 9} {
puts \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\
\\n         Usages: uen EMS_IP_or_IP_part  EMS_Username  EMS_Password  NMS_IP_or_IP_part  NMS_Username  NMS_Password  Remove_DB(y/n)  Version   Tag\\n 
\\
\\n         IP    :   102 will be treated as 192.168.230.102\\
\\n                   241.244 will be treated as 192.168.241.244\\
\\n                   169.200.100 will be treated as 192.169.200.100\\
\\n                   172.124.143.102 will be Taken as complete IP as it is given.\\n
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {[llength \$argv] < 9} { exit;
}
}
 # timeout -1 means infinite
    set timeout 30000
    set ems_ip_part [lindex \$argv 0];
    set ems_user [lindex \$argv 1];
    set ems_user_pass [lindex \$argv 2];
    set nms_ip_part [lindex \$argv 3];
    set nms_user [lindex \$argv 4];
    set nms_user_pass [lindex \$argv 5];
    set remove_db [lindex \$argv 6]
    set upgrade_to_version [lindex \$argv 7];
    set version_tag [lindex \$argv 8];
    set null_value \"\";
    set base_url \"http://tn100build/cgi-bin/viewvc.cgi/nms-releases/\"
    set download_dir \${upgrade_to_version}_\${version_tag}
    set nms_file_ver \${upgrade_to_version}_\${version_tag}
    set ems_file EMS_Release_\${upgrade_to_version}_\${version_tag}
    set nms_file NMS_Release_\${upgrade_to_version}_\${version_tag}
    set ems_file_path \${base_url}tejnms-sn/REL_\${upgrade_to_version}/\${version_tag}/builds/\${ems_file}.tgz
    set nms_file_path \${base_url}tejnms-nm/REL_\${upgrade_to_version}/\${version_tag}/build/\${nms_file}.tgz
    #EMS
    set ems_reconfig_mysql_passwd \"y\"
    set ems_root_pw_db_server \"iltwat\"
    set ems_new_root_pwd_db_server \"iltwat\"
    set ems_name \"EPG-EMS\"
    set ems_application_mode \"SDH\"
    set user_ems_password \"iltwat\"
    set concurrent_login \"true\"
    set nbi_over_nat \"false\"
    set run_ems_at_startup \"y\"
    set install_in_hot_standby_mode \"n\"
    set start_ems_after_install \"y\"
    #NMS
    set nms_installtion_mode \"1\"
    set nms_reconfigure_mysql_pass \"y\"
    set nms_root_pw_db_server \"iltwat\"
    set nms_new_root_pwd_db_server \"iltwat\"
    set upgrade_now \"y\"
    set is_ems_upgraded \"y\"
    set ems_upgraded_to \$upgrade_to_version
    regsub -all {_} \$ems_upgraded_to . ems_upgraded_to
    set ems_upgraded_to [string range \$ems_upgraded_to 0 2]
    set reconfig_application_mode \"y\"
    set nms_application_mode \"SDH\"
    set run_nms_at_startup \"y\"
    set nms_install_hotstandby_mode \"n\"

#flexible IP addressing
#So that u can provide 102 or 241.244 or 169.143.102 or 172.124.36.102 as IP.
    regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$ems_ip_part all first second third fourth
if { \$fourth != \$null_value } {
   set ip \"\$all\"
} elseif { \$third != \$null_value } {
   set ip \"192\\.\$first\\.\$second\\.\$third\"
} elseif { \$second != \$null_value } {
   set ip \"192\\.168\\.\$first\\.\$second\"
} elseif { \$first != \$null_value } {
   set ip \"192\\.168\\.230\\.\$first\"
} else { puts \"Invalid IP\"; exit; }
   set ems_ip \$ip
puts \"\\nEMS IP is \$ems_ip \\n\"

    regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$nms_ip_part all first second third fourth
if { \$fourth != \$null_value } {
   set ip \"\$all\"
} elseif { \$third != \$null_value } {
   set ip \"192\\.\$first\\.\$second\\.\$third\"
} elseif { \$second != \$null_value } {
   set ip \"192\\.168\\.\$first\\.\$second\"
} elseif { \$first != \$null_value } { 
   set ip \"192\\.168\\.230\\.\$first\"
} else { puts \"Invalid IP\"; exit; }
set nms_ip \$ip

puts \"\\nNMS IP is \$nms_ip \\n\"
puts \"Upgrading EMS\\n\"

spawn ssh \$ems_user@\$ems_ip -X
set ems_spawn_id \$spawn_id
expect {
	    \"*yes/no*\" {
			        send \"yes\\r\"
			        exp_continue
				    }

	    \"assword:\" {
			        send \"\$ems_user_pass\\r\"
				   }
}
expect \"*#\"
send \"/sbin/service ems stop\\r\"
expect \"*#\"
send \"/sbin/service ems status\\r\"
expect \"*#\"
puts \"Current Version of EMS is : \\n\"
send \"cat /opt/ems/release/version/version.txt\\r\"
expect \"*#\"
send \"/opt/ems/release/install/ems_uninstall.sh\\r\"
expect \"*you want to remove*\"
send \"\$remove_db\\r\"
expect {
        \"*you want*\" {
                    send \"\\r\"
                    exp_continue
                    }

             \"*#\" {
                    send \"\\r\"
                   }
           default {
                    send \"\\r\"
			       }
}
expect \"*#\"
send \"cd /home/\\r\"
expect \"*#\"
send \"mkdir -p \$download_dir ; cd \$download_dir ; rm \${ems_file}.tgz* \\r\"
expect {
         \"*remove regular file*\" {
                                   send \"y\\r\"
                                   exp_continue
                                 }
                            \"*#\" {
                                   send \"\\r\"
                                 }
       }
expect \"*#\"
send \"wget \$ems_file_path\\r\"
expect \"*#\"
send \"tar -zxvf \$ems_file.tgz\\r\"
expect \"*#\"
send \"cd EMS*/install/ ; ls \\r\"
expect \"*#\"
send \"./ems_install.sh\\r\"
expect \"*like to reconfigure*\"
send \"\$ems_reconfig_mysql_passwd\\r\"
expect \"*specify root password*\"
send \"\$ems_root_pw_db_server\\r\"
expect \"*specify new root password*\"
send \"\$ems_new_root_pwd_db_server\\r\"
expect \"*re-enter the new root password*\"
send \"\$ems_new_root_pwd_db_server\\r\"
expect \"*enter unique EMS Name*\"
send \"\$ems_name\\r\"
expect \"*enter ems application mode*\"
send \"\$ems_application_mode\\r\"
expect \"*enter the password for user ems*\"
send \"\$user_ems_password\\r\"
expect \"*Concurrent User*\"
send \"\$concurrent_login\\r\"
expect \"*NBI over NAT*\"
send \"\$nbi_over_nat\\r\"
expect \"*Services to run at Startup*\"
send \"\$run_ems_at_startup\\r\"
expect \"*application in Hot Standby mode*\"
send \"\$install_in_hot_standby_mode\\r\"
expect \"*you want to start TJ5100 services now*\"
send \"\$start_ems_after_install\\r\"
#expect \"*#\"
#send \"/sbin/service ems status\\r\"
expect \"*#\"
send \"exit\\r\"
close \$ems_spawn_id

puts \"EMS is Upgraded to \${upgrade_to_version}_\${version_tag}\\n.\"

puts \"\\nUpgrading NMS\\n\"

spawn ssh \$nms_user@\$nms_ip -X
set nms_spawn_id \$spawn_id
expect {
        \"*yes/no*\" {
                    send \"yes\\r\"
                    exp_continue
                    }

        \"assword:\" {
                    send \"\$nms_user_pass\\r\"
                   }
}
expect \"*#\"
send \"/sbin/service nms stop\\r\"
expect \"*#\"
send \"/sbin/service nms status\\r\"
expect \"*#\"
puts \"Current Version of NMS is : \\n\"
send \"cat /opt/nms/release/version.properties\\r\"
expect \"*#\"
send \"ps -ef | grep \\\"java\\\"\\r\"
expect \"*#\"
send \"kill -9 \\\$(ps -ef | grep  java | awk '{print \\\$2}') 2>/dev/null\\r\"
expect \"*#\"
send \"ps -ef | grep java\\r\"
expect \"*#\"
#send \"/opt/nms/release/install/nms_uninstall.sh\\r\"
#expect \"*#\"
send \"cd /home/\\r\"
expect \"*#\"
send \"mkdir -p \$download_dir ; cd \$download_dir ; rm \${ems_file}.tgz* \\r\"
expect {
         \"*remove regular file*\" {
                                   send \"y\\r\"
                                   exp_continue
                                 }
                            \"*#\" {
                                   send \"\\r\"
                                 }
       }

expect \"*#\"
send \"wget \$nms_file_path\\r\"
expect \"*#\"
send \"tar -zxvf \$nms_file.tgz\\r\"
expect \"*#\"
send \"cd NMS*/install/ ; ls \\r\"
expect \"*#\"
send \"./nms_install.sh\\r\"
interact
######################################################## Interact is better #################################################
expect \"*the Installation mode*\"
send \"\$nms_installtion_mode\\r\"
expect \"*like to reconfigure the same*\"
send \"\$nms_reconfigure_mysql_pass\\r\"
expect \"*specify root password for Database*\"
send \"\$nms_root_pw_db_server\\r\"
expect \"*specify new root password for Database*\"
send \"\$nms_new_root_pwd_db_server\\r\"
expect \"*re-enter the new root password for Database*\"
send \"\$nms_new_root_pwd_db_server\\r\"
expect \"*you want*\"
send \"\$upgrade_now\\r\"
expect \"*been upgraded*\"
send \"\$is_ems_upgraded\\r\"
expect \"*enter the upgraded version number*\"
send \"\$ems_upgraded_to\\r\"
expect \"*you want to continue NMS upgradation*\"
send \"y\\r\"
expect \"*you want to reconfigure*\"
send \"\$reconfig_application_mode\\r\"
expect \"*enter nms application mode*\"
send \"\$nms_application_mode\\r\"
expect \"*you want NMS Services to run at Startup*\"
send \"\$run_nms_at_startup\\r\"
expect \"*install application in Hot Standby mode*\"
send \"\$nms_install_hotstandby_mode\\r\"
expect \"*#\"
send \"nms_file_ver=\$nms_file_ver ; cp /opt/nms/\\\${nms_file_ver//_/.}*/license/license.dat /opt/nms/release/license/\\r\"
expect \"*#\"
send \"/sbin/service nms start\\r\"
#expect \"*#\"
#send \"/sbin/service nms status\\r\"
#expect \"*#\"
#send \"exit\\r\"
interact
close \$nms_spawn_id

puts \"\\nNMS is Upgraded to \${upgrade_to_version}_\${version_tag}\\n.\"

" > $generated_scripts_output_path/myscripts/uen
echo "Generated $generated_scripts_output_path/myscripts/uen "

echo -n "#!/usr/bin/env expect 
##########################################################Generic Auto Telnet (gat)###########################################################
if {[llength \$argv] < 4} {
puts \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\
\\n               Usages: gat \\[IP_or_IP_part\\]   Username      Password     remote_rel_details_path\\n 
\\
\\n               Node_IP : 102 will be treated as 192.168.143.102\\
\\n                         241.244 will be treated as 192.168.241.244\\
\\n                         169.200.100 will be treated as 192.169.200.100\\
\\n                         172.124.143.102 will be Taken as complete IP as it is given.\\n
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {[llength \$argv] < 3} { exit;
}
}
 # timeout -1 means infinite
    set timeout 600
    set ip_part [lindex \$argv 0];
    set user [lindex \$argv 1];
    set user_pass [lindex \$argv 2];
    set remote_release_details_path [lindex \$argv 3];
    set null_value \"\";
#    set release_details_path \"/tmp/releases_details.txt\"
    set release_images_path \"/swtn100/hobbes/hobbes/cvsroot/nms-releases/tejnms-nm/\"
#flexible IP addressing
#So that u can provide 102 or 241.244 or 169.143.102 or 172.124.36.102 as IP.
    regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$ip_part all first second third fourth
if { \$fourth != \$null_value } {
   set ip \"\$all\"
} elseif { \$third != \$null_value } {
   set ip \"192\\.\$first\\.\$second\\.\$third\"
} elseif { \$second != \$null_value } {
   set ip \"192\\.168\\.\$first\\.\$second\"
} elseif { \$first != \$null_value } {
   set ip \"192\\.168\\.143\\.\$first\"
} else { puts \"Invalid IP\"; exit; }
puts \"\\nEntity IP is \$ip \\n\"

if {[llength \$argv] == 4} {
        spawn telnet \$ip
        set node_spawn_id \$spawn_id
        expect \"*login*\"
        send \"\$user\\r\"
	expect  {
		\"*asswor*\" {
				send \"\$user_pass\\r\"
				exp_continue
			   }
     \"*command not found*\" {
				send \"\\r\"
				exp_continue
			   }
 
             \"*incorrect*\" {
                                return 1
                           }

		     \"*\$*\" {
			         send \"stty -echo \\r rel_det=\\\"\$remote_release_details_path\\\" ; echo -n \\> \\\$rel_det ; pushd \$release_images_path ; for direc in \\\$\\(ls -d1 REL\\*\\); do pushd \\\$direc 2\\>/dev/null ;suc=\\\$\\? ;if \\[ \\\$suc == 0 \\];then echo \\\"\\\$direc\\\" \\>\\> \\\$rel_det ; ls -1d a\\* \\>\\> \\\$rel_det 2\\>/dev/null ;echo \\\"end\\\$direc\\\" \\>\\> \\\$rel_det; popd >/dev/null ;fi; done ; popd ; echo \\\"DONE\\\" \\r\"
                     expect \"*DONE\"
                     #interact
                     exit ;
			       }

		   default {
				interact
			   }
		}
}

" > $generated_scripts_output_path/myscripts/emsnmsinfo
echo "Generated $generated_scripts_output_path/myscripts/emsnmsinfo "

echo -n "if [[ \"\$#\" != \"2\" ]];then
    echo \"2 package files needed.\"
    exit
fi

function dodiff () {
echo \"file1 \$1, file2 \$2\"
file1=\$1
file2=\$2
echo -n >  extra_in_\$file2
total_lines=\`cat \$file2|wc -l\`
COUNTER=1
         while [  \$COUNTER -lt \$total_lines ]; do
		pkg_temp=\$(sed -n \"\${COUNTER}p\" \"\$file2\")
                if grep -q \"\$pkg_temp\" \$file1; then
		:
		else
		   echo \"\$pkg_temp\" >> extra_in_\$file2;
		fi
             let COUNTER=COUNTER+1 
         done
}

dodiff \$1 \$2
dodiff \$2 \$1
" > $generated_scripts_output_path/myscripts/pkg_diff.sh
echo "Generated $generated_scripts_output_path/myscripts/pkg_diff.sh "

echo -n "#&&&&^^^^BASHRCIDTOKEN^^^^&&&&#
#IF YOU WANT TO MAKE YOUR PERSONAL CHANGES(FXNS ETC.) PLEASE KEEP THEM BELOW THIS BASHRC TOKEN. OTHERWISE ABOVE THIS TOKEN THEY MIGHT GET DESTROYED.
####################################################################### MY ALIASES #####################################################################
# for pushd and popd
alias pu='pushd'
alias ,,='po'
alias clc='gnome-calculator'
alias lsl='ls -lrt'
alias cp7='chmod 777' #changes permissions to 777
#for checkout mirror
alias cout=~/cm-utils/checkout
alias mirr=~/cm-utils/mirror
#directly goto home
alias h='pushd \$HOME >> /dev/null'
alias ms='pushd \$HOME/myscripts >> /dev/null'
alias ccd='dirs -c'
alias dw='pushd \$HOME/Downloads >> /dev/null'
alias dskt='pushd \$HOME/Desktop >> /dev/null'
## get rid of command not found
alias cd..='cd ..'
alias cd-='cd -'
## a quick way to get out of current directory
alias ..='pushd .. >> /dev/null'
alias .2='pushd ../../ >> /dev/null'
alias ...='pushd ../../../ >> /dev/null'
alias ....='pushd ../../../../ >> /dev/null'
alias .....='pushd ../../../../../ >> /dev/null'
alias ......='pushd ../../../../../../ >> /dev/null'
alias .......='pushd ../../../../../../../ >> /dev/null'
alias ........='pushd ../../../../../../../../ >> /dev/null'
alias .........='pushd ../../../../../../../../../ >> /dev/null'
alias .3='pushd ../../../ >> /dev/null'
alias .4='pushd ../../../../ >> /dev/null'
alias .5='pushd ../../../../../ >> /dev/null'
alias .6='pushd ../../../../../../ >> /dev/null'
alias .7='pushd ../../../../../../../ >> /dev/null'
alias .8='pushd ../../../../../../../../ >> /dev/null'
####################################################################### OVERRIDES# ####################################################################
function c () {
#++# c : change dir using pushd.
    pushd \$@ > /dev/null
}
function kt () {
#++# kt : kill tail
    kill -9 \$(ps | grep [t]ail | awk '{print \$1}' 2>/dev/null) 2>/dev/null
}
function gs () {
#++# gs : git status,overriding existing package ghostscript.
    git status
}
function gd () {
#++# gd : git diff.
    git diff
}
function po () {
#++# po : same as popdir, but extra thing is you can give how many times you want to popd.
     count=\$1
     temp=1
    if [ \"\$count\" == \"\" ];then
        count=1
    fi
    while [ \$temp -le \$count ]
    do
        popd >> /dev/null
        let temp=temp+1
    done
}
function sd () {
#++# sd : show dir stack.
    dirs
}

########################################################################## NOTE ########################################################################
#AVOID USING \$* WITH fip. use \$@ otherwise all args passed via \$* will be considered in \$1 only in fip fxn.
#  Special Parameters
#  The shell treats several parameters specially.   These  parameters  may only be referenced; assignment to them is not allowed.
#  *      Expands  to  the positional parameters, starting from one.  When the expansion occurs within double quotes, it expands to a  sin‐
#         gle word with the value of each parameter separated by the first character of the IFS special variable.  That is, \"\$*\" is equiva‐
#         lent to \"\$1c\$2c...\", where c is the first character of the value of the IFS variable.  If IFS is unset, the parameters are  sepa‐
#         rated  by  spaces.   If  IFS  is null, the parameters are joined without intervening separators.
#  
#  @      Expands to the positional parameters, starting from  one.   When the  expansion  occurs  within  double  quotes,  each  parameter
#         expands to a separate word.  That is, \"\$@\" is equivalent to \"\$1\" \"\$2\"  ...   If the double-quoted expansion occurs within a word,
#         the expansion of the first parameter is joined with  the  begin‐ning  part  of  the original word, and the expansion of the last
#         parameter is joined with the last part  of  the  original  word.When  there  are no positional parameters, \"\$@\" and \$@ expand to
#         nothing (i.e., they are removed).

######################################################################## DEFINATIONS ###################################################################
scripts_path=\"$your_scripts_path\"; #<#<#$HOME/myscripts#>#>#
user_bashrc=~/.bashrc  ## for root its in root/.bashrc for normal user will be \$USER/.bashrc
my_mobile_no=\"$my_mobile_no\";
sms_sending_script=\"\$scripts_path/python/send_sms_way2sms.py\"
modules_conf_path=~/cm-utils/modules.conf
tej_ph=~/.name_phone
tej_nph=~/.name_nph
tej_more=~/.name_phmore
tej_det=~/.name_phmore_details
reip='^[0-9\\.]+\$' ## regex for matching numerical with . inside // ip .
renum='^[0-9]+\$' ## regex for matching numerical value only
retext='^[a-zA-Z0-9]+\$' ## regex for matching text
password_manager_file=~/.psm_file
mirrors_of_checkout_file=\".mirrors_list\"
compile_for_type_file=\".compile_for\"
universal_mirrors_file=~/.universal_mirrors_list
universal_checkouts_file=~/.universal_checkouts_list
universal_orphan_mirrors_file=~/.universal_orphan_mirrors_list
universal_local_md5_file=~/.universal_local_md5_list
md5_temp_on_release_server=\"/tmp/.universal_release_md5_list\"
universal_release_md5_file=~/.universal_release_md5_list
temp_on_release_server=\"/tmp/.release_details\" #these names
universal_release_details=~/.release_details #should match otherwise will give touble
ems_nms_temp_on_release_server=\"/tmp/.ems_nms_release_details\" #these names
universal_ems_nms_release_details=~/.ems_nms_release_details #should match otherwise will give touble
release_server_ip=\"192.168.0.14\"
release_server_username=\"swtn100\"
release_server_password=\"tn100sw\"
up_ip_list=~/.upload_ip_list
uen_ip_list=~/.uen_ip_list
fip_ip_list=~/.fip_ips
fip143_ip_list=~/.fip143_ips
if ! [ -e \$up_ip_list ] || ! [ -e \$uen_ip_list ];then
touch \$up_ip_list ;
touch \$uen_ip_list ;
fi
outer_latest_image=\".outer_latest_img\"
inner_latest_image=\".inner_latest_img\"
image_name_delimeters=\"_-\"
combined_image_keyword=\"unified\"
outer_images=(xcc360g tj1700 tj14xx teraxc)
total_outer=\${#outer_images[@]};
inner_images=(cef5 elan10)
total_inner=\${#inner_images[@]};
timestamp_override_token=\".my_priority_1\"
final_outer=\".combine_me_outer\"
final_inner=\".combine_me_inner\"
image_extraction_dir=\"name\"
all_nodes_dir=~/.all_nodes/
if ! [ -d \$all_nodes_dir ];then
      mkdir \$all_nodes_dir
fi
node_subnets=(143 241 50)
######################################################################## FUNCTIONS #####################################################################
function pe () {
#++# pe : prepare_essential. Take care of initial setup
touch \$tej_ph
touch \$tej_nph
touch \$tej_more
touch \$tej_det
touch \$password_manager_file
touch \$universal_mirrors_file
touch \$universal_checkouts_file
touch \$universal_orphan_mirrors_file
touch \$universal_release_details
touch \$universal_ems_nms_release_details
touch \$up_ip_list
touch \$uen_ip_list
touch \$fip_ip_list
touch \$fip143_ip_list
touch \$universal_release_md5_file
touch \$universal_local_md5_file
mkdir -p \$all_nodes_dir
urd
uml
ulmd
urmd
update_all &
}
should_this_be_outer_image () {
   image=\$1
   for ((index=0; index<\$total_outer; index++))
   do
        if [ \"\${outer_images[\$index]}\" == \"\${image}\" ]; then
            echo \"yes\"
            return
        fi
   done;
   echo \"no\"
}
should_this_be_inner_image () {
   image=\$1
   for ((index=0; index<\$total_inner; index++))
   do
        if [ \"\${inner_images[\$index]}\" == \"\${image}\" ]; then
            echo \"yes\"
            return
        fi
   done;
   echo \"no\"
}
function compile () { 
#++# compile : compile function. takes care of complicated compile commands for different targets.
target=\$1
thread=\$2;
if [[ \$target =~ \$renum ]];then 
    thread=\$target 
    target=\"\" #so that we can fill up value of target from .compile_for file if it exists otherwise just print usage.
fi
rel_path=\$(reverse_recursive_search taginfo)
if [[ \"\$rel_path\" == \"\" ]]; then
     echo \"Not able to locate taginfo. Doesn't seem to be checkout or mirror area.\"
     return
else
     if ! [ -L \"\$rel_path\" ];then
          echo \"You are trying to give Compile command in the checkout area. If still want to compile in checkout area write your own fxn.\"
          echo \";)\"
          return
     else
          rel_path=\${rel_path%/*}
     fi
fi

if [ -e \${rel_path}/\$compile_for_type_file ];then
   temp_target=\$(cat \${rel_path}/\$compile_for_type_file)
   if [[ \"\$temp_target\" != \"\" ]] && [ \"\$target\" == \"\" ];then
       target=\$temp_target
   fi
fi

if [ \"\$target\" == \"\" ]; then
    echo \"Usages: compile [ cef5 / xcc360g / tj1700 / plc01 / osmc / elan07 / teraxc / xa10g / elan10 / cef4 /cef4C / tj14xx / tj14xxN ] [No. of threads. Default : 1]\";
    return;
fi
  
if ! [ -e './create_install' ]; then
    echo -n \"\$target\" > \${rel_path}/\$compile_for_type_file
    pushd \$rel_path/tj100_mc/scripts >> /dev/null
fi

if [ \"\$thread\" == \"\" ];then
    thread=1
fi
compile_dir=\$PWD
compile_cmd=\$(get_compile_command \$target \$compile_dir \$thread)
if [ \"\$compile_cmd\" == \"\" ];then
    echo \"Unknown target Type. Please add this to the get_compile_command function.\"
    return
fi
echo \$compile_cmd
eval \$compile_cmd
}

function _compile() { ## autocompletion function for compile
words=(cef5 xcc360g tj1700 plc01 osmc elan07 teraxc xa10g elan10 cef4 cef4C tj14xx tj14xxN)
rel_path=\$(reverse_recursive_search taginfo)
if [[ \"\$rel_path\" == \"\" ]]; then
     COMPREPLY=( \$(compgen -W \"\$(for word in \${words[@]}; do echo \"\$word\"; done)\" -- \${COMP_WORDS[COMP_CWORD]}) )
else
     rel_path=\${rel_path%/*}
fi

if [ -e \${rel_path}/\$compile_for_type_file ];then
   temp_target=\$(cat \${rel_path}/\$compile_for_type_file)
   if [[ \"\$temp_target\" != \"\" ]];then
      COMPREPLY=( \$(compgen -W \"\$temp_target\" -- \$cur) )
   else
      COMPREPLY=( \$(compgen -W \"\$(for word in \${words[@]}; do echo \"\$word\"; done)\" -- \${COMP_WORDS[COMP_CWORD]}) )
   fi
else
   COMPREPLY=( \$(compgen -W \"\$(for word in \${words[@]}; do echo \"\$word\"; done)\" -- \${COMP_WORDS[COMP_CWORD]}) )
fi
}
complete -F _compile compile mc
function update_ph () { #internal
    perl \$scripts_path/perl/phone > \$tej_ph
}
function update_nph () { #internal
    perl \$scripts_path/perl/nph.pl \$1 \$2 \$3 \$4 | html2text | grep @ > \$tej_nph
}
function update_more () { #internal
    GET \"http://192.168.0.8/cgi-bin/name/tis.cgi?action=searchUserInfo&key=name&keyval=\" | sed -e \"s/<\\/td><td>/ /g\"  | sed -e \"s/<TR>/\\n/g\" |sed -e \"s/<td><a href=//g\" | sed -e \"s/<\\/td>//g\" | grep \"tis.cgi?action=dispUserInfo&amp;id\" > \$tej_more
}

function update_det () { #internal
echo -n \"\" > \$tej_det
for page_id in \$(cat \$tej_more | awk 'BEGIN { FS = \"\\\"\" } { print \$2}' | cut -f3 -d '=')
do
    echo \"page_id\${page_id}start\" >> \$tej_det
    GET \"http://192.168.0.8/cgi-bin/name/tis.cgi?action=dispUserInfo&amp;id=\$page_id\" | html2text | grep -v \"Search\\|SUBMIT\\|Edit\\|oExtn\\|^\$\" >> \$tej_det
    echo \"page_id\${page_id}end\" >> \$tej_det
done
}

function update_all () { 
#++# update_all : update name user search info.
    update_ph
    update_nph
    update_more
    update_det &
}
function tejph () { #interal
    cat \$tej_ph
}
function tejnph () { # internal
    cat \$tej_nph
}
function wht2und () { ## white spaces to underscore converter. internal
    echo \"\$*\" | sed -e 's/ /_/g'
}
function und2wht () { ## white spaces to underscore converter. internal
    echo \"\$*\" | sed -e 's/_/ /g'
}
function diag () {
#++# diag : open diag directly with killing if already someone else is using it.
    \$scripts_path/diag \$1 \$2 \$3 \$4
}
function up () {
#++# up : upload a local image or release image directly to node.
    \$scripts_path/supload \$1 \$2 \$3 \$4 \$5 \$6
    if  [[ \$1 =~ \$renum ]] ; then ## check if second arg is port or some numerical else it might be last name.
        if ! grep -Fxq \"\$1\" \$up_ip_list
        then
#           echo \"\$1\" >> \$up_ip_list
            echo \"\$1\" > \$up_ip_list # more lazy approach. single tab ip completion
        fi
    fi
}
function _up () { ##internal autocompletion fxn for up. specifically for up rel.
if [[ \"\$COMP_CWORD\" -ge \"2\" ]] && [[ \"\${COMP_WORDS[2]}\" == \"rel\" ]];then
case \$COMP_CWORD in
        3) COMPREPLY=(\$(compgen -W \"\$(cat \$universal_release_details |grep ^REL | sed -e 's/REL_//g')\" -- \${COMP_WORDS[COMP_CWORD]}));;
        4) COMPREPLY=(\$(compgen -W \"\$(cat \$universal_release_details |grep -A200 REL_\${COMP_WORDS[COMP_CWORD-1]} | grep -B200 endREL_\${COMP_WORDS[COMP_CWORD-1]} | grep -v REL)\" -- \${COMP_WORDS[COMP_CWORD]}));;
    esac
else
case \$COMP_CWORD in
        1) COMPREPLY=(\$(compgen -W \"\$(cat \$up_ip_list)\" -- \${COMP_WORDS[COMP_CWORD]}));;
        2)
        taginfo_relative_path=\$(reverse_recursive_search taginfo)
        if [[ \"\$taginfo_relative_path\" == \"\" ]];then
             COMPREPLY=(\$(compgen -o filenames -o dirnames -W \"\$(echo \"rel\" ; ls -1 )\" -- \${COMP_WORDS[COMP_CWORD]}));
              return
        fi
        taginfo_absolute_path=\$(readlink -e \$taginfo_relative_path)
        taginfo_absolute_path=\${taginfo_absolute_path%taginfo}

        if ! [[ -e \${taginfo_absolute_path}\${mirrors_of_checkout_file} ]];then
              COMPREPLY=(\$(compgen -o filenames -o dirnames -W \"\$(echo \"rel\" ; ls -1 )\" -- \${COMP_WORDS[COMP_CWORD]}));
              return
        fi

        readarray -t mirrors <<< \"\$(cat \${taginfo_absolute_path}\${mirrors_of_checkout_file})\"
         total_results=\${#mirrors[@]}
        if [[ \"\$total_results\" == \"0\" ]]; then
             COMPREPLY=(\$(compgen -o filenames -o dirnames -W \"\$(echo \"rel\" ; ls -1 )\" -- \${COMP_WORDS[COMP_CWORD]}));
             return
        fi
        IFS=\$'\\n' tmp=( \$(compgen -o dirnames -o filenames -W \"\$(echo \"rel\";for((index=0;index<\$total_results;index++)); do ls -1rt \${mirrors[\$index]}*.img 2>/dev/null | tail -n 1; done)\" -- \"\${COMP_WORDS[\$COMP_CWORD]}\" ))
         COMPREPLY=( \"\${tmp[@]}\" )
    esac
fi
}
complete -F _up up
function cph () {
#++# cph : compact User search. Can easily manpulate its output. Its mostly an internal bashrc fxn.
    perl \$scripts_path/perl/nph.pl \$1 \$2 \$3 \$4 | html2text | grep @
}
function uph () { 
#++# uph : User search results with underscore. setting escape chars to spaces so that exact match happens.
    cph | grep -i \$(wht2und \"\$*\")    ### -i to ignore case
}
function ph () { 
#++# ph : User search. underscore to white spaces converted. better looking.
    echo \"Name               EMail                Extension Cube No   Mobile No    Res Phone   Current        Designation                        Group\"
    echo \"                                                                         No          Location\"
    cat \$tej_nph | sed -e 's/_/ /g' | grep -i \"\$*\"    ### -i to ignore case
}
function phm () {
#++# phm : More detailed ph(User Search) , will give more details about person.
for page_id in \$(cat \$tej_more | grep -i \"\$*\" | awk 'BEGIN { FS = \"\\\"\" } { print \$2}' | cut -f3 -d '=')
do
    echo \" \"
    cat \$tej_det | grep -A20 \"page_id\${page_id}start\" | grep -B20 \"page_id\${page_id}end\" | grep -v \"page_id\${page_id}start\\|page_id\${page_id}end\" | grep -i -C 300 \"\$*\" 
done
}
function ei () { ## email initials, get using anything that is grepable, internal fxn
    cat \$tej_ph| grep -i \"\$*\" | grep @ | cut -f2 | cut -f1 -d '@'
}
function getemail () { ## email initials, get using anything that is grepable. internal fxn.
    names=( \"\$@\" )
    for name in \"\${names[@]}\"
    do
    cat \$tej_ph| grep -i \"\$name\" | grep @ | cut -f2 | cut -f1 -d '@' | sed -e 's/\$/@india.namenetworks.com/g'
    done
}
function mail () {
#++# mail : mail to people using their email initial, complete name, partial info .cube etc.
    echo -n \"\" > .mailfifo
    names=( \"\$@\" )
    for name in \"\${names[@]}\"
    do
        cat \$tej_ph| grep -i \"\$name\" | grep @ | cut -f2 | cut -f1 -d '@' | sed -e 's/\$/@india.namenetworks.com,/g' >> .mailfifo
    done
    thunderbird -compose \"to='\$(cat .mailfifo)'\"
    rm .mailfifo
}
function bei () { ## email initials from bangalore office only. internal fxn
    cat \$tej_ph|grep -i \"\$*\" | grep @ |grep -i bangalore | cut -f2 | cut -f1 -d '@'
}
function n2i () { ## name to ip
#internal fxn
#declare -a email_initial=(\$(bei \"\$*\")) ## just try for lookup in bangalore office only. local will work with them only.
    declare -a email_initial=(\$(cat \$tej_ph|grep -i \"\$*\" | grep @ |grep -i bangalore | cut -f2 | cut -f1 -d '@'))
## now loop through the above array
    for i in \"\${email_initial[@]}\"
    do
        temp=\`gethostip -d \"\$i-DT.local\"\`
        if [ \"\$?\" == \"0\" ];then
        echo \$temp
        fi
    done
}
function rd () {
#++# rd : opens term-eng automatically.
login_as=\$1
domain=\"name\"
if [ \"\$login_as\" == \"\" ];then
    login_as=\"parmilk\"
fi

    rdesktop -f -5 -K -r clipboard:CLIPBOARD term-eng -u\$login_as -d\$domain &
}

function node () {
#++# node : telnet to any node.
    \$scripts_path/node \$1 \$2
}
function logs () {
#++# logs : get cef5 logs from any node.
    \$scripts_path/logs \$1 \$2
}
function password_manager () { #internal fxn used by bashrc. stores passwords.
    ip=\$1
    username=\$(cat \$password_manager_file | grep -w \$ip |cut -f2 -d ' ')
    if ! [[ \$username =~ \$retext ]] ; then
        echo -n \"login(username):\";
        read  username
        echo -n \"password:\";
        read -s password
        echo \"\$ip \$username \$password\" >> \$password_manager_file
    fi
}
function fip () { #internal fxn used by bashrc
    only_string=(\$(echo \"\$*\"|sed 's/[0-9]*//g'))
    if  [[ \$1 =~ \$reip ]] ; then ##    reip='^[0-9.]+\$' ## regex for matching numerical with . inside // ip . defined above in definations
    echo \"\$1\" > \$fip_ip_list
    if [[ \$1 = *.*.*.* ]] ; then
        echo \$1
    elif [[ \$1 = *.*.* ]] ; then
        echo 192.\$1
    elif [[ \$1 = *.* ]] ; then
        echo 192.168.\$1
    elif [[ \$1 -lt 255 ]] ; then
        echo 192.168.230.\$1
    else
        possible_ip=(\$(n2i \"\$@\"))
        printf '%s\\n' \"\${possible_ip[@]}\" | grep -vi \"Unknown\"
    fi

    else
        possible_ip=(\$(n2i \"\${only_string[@]}\"))
        printf '%s\\n' \"\${possible_ip[@]}\" | grep -vi \"Unknown\"
    fi
}

function _fip () { #completion fxn for fip
case \$COMP_CWORD in
        1) COMPREPLY=(\$(compgen -W \"\$(cat \$fip_ip_list 2>/dev/null)\" -- \${COMP_WORDS[COMP_CWORD]}));;
esac
}
complete -F _fip tt s ft pc p

function _fip143 () { #completion fxn for fip143
case \$COMP_CWORD in
        1) COMPREPLY=(\$(compgen -W \"\$(cat \$fip143_ip_list 2>/dev/null)\" -- \${COMP_WORDS[COMP_CWORD]}));;
esac
}
complete -F _fip143 pn ni nis cef5

function fip143 () { #internal fxn by bashrc
echo \"\$1\" > \$fip143_ip_list
    if [[ \$1 = *.*.*.* ]] ; then
        echo \$1
    elif [[ \$1 = *.*.* ]] ; then
        echo 192.\$1
    elif [[ \$1 = *.* ]] ; then
        echo 192.168.\$1
    elif [[ \$1 -lt 255 ]] ; then
        echo 192.168.143.\$1
    fi
}

function tt () {
#++# tt : telnet, using ip part or complete ip, email initial, name, cube or phone no. Asks password for frist time, next time automatic login.
null_value=\"\"
if [ \"\$1\" == \"\$null_value\" ];then
echo Input some part of ip or complete ip.
else
        possible_ip=(\$(fip \"\$@\"))
        no_of_ip=\${#possible_ip[@]}
        if [ \$no_of_ip -gt \"1\" ];then
            echo \"Multiple Host IP found for the name you gave. Please be more specific.\"
        elif [ \$no_of_ip -lt \"1\" ];then
            echo \"No IP Found for that. Please try again with more accurate info.\"
        else
            password_manager \$possible_ip
            username=\$(cat \$password_manager_file | grep -w \$ip |cut -f2 -d ' ')
            password=\$(cat \$password_manager_file | grep -w \$ip |cut -f3 -d ' ')
            if  [[ \$2 =~ \$renum ]] ; then ## check if second arg is port or some numerical else it might be last name.
            telnet \$possible_ip \$2
            else
            # telnet \$possible_ip
            \$scripts_path/gat \$possible_ip \$username \$password
            fi
        fi
fi
}
# function _tt () { #internal fxn for autocompletion
# COMPREPLY=(\$(compgen -W \"\$(cat \$password_manager_file | cut -f1 -d ' ')\" -- \${COMP_WORDS[COMP_CWORD]}))
# }
# complete -F _tt tt s ft pc

function s () {
#++# s : ssh -X , using ip part or complete ip, email initial, name, cube or phone no. Asks password for frist time, next time automatic login.
    null_value=\"\"
        if [ \"\$1\" == \"\$null_value\" ];then
            echo Usages : s  ip_part/email_initial/cube_no./anything.
        else
             possible_ip=(\$(fip \"\$@\"))
             no_of_ip=\${#possible_ip[@]}
             if [ \$no_of_ip -gt \"1\" ];then
                  echo \"Multiple Host IP found for the name you gave. Please be more specific.\"
             elif [ \$no_of_ip -lt \"1\" ];then
                 echo \"No IP Found for that. Please try again with more accurate info.\"
             else
                 password_manager \$possible_ip
                 username=\$(cat \$password_manager_file | grep -w \$ip |cut -f2 -d ' ')
                 password=\$(cat \$password_manager_file | grep -w \$ip |cut -f3 -d ' ')
                 \$scripts_path/gas \$possible_ip \$username \$password
             fi
        fi
}

function pc () {
#++# pc : open pc using remote-desktop from ip part or complete ip, email initial, name, cube or phone no.(subnet 230 hardcoded in fip)
null_value=\"\"
vnc_port=\"5900\"
if [ \"\$1\" == \"\$null_value\" ];then
echo Input some part of ip or complete ip or name_of_person/email_initial/cube_no./anything..
else
             possible_ip=(\$(fip \"\$@\"))
             no_of_ip=\${#possible_ip[@]}
             if [ \$no_of_ip -gt \"1\" ];then
                 echo \"Multiple Host IP found for the name you gave. Please be more specific.\"
             elif [ \$no_of_ip -lt \"1\" ];then
                 echo \"No IP Found for that. Please try again with more accurate info.\"
             else
                 vinagre -f --vnc-scale \$possible_ip:\$vnc_port
             fi

fi
}

function ft () {
#++# ft : ftp, using ip part or complete ip, email initial, name, cube or phone no. Asks password for frist time, next time automatic login.
null_value=\"\"
if [ \"\$1\" == \"\$null_value\" ];then
echo Input some part of ip or complete ip or name_of_person/email_initial/cube_no./anything..
else
             possible_ip=(\$(fip \"\$@\"))
             no_of_ip=\${#possible_ip[@]}
             if [ \$no_of_ip -ne \"1\" ];then
                 echo \"Multiple Host IP found for the name you gave. Please be more specific.\"
             elif [ \$no_of_ip -lt \"1\" ];then
                 echo \"No IP Found for that. Please try again with more accurate info.\"
             else
                password_manager \$possible_ip
                username=\$(cat \$password_manager_file | grep -w \$ip |cut -f2 -d ' ')
                password=\$(cat \$password_manager_file | grep -w \$ip |cut -f3 -d ' ')
                if  [[ \$2 =~ \$renum ]] ; then ## check if second arg is port or some numerical else it might be last name.
                ftp \$possible_ip \$2
                else
                \$scripts_path/gaf \$possible_ip \$username \$password
                fi  
             fi
fi
}

function sbc () {
#++# sbc : source bashrc.
    echo \"Sourcing \$user_bashrc of user \$USER\";
    source \$user_bashrc
}

function ebc () {
#++# ebc : open bashrc from anywhere and source it after closing.
        echo \"Opening \$user_bashrc of user \$USER\";
            vi \$user_bashrc +\$
        #calling sbc() to source it
        sbc
}

function rbc () {
#++# rbc : open bashrc but don't source on closing it. form anywhere.
            echo \"Opening \$user_bashrc of user \$USER\";
                        vi \$user_bashrc +\$
                                    
}
function gat () {
#++# gat : generic automated telnet. mostly used by other bashrc fxns.
null_value=\"\"
if [ \"\$1\" == \"\$null_value\" ];then
echo Input some part of ip or complete ip or name_of_person/email_initial/cube_no./anything..
else
             possible_ip=(\$(fip \"\$1\"))
             no_of_ip=\${#possible_ip[@]}
             if [ \$no_of_ip -ne \"1\" ];then
                 echo \"Multiple Host IP found for the name you gave. Please be more specific.\"
             elif [ \$no_of_ip -lt \"1\" ];then
                 echo \"No IP Found for that. Please try again with more accurate info.\"
             else
                  \$scripts_path/gat \$possible_ip \$2 \$3 \$4
             fi
fi
}
function reg () {
#++# reg : automatic telnet to regression server. 240.11 in this case.
    \$scripts_path/gas 240.11 Techie iltwat iltwat
}

function rel () {
#++# rel : automatic telnet to release server 0.14.
    \$scripts_path/gat \$release_server_ip \$release_server_username \$release_server_password
}

function urd () {
#++# urd : update releases details
    echo \"Sending commands to release server so that it will create \$temp_on_release_server.\"
    \$scripts_path/relinfo \$release_server_ip \$release_server_username \$release_server_password \$temp_on_release_server
    echo \"Server has created \$temp_on_release_server\"
    echo \"Downloading that to \$universal_release_details\"
    echo -n > \$universal_release_details
    ncftpget -u\$release_server_username -p\$release_server_password \$release_server_ip ~/ \$temp_on_release_server
    echo \"Done. Updated Release Details to latest.\"    
}

function uen () {
#++# uen : update ems nms

        if ! grep -Fxq \"\$1 \$2 \$3 \$4 \$5 \$6 \$7\" \$uen_ip_list
        then
           echo \"\$1 \$2 \$3 \$4 \$5 \$6 \$7\" >> \$uen_ip_list
        fi

    \$scripts_path/uen \$1 \$2 \$3 \$4 \$5 \$6 \$7 \$8 \$9 \${10}
}
function _uen () { ##internal autocompletion fxn for uen.
case \$COMP_CWORD in
        1)COMPREPLY=(\$(compgen -W \"\$(cat \$uen_ip_list | awk 'BEGIN {FS=\" \"} {print \$1}' )\" -- \${COMP_WORDS[COMP_CWORD]}));;
        2)COMPREPLY=(\$(compgen -W \"\$(cat \$uen_ip_list | awk 'BEGIN {FS=\" \"} {print \$2}' )\" -- \${COMP_WORDS[COMP_CWORD]}));;
        3)COMPREPLY=(\$(compgen -W \"\$(cat \$uen_ip_list | awk 'BEGIN {FS=\" \"} {print \$3}' )\" -- \${COMP_WORDS[COMP_CWORD]}));;
        4)COMPREPLY=(\$(compgen -W \"\$(cat \$uen_ip_list | awk 'BEGIN {FS=\" \"} {print \$4}' )\" -- \${COMP_WORDS[COMP_CWORD]}));;
        5)COMPREPLY=(\$(compgen -W \"\$(cat \$uen_ip_list | awk 'BEGIN {FS=\" \"} {print \$5}' )\" -- \${COMP_WORDS[COMP_CWORD]}));;
        6)COMPREPLY=(\$(compgen -W \"\$(cat \$uen_ip_list | awk 'BEGIN {FS=\" \"} {print \$6}' )\" -- \${COMP_WORDS[COMP_CWORD]}));;
        7)COMPREPLY=(\$(compgen -W \"\$(cat \$uen_ip_list | awk 'BEGIN {FS=\" \"} {print \$7}' )\" -- \${COMP_WORDS[COMP_CWORD]}));;
        8) COMPREPLY=(\$(compgen -W \"\$(cat \$universal_ems_nms_release_details |grep ^REL | sed -e 's/REL_//g')\" -- \${COMP_WORDS[COMP_CWORD]}));;
        9) COMPREPLY=(\$(compgen -W \"\$(cat \$universal_ems_nms_release_details |grep -A200 REL_\${COMP_WORDS[COMP_CWORD-1]} | grep -B200 endREL_\${COMP_WORDS[COMP_CWORD-1]} | grep -v REL)\" -- \${COMP_WORDS[COMP_CWORD]}));;
    esac
}
complete -F _uen uen

function uend () {
#++# uend : update ems nms details
    echo \"Sending commands to release server so that it will create \$ems_nms_temp_on_release_server.\"
    \$scripts_path/emsnmsinfo \$release_server_ip \$release_server_username \$release_server_password \$ems_nms_temp_on_release_server
    echo \"Server has created \$ems_nms_temp_on_release_server\"
    echo \"Downloading that to \$universal_ems_nms_release_details\"
    echo -n > \$universal_ems_nms_release_details
    ncftpget -u\$release_server_username -p\$release_server_password \$release_server_ip ~/ \$ems_nms_temp_on_release_server
    echo \"Done. Updated EMS NMS Release Details to latest.\"    
}


function pf () {
#++# pf : open password file managed by password_manager function. to directly open file and edit any worng info.
    vi \$password_manager_file +\$
}
function bct () { 
#++# bct : build cscope & ctags. generates cscope.files and build symbol database & tags file also.
    echo \"Building cscope.files & cscope database.\"
    find -name *.cpp -o -name *.[ch] > cscope.files
    echo \"cscope.files written.\"
    cscope -R -b -q -k &
    echo \"cscope symbol database building. In Background.\"
    echo \"Building CTAGS database.\"
    ctags -R *
    echo \"ctag & cscope build completed.\"
}
function cs () { 
#++# cs : run cscope,cscope file is required
    cscope -d
}

function p () { 
#++# p : ping,generally to ping my 3rd floor pcs (subnet 230 is used or name cube no. email initial can be used)
null_value=\"\"
if [ \"\$1\" == \"\$null_value\" ];then
echo Input some part of ip or complete ip or name_of_person/email_initial/cube_no./anything..
else
             possible_ip=(\$(fip \"\$@\"))
             no_of_ip=\${#possible_ip[@]}
             if [ \$no_of_ip -ne \"1\" ];then
                 echo \"Multiple Host IP found for the name you gave. Please be more specific.\"
             elif [ \$no_of_ip -lt \"1\" ];then
                 echo \"No IP Found for that. Please try again with more accurate info.\"
             else
                ping \$possible_ip
             fi
fi
}
function pn () { 
#++# pn : pingnode, shorten ping commands, hardcoded fip143 function. all my nodes are in 143 subnet.
null_value=\"\"
if [ \"\$1\" == \"\$null_value\" ];then
echo Input some part of ip or complete ip or name_of_person/email_initial/cube_no./anything..
else
             possible_ip=(\$(fip143 \"\$@\"))
             no_of_ip=\${#possible_ip[@]}
             if [ \$no_of_ip -ne \"1\" ];then
                 echo \"Multiple Host IP found for the name you gave. Please be more specific.\"
             elif [ \$no_of_ip -lt \"1\" ];then
                 echo \"No IP Found for that. Please try again with more accurate info.\"
             else
                ping \$possible_ip
             fi
fi
}


function ni () { 
#++# ni : complete node info # mostly card info 
if [ \"\$1\" == \"\" ];then
echo Input some part of ip or complete ip.
else
             possible_ip=(\$(fip143 \"\$@\"))
             no_of_ip=\${#possible_ip[@]}
             if [ \$no_of_ip -ne \"1\" ];then
                 echo \"Multiple Host IP found for the name you gave. Please be more specific.\"
             elif [ \$no_of_ip -lt \"1\" ];then
                 echo \"No IP Found for that. Please try again with more accurate info.\"
             else
                #python \$scripts_path/python/autologin.py \$possible_ip |html2text |html2text |sed -e 's/_/ /g' | sed -e 's/Â//g' | sed -e 's/|\\ .*|//g'
                 python \$scripts_path/python/autologin.py \$possible_ip |html2text |html2text
                 fi
fi
}
function nis () {
#++# nis : node info simplified.
if [ \"\$1\" == \"\" ];then
echo Input some part of ip or complete ip.
else
             possible_ip=(\$(fip143 \"\$@\"))
             no_of_ip=\${#possible_ip[@]}
             if [ \$no_of_ip -ne \"1\" ];then
                 echo \"Multiple Host IP found for the name you gave. Please be more specific.\"
             elif [ \$no_of_ip -lt \"1\" ];then
                 echo \"No IP Found for that. Please try again with more accurate info.\"
             else
                #python \$scripts_path/python/autologin.py \$possible_ip |html2text |html2text |sed -e 's/_/ /g' | sed -e 's/Â//g' | sed -e 's/|\\ .*|//g'
                #python \$scripts_path/python/autologin.py \$possible_ip |html2text |html2text
#python /home/parmil/myscripts/python/inventory.py \$possible_ip | html2text | html2text  | grep ^\\|....\\|.*________________\\| | sed -e 's/_/ /g' | sed -e 's/|/ /g'|column -t
python \$scripts_path/python/inventory.py \$possible_ip | html2text | html2text  | grep ^\\|....\\|\\[^\\ ]*\\| |column -t |sed -e 's/_/ /g'

python \$scripts_path/python/inventory.py \$possible_ip | grep -A 100 \"<CAPTION><B>SFP</B></CAPTION>\" | grep \"TH\" | sed -e 's/<TH >//g' | sed -e 's/<\\/TH>//g' | sed -e 's/<INPUT TYPE=BUTTON VALUE=.*(.*)\" \\?>//g'  | sed -e 's/&nbsp;//g' | sed -e 's/<TD >//g' |sed -e 's/<\\/TD>/  /g'|sed -e 's/<BR>/  /g' | grep -v \"Name Port Operational Status\" |column -t
                 fi
fi
}

function cef5 () { 
#++# cef5 : gives slot numbers in which CEF5 are up from UI.Its being used by nall function.
if [ \"\$1\" == \"\" ];then
echo Input some part of ip or complete ip.
else
             possible_ip=(\$(fip143 \"\$@\"))
             no_of_ip=\${#possible_ip[@]}
             if [ \$no_of_ip -ne \"1\" ];then
                 echo \"Multiple Host IP found for the name you gave. Please be more specific.\"
             elif [ \$no_of_ip -lt \"1\" ];then
                 echo \"No IP Found for that. Please try again with more accurate info.\"
             else
                #python \$scripts_path/python/autologin.py \$possible_ip |html2text |html2text |sed -e 's/_/ /g' | sed -e 's/Â//g' | sed -e 's/|\\ .*|//g'
                 python \$scripts_path/python/inventory.py \$possible_ip |html2text |html2text|sed -e s/_//g | grep CEF-5 | grep -v Not | cut -f2 -d '|' | tr '\\n' ' '
             fi
fi
}
function nodes () { 
#++# nodes : it will give you all live nodes in one ip range(subnet example 143 or 241 subnet)
    if [[ \$1 = *.*.*.* ]] ; then
        ip_range=\$1
    elif [[ \$1 = *.*.* ]] ; then
        ip_range=\$1.1
    elif [[ \$1 = *.* ]] ; then
        ip_range=192.\$1.1
    elif [[ \$1 -lt 255 ]] ; then
        ip_range=192.168.\$1.1
    fi
if [ \"\$1\" == \"\" ];then
echo Input IP_Range
else
nmap --open -p U:20080,T:20080 \$ip_range/24 |grep -v \"is closed\"|grep -o '[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}'
fi
}
function goct () { 
#++# goct : generates octave scripts for creating graphs wrt different variables
    \$scripts_path/generic_octave_script_generator.sh \$@
}
function cmc () { 
#++# cmc : checkout mirror compile for given targets.
local total_args=\$#
local all_args=\$@
if [[ \"\$total_args\" -lt \"3\" ]]; then
    echo \"Usage: cmc -dir=<path to checkout> Branch-Name -tag=(optional) -target=cef5 xcc360g etc..(Optional. But -target= should be last parameter)\"
    return
fi

 checkout_command=\${all_args%%-target=*}
if [[ \$all_args =~ \"target\" ]]; then
     targets=\${all_args##*target=}
    else
     targets=\"xcc360g cef5\"
fi
 checkout_path=\${all_args##*-dir=}
checkout_path=\${checkout_path%% *}
 mirror_path=\${checkout_path%/*}
echo \"Targets are : \$targets\"
echo \"Checkout path is : \$checkout_path\"
echo \"Mirroring path is : \$mirror_path\"
echo \"Checkout command is : \$checkout_command\"
if [[ -e \"\$checkout_path\" ]]; then
    echo \"\$checkout_path Exists Already. Skipping the checkout process.\"
else
    ~/cm-utils/checkout \$checkout_command
fi

for target in \$targets; do
    if [[ -e \"\${mirror_path}/\${target}mirror\" ]]; then
        echo \"\${mirror_path}/\${target}mirror Already Exists. No need to mirror for this.\"
    else
        ~/cm-utils/mirror \$checkout_path \${mirror_path}/\${target}mirror
    fi
done

local chain_of_commands=\"\"

for target in \$targets; do

if [ \"\$thread\" == \"\" ];then
    thread=1
fi

 compile_dir=\${mirror_path}/\${target}mirror/tj100_mc/scripts
 compile_cmd=\$(get_compile_command \$target \$compile_dir \$thread)
if [ \"\$compile_cmd\" == \"\" ];then
    echo \"Unknown target Type. Please add this to the get_compile_command function.\"
    return
fi
       tab=\"--tab --title=\$target\"
       cmd=\"bash -c 'echo -en \\\"\\033\\]0;\$target\\a\\\" && cd \${mirror_path}/\${target}mirror/tj100_mc/scripts && \$compile_cmd ; bash ; echo -en \\\"\\033\\]0;\$target\\a\\\" ; '\"
      chain_of_commands+=(\$tab -e \"\$cmd\")         
done

gnome-terminal --maximize \"\${chain_of_commands[@]}\"
}

function _cmc()
{ ## autocompletion function for cmc
words=(cef5 xcc360g tj1700 plc01 osmc elan07 teraxc xa10g elan10 cef4 cef4C tj14xx tj14xxN -dir= -target= -tag=)
COMPREPLY=( \$(compgen -o dirnames -o filenames -W \"\$(for word in \${words[@]}; do echo \"\$word\"; done)\" -- \${COMP_WORDS[COMP_CWORD]}) )
}
complete -o nospace -F _cmc cmc cout


function kgcc () { 
#++# kgcc : kernelgcc, for compiling kernel modules writes the Makefile for all c file in that dir. Bit of hardcoded things. 
 present_c_files=\$(ls ./*.c 2> /dev/null | grep -v \".mod.c\")
if [[ \"\$present_c_files\" -eq \"\" ]]; then
    echo \"Unable to find any eligible c file. Make sure you haven't named you c file with *.mod.c extention. By default we ignore these files.\"
    return 1;
fi
echo -n > Makefile
for filename in \$present_c_files
do
     filename=\${filename%.*}
    echo  \"obj-m += \$filename.o\" >> Makefile
done

echo -n \"
all:
    make -C /lib/modules/2.6.32-38-generic/build M=\\\$(PWD) modules
clean:
    make -C /lib/modules/2.6.32-38-generic/build M=\\\$(PWD) clean
\" >> Makefile
make
chmod 777 *.ko
}

function st() { 
#++# st : set-title, it will set title of a terminal.
  if [[ -z \"\$ORIG\" ]]; then
    ORIG=\$PS1
  fi
  TITLE=\"\\[\\e]2;\$@\\a\\]\"
  PS1=\${ORIG}\${TITLE}
}

function nall() { 
#++# nall : nodeall, it will start tailing all logs of a node. including xcc and cef5 also.
 possible_cef5_slots=(\$(cef5 \"\$@\"))
 chain_of_commands=\"\"

 tab=\"--tab --title=NODE-\$@-XCC\"
 node_cmd=\"\$scripts_path/node \$@\"
# cmd=\"bash -c 'echo -en \\\"\\033\\]0;\$@\\a\\\" && \$node_cmd ; bash ; echo -en \\\"\\033\\]0;\$@\\a\\\" ; '\"
 cmd=\"bash -c ' \$node_cmd ; bash ;'\"
chain_of_commands+=(\$tab -e \"\$cmd\")
 slot_cmd=\"\"
if [[ \"\$possible_cef5_slots\" -ne \"\" ]];then
    for slot in \${possible_cef5_slots[@]}
    do
        slot_cmd=\"\$scripts_path/node \$@ \$slot\"
        tab=\"--tab --title=NODE-\$@-SLOT-\$slot\"
        # cmd=\"bash -c 'echo -en \\\"\\033\\]0;node\$@slot\$slot\\a\\\" && \$slot_cmd ; bash ; echo -en \\\"\\033\\]0;node\$@slot\$slot\\a\\\" ; '\"
         cmd=\"bash -c ' \$slot_cmd ; bash ; '\"
        chain_of_commands+=(\$tab -e \"\$cmd\")
    done
fi
gnome-terminal  --maximize \"\${chain_of_commands[@]}\"
}


function mgc() 
#++# mgc : modified gcc, compile c file and generate .out file with same name and run it.
{
     null_value=\"\";
     least_no_of_arguments=\"1\";
     source_code_file_to_be_compiled=\$1;
     generated_output_file=\$2;
     extension=\${source_code_file_to_be_compiled##*.}
    if [[ \$generated_output_file -eq \$null_value ]]; then
        {
            generated_output_file=\${source_code_file_to_be_compiled/%.*/.out};
        }
    fi

    if [[ \$# -lt \$least_no_of_arguments ]]; then
        {
            echo \"Usages: mgc src_code output(optional)\"
            return;
        }
    fi
    if [[ \"\$extension\" == \"c\" ]];then
       gcc \$source_code_file_to_be_compiled -g -o \$generated_output_file
    elif [[ \"\$extension\" == \"cpp\" ]];then
       g++ \$source_code_file_to_be_compiled -g -o \$generated_output_file
    else
       echo \"Unknown extension type. Please add in the fxn.\"
    fi
#     ./\$generated_output_file
}

function gts() 
{
#++# gts : git status for all the modules from dir where taginfo is present
    #putting gta so that it can goto tagfile
    gta
     temp=\$(readlink -e ./taginfo)
    temp=\${temp%taginfo}
    cd \$temp
    if ! [ -e './taginfo' ]; then
        echo \"No taginfo file found in current directory.\"
        return
    else
         checkout_path=\$(readlink -e ./)
    fi
 tagfile=\$checkout_path/taginfo
 versionfile=\$checkout_path/versioninfo
 current_branch_name=\$(cat \$versionfile | grep module_name | cut -f2 -d ' ')
 current_branch_tag=\$(cat \$versionfile | grep tag | cut -f2 -d ' ')
echo \"Your current_branch_name is : \$current_branch_name\"
echo \"Your current_branch_tag is : \$current_branch_tag\"
declare -a all_modules=\$(cat \$tagfile | awk '{OFS=\"\\t\"; print \$2}' | grep -v -- \"----\\|Component\\|LINUX\")
for module in \${all_modules[@]}
    do
        pushd \${checkout_path}/\$module* 2>/dev/null > /dev/null #have added * so that it will go to min. matching module.
         module_push_status=\$?
        if [ \$module_push_status -eq 0 ]; then

             pwdmodule=\$(pwd)
            pwdmodule=\${pwdmodule#\$(echo \"\$checkout_path\")/}
            echo \"Module \$pwdmodule\"
            git status
            popd > /dev/null
        else
            echo \"Not able to go to module : \${checkout_path}/\$module\";
        fi
done

}

function gtsp()
{
#++# gtsp : git status & pull, frist will goto module git status , git stash , git pull, git stash pop.
    #putting gta so that it can goto tagfile
    gta
     temp=\$(readlink -e ./taginfo)
    temp=\${temp%taginfo}
    cd \$temp
    if ! [ -e './taginfo' ]; then
        echo \"No taginfo file found in current directory.\"
        return
    else
         checkout_path=\$(readlink -e ./)
    fi
 tagfile=\$checkout_path/taginfo
 versionfile=\$checkout_path/versioninfo
 current_branch_name=\$(cat \$versionfile | grep module_name | cut -f2 -d ' ')
 current_branch_tag=\$(cat \$versionfile | grep tag | cut -f2 -d ' ')
echo \"Your current_branch_name is : \$current_branch_name\"
echo \"Your current_branch_tag is : \$current_branch_tag\"
declare -a all_modules=\$(cat \$tagfile | awk '{OFS=\"\\t\"; print \$2}' | grep -v -- \"----\\|Component\\|LINUX\")
for module in \${all_modules[@]}
    do
        pushd \${checkout_path}/\$module* 2>/dev/null > /dev/null #have added * so that it will go to min. matching module.
         module_push_status=\$?
        if [ \$module_push_status -eq 0 ]; then

             pwdmodule=\$(pwd)
            pwdmodule=\${pwdmodule#\$(echo \"\$checkout_path\")/}
            echo \"Module \$pwdmodule\"
            git status
            git stash
            git pull
            git stash pop
            popd > /dev/null
        else
            echo \"Not able to go to module : \${checkout_path}/\$module\";
        fi
done

}


function reverse_recursive_search () { 
#++# reverse_recursive_search : search recursively backwards for certain file. return null if not found else will return relative path.
   slashes=\${PWD//[^\\/]/}
   directory=\"\$PWD\"
  for (( n=\${#slashes}; n>=0; --n ))
  do
    test -e \"\$directory/\$1\" && echo \"\$directory/\$1\" && return 
    directory=\"\$directory/..\"
  done
}

function mkc () { 
#++# mkc : will mkeenv so that can run make clean in any dir.
if [[ \"\$#\" -lt 1 ]]; then
    echo \"Usage: mkc target building_for_type(Optional: host(for simulator) or target, default is target)\"
    return
fi
 target=\$1
 building_for_type=\$2
if [ \"\$building_for_type\" == \"\" ];then
    building_for_type=\"target\"
fi
 rel_path=\$(reverse_recursive_search taginfo)

if [[ \"\$rel_path\" == \"\" ]]; then
    echo \"Not able to locate taginfo. Doesn't seem to be checkout or mirror area.\"
    return
else
    rel_path=\${rel_path%/*}
    echo \"rel_path is \$rel_path\"
fi

pushd \$rel_path > /dev/null
 taginfo_path=\$(pwd)
popd > /dev/null

 src_path=\${taginfo_path}
 src_path=\${src_path}/tj100_mc/src
echo \"src path is \$src_path\"
case \"\$target\" in
  cef5|xcc360g|tj1700|plc01|osmc|elan07|teraxc|xa10g|elan10|cef4|cef4C|tj14xx|tj14xxN)
  echo \"Changing Dir to \$src_path\"
  echo \"Target is \$target\"
  pushd \$src_path > /dev/null
  export SOFTWARE_ROOT=\$PWD/
  source \$SOFTWARE_ROOT/../scripts/makeenv
  makeenv \$target \$building_for_type LINUX26 \$SOFTWARE_ROOT NO NO
  export SMART_TIDL=YES
  export DEBUG_SMART=YES
  popd > /dev/null
  echo \"Ready for make clean commands for target.\"
    ;;
    *)
    echo \"Unknown target Type. Please add this to the mkc function.\"
    return;
esac

}


function _mkc()
{ ## autocompletion function for mkc
     targets=(cef5 xcc360g tj1700 plc01 osmc elan07 teraxc xa10g elan10 cef4 cef4C tj14xx tj14xxN)
case \$COMP_CWORD in
        1) COMPREPLY=( \$(compgen -W \"\$(for target in \${targets[@]}; do echo \"\$target\"; done)\" -- \${COMP_WORDS[COMP_CWORD]}) );;
        2) COMPREPLY=( \$(compgen -W \"\$(echo host ; echo target)\" -- \${COMP_WORDS[COMP_CWORD]}) );;
esac

}
complete -o nospace -F _mkc mkc

function mk () {
#++# mk : make daemons for uml(not talking about the bashrc internal fxn uml.).
if [[ \"\$#\" -lt 1 ]]; then 
    echo \"Usage: mk daemon target(Optional: will automatically detect.inputs:tj1700 or tj160032. Just given in case if not able to detect.)\"
    return
fi
echo \"Please do makeenv before proceeding further. Timer is running use ctrl + C if makeenv not done.\"
for tick in 3 2 1
do
   echo \$tick
   sleep 1s
done
echo \"Lets Do This!!!\"

gta # trying to locate the taginfo.
if [ -e taginfo ];then
    echo \"Proceeding to do make\"
else
    echo \"It don't seems to be anykind of checkout area or mirror.\"
    return
fi

if [ -L taginfo ];then #checking its checkout area or mirror.
    cd tj100_mc/src  #can replace cd with pushd if want to.
else
    echo \"It seems you are trying to do make in checkout area. If still want to proceed. I will not proceed. Write your own new fxn to do so :)\"
    return
fi

 daemon_name=\$1
if [ \"\$daemon_name\" == \"nm\" ];then #if1
 target=\$2
    if [ \"\$target\" == \"\" ];then #if2
        pushd app/tj1700/nm >> /dev/null
         lo_count=\$(ls -lrt *.lo | wc -l)
        popd >> /dev/null
        if [ \"\$lo_count\" != \"0\" ];then
            echo \"Seems target is tj1700\"
            target=\"tj1700\"
        else
            echo \"Seems target is tj160032\"
            target=\"tj160032\"
        fi
    fi #if2   
fi #if1

case \"\$daemon_name\" in
  gmpls|net|init)
    echo \"daemon dir app/common/\$daemon_name\"
    make -C app/common/\$daemon_name
    ;;
  nm)
    echo \"daemon dir app/\$target/nm\"
    make -C app/\$target/nm
    ;;
  ccs)
    echo \"daemon dir app/common/nm/ccs\"
    make -C app/common/nm/\$daemon_name
    ;;
  interfaces)
    echo \"dir interfaces\"
    make -C \$daemon_name
    ;;
    *)   
    echo \"Unknown daemon Type. Please add this to the mk function.\"
    return;
esac
}

function _mk()
{ ## autocompletion function for mk
     words=(gmpls net init nm ccs interfaces tj1700 tj160032)
     COMPREPLY=( \$(compgen -W \"\$(for word in \${words[@]}; do echo \"\$word\"; done)\" -- \${COMP_WORDS[COMP_CWORD]}) )
}
complete -F _mk mk

function gta () {
#++# gta : goto_taginfo_area, pushd the taginfo dir. basically search for taginfo recursively and goto that.
 target=\$1
 rel_path=\$(reverse_recursive_search taginfo)

if [[ \"\$rel_path\" == \"\" ]]; then
    echo \"Not able to locate taginfo. Doesn't seem to be checkout or mirror area.\"
    return 1
else
    rel_path=\${rel_path%/*}
fi
pushd \$rel_path > /dev/null

}

function gca () {
#++# gca : goto_checkout_area , pushd checkout area for same mirror.
 path_relative_to_taginfo=\$(crp taginfo)
path_relative_to_taginfo=\${path_relative_to_taginfo#\\/}
gta
if [[ \"\$?\" == \"0\" ]];then
  temp=\$(readlink -e ./taginfo)
  temp=\${temp%taginfo}
  popd > /dev/null
  pushd \${temp}\${path_relative_to_taginfo} >> /dev/null
else
    rcd
fi
}

function gma () {
#++# gma : goto_mirror_area, pushd mirror area using mirror_list. first have generate mirrorlist.
 goto_mirror=\$@
 path_relative_to_taginfo=\$(crp taginfo)
#path_relative_to_taginfo=\${path_relative_to_taginfo#\\/} #not sure what will _gma will send. path//other_path works.

if [ \"\$goto_mirror\" == \"\" ];then
    taginfo_relative_path=\$(reverse_recursive_search taginfo)
    if [[ \"\$taginfo_relative_path\" == \"\" ]];then
         echo \"It doesn't seem to be a checkout area. Reading Universal Mirror List.\"
         mirrors=(\$(cat \${universal_mirrors_file}))
         total_results=\${#mirrors[@]}
         echo \"Found \$total_results Mirrors. Which one to pursue?\"
         for((index=0;index<\$total_results;index++))
          do
             echo \"\$index  \${mirrors[\$index]}\"
          done
         echo \"Please Enter index no. That would be selected to navigate.\"
         read choice
         while (( choice < 0 || choice >= total_results ))
          do
              echo \"Invalid index. Enter again.\"
              read choice
          done
         pushd \${mirrors[\$choice]} >>/dev/null
         return
    fi
     taginfo_absolute_path=\$(readlink -e \$taginfo_relative_path)
    taginfo_absolute_path=\${taginfo_absolute_path%taginfo}

    if ! [[ -e \${taginfo_absolute_path}\${mirrors_of_checkout_file} ]];then
          echo \"It seems you haven't created/updated mirrors_list file. Please Run fxn -> uml (=update_mirror_list)\"
          return
    fi

    readarray -t mirrors <<< \"\$(cat \${taginfo_absolute_path}\${mirrors_of_checkout_file})\"
     total_results=\${#mirrors[@]}

    if [[ \"\$total_results\" != \"1\" ]]; then
        echo \"Found \$total_results Mirrors. Which one to pursue?\"
           for((index=0;index<\$total_results;index++))
           do
               echo \"\$index  \${mirrors[\$index]}\"
           done
        echo \"Please Enter index no. That would be selected to navigate.\"
        read choice
            while (( choice < 0 || choice >= total_results ))
            do
                echo \"Invalid index. Enter again.\"
                read choice
            done
        pushd \${mirrors[\$choice]}\${path_relative_to_taginfo} >>/dev/null

    elif [[ \"\$total_results\" == \"1\" ]] && [[ \"\${mirrors}\" != \"\" ]]; then
         pushd \${mirrors}\${path_relative_to_taginfo} >>/dev/null
    else
         echo \"No mirrors found for this checkout area.\"
         return
    fi
else
    pushd \${goto_mirror}\${path_relative_to_taginfo} >> /dev/null
    if [ \"\$?\" != \"0\" ];then
        echo \"Unable to change to mirror.\"
        return
    fi
fi
}
function _gma()
{ ## autocompletion function for gma
         taginfo_relative_path=\$(reverse_recursive_search taginfo)
        if [[ \"\$taginfo_relative_path\" == \"\" ]];then
              echo \"It doesn't seem to be a checkout area.\"
              return
        fi
         taginfo_absolute_path=\$(readlink -e \$taginfo_relative_path)
        taginfo_absolute_path=\${taginfo_absolute_path%taginfo}

        if ! [[ -e \${taginfo_absolute_path}\${mirrors_of_checkout_file} ]];then
              echo \"It seems you haven't created/updated mirrors_list file. Please Run fxn -> uml (=update_mirror_list)\"
              return
        fi

        readarray -t mirrors <<< \"\$(cat \${taginfo_absolute_path}\${mirrors_of_checkout_file})\"
         total_results=\${#mirrors[@]}
        if [[ \"\$total_results\" == \"0\" ]]; then
             echo \"No mirrors found for this checkout area.\"
             return
        fi
        IFS=\$'\\n' tmp=( \$(compgen -o dirnames -W \"\$(for((index=0;index<\$total_results;index++)); do echo \"\${mirrors[\$index]}\"; done)\" -- \"\${COMP_WORDS[\$COMP_CWORD]}\" ))
         COMPREPLY=( \"\${tmp[@]}\" )
}
complete -o nospace -F _gma gma

function uml () {
#++# uml : update_mirror_list, update the mirrors list in checkout areas and create if don't exist.
readarray -t taginfo_files <<< \"\$(locate -b '\\taginfo' | grep -v \"CVSROOT\")\"
 total_results=\${#taginfo_files[@]}
if [[ \"\$total_results\" == \"0\" ]]; then
    echo \"NO Checkout or mirror area found.\"
    return
fi
echo \"Resetting Universal Checkout, Mirrors & Orphan Mirrors List.\"
echo -n > \$universal_mirrors_file
echo -n > \$universal_checkouts_file
echo -n > \$universal_orphan_mirrors_file

for taginfo_file in \${taginfo_files[@]}
do
    if ! [ -L \$taginfo_file ];then
         checkout_area=\${taginfo_file%taginfo}
        echo \"Resetting mirror_list for \$checkout_area\"
        echo -n > \${checkout_area}\${mirrors_of_checkout_file}
        if [ \"\$?\" == \"0\" ];then
        	echo \"\$checkout_area\" >> \$universal_checkouts_file
		fi
    fi
done

for taginfo_file in \${taginfo_files[@]}
do
    if [ -L \$taginfo_file ];then
         mirror_name=\${taginfo_file%taginfo}
        echo \"Creating Entry of mirror \$mirror_name to proper mirror list.\"
        local corresponding_checkout_area=\$(readlink -e \$taginfo_file)
        readlink -e \$taginfo_file >> /dev/null
        if [ \"\$?\" == \"0\" ];then
             corresponding_checkout_area=\${corresponding_checkout_area%taginfo}
             echo \"\$mirror_name\" >> \${corresponding_checkout_area}\${mirrors_of_checkout_file}
             if [ \"\$?\" == \"0\" ];then
                 echo \"\$mirror_name\" >> \$universal_mirrors_file
             fi
        else
             echo \"Found Orphan Mirror \$mirror_name. Saving it to Universal Mirrors Without Checkout List.\"
             echo \"\$mirror_name\" >> \$universal_orphan_mirrors_file
        fi
    fi
done
}

function cmpl () {
#++# cmpl : Start compilation for all targets or current target.Can give no. of threads also.
 thread=\$1
local rel_path=\$(reverse_recursive_search taginfo)

if [[ \"\$rel_path\" == \"\" ]]; then
    echo \"Not able to locate taginfo. Doesn't seem to be checkout or mirror area.\"
    return
else
    rel_path=\${rel_path%/*}
fi

pushd \$rel_path/.. > /dev/null

targets=\$(ls -1 | grep mirror)
mirror_path=\$(pwd)

local chain_of_commands=\"\"

for target in \$targets; do

if [ \"\$thread\" == \"\" ];then
    thread=1
fi

 compile_dir=\${mirror_path}/\${target}/tj100_mc/scripts
local compile_cmd=\$(get_compile_command \${target%%mirror*} \$compile_dir \$thread)
if [ \"\$compile_cmd\" == \"\" ];then
    echo \"Unknown target Type. Please add this to the get_compile_command function.\"
    return
fi
     local  tab=\"--tab --title=\$target\"
       cmd=\"bash -c 'echo -en \\\"\\033\\]0;\$target\\a\\\" && cd \${mirror_path}/\${target}/tj100_mc/scripts && (\$compile_cmd) ; bash ; echo -en \\\"\\033\\]0;\$target\\a\\\" ; '\"
      chain_of_commands+=(\$tab -e \"\$cmd\")
done
gnome-terminal --maximize \"\${chain_of_commands[@]}\"
}

function pbc () {
#++# pbc : Print .bashrc changes, It will print all custom bashrc fxn & all.
        cat \$user_bashrc | sed '0,/#%%%%#/d'
}
function pfs () {
#++# pfs : Password File Search, search in password file & print the result.
    cat \$password_manager_file | awk '{print \$1 \" \" \$2 }' | grep -i \"\$*\"
}
function ems () {
#++# ems : ssh -X to ems server(230.153).
     ems_ip=\"192.168.230.153\"
    echo \"Login to EMS Server \$ems_ip Username: root, Password: name . Run : \"
    echo \"java -jar /opt/ems/release/ems.jar\"
    s \$ems_ip
}
function nms () {
#++# nms : Open NMS in Firefox.
     nms_ip=\"192.168.230.157\"
    echo NMS: Username: administrator Password: iltwat@123
    firefox \"http://\$nms_ip:8080/webnms/\"
}
function crp () {
#++# crp : Current Relative Path, Show current path from taginfo file.
 search_for=\$1
if [[ \"\$search_for\" == \"\" ]]; then
    echo \"Usage : crp searchkeyword(dir/filename)\"
    return
fi
     current_path=\$(pwd)
    #do gsd
     gsd_status=\$(gsd \$search_for)
    gsd_status_word_count=\$(echo -n \$gsd_status | wc -w)
    if [ \$gsd_status_word_count -eq 0 ];then
        gsd \$search_for
         result_path=\$(pwd)
        popd >> /dev/null
        relative_path=\${current_path#\$result_path}
        echo \$relative_path
    fi
}
function rcd () {
#++# rcd : Relative cd , goto same code area taken reference from taginfo file.
     keyword=\$1
     current_path=\$(pwd)
     path_relative_to_taginfo=\$(crp taginfo)
if [ \"\$keyword\" != \"\" ];then
#        echo \"Usage: rcd anykeyword(file/dir) relative to that we will try to change dir.\"
#        return
#    fi
     gsd_status=\$(gsd \$keyword)
     gsd_status_word_count=\$(echo -n \$gsd_status | wc -w)
    if [ \$gsd_status_word_count -ne 0 ];then
        echo \$gsd_status
        return
    fi
    gsd \$keyword
     temp_path1=\$(pwd)
    readarray -t currarr <<< \"\$(current_path=\${current_path#\\/} ; echo \$current_path  | sed -e 's/\\//\\n/g')\"
     currlen=\${#currarr[*]}
    readarray -t temparr <<< \"\$(temp_path1=\${temp_path1#\\/} ; echo \$temp_path1  | sed -e 's/\\//\\n/g')\"
     templen=\${#temparr[*]}
    for ((dir_no=0;dir_no<\$currlen;dir_no++)) #can't decide how long the dir will be so starting from 0
    do
        cd \${currarr[\$dir_no]} 2> /dev/null
    done
    status=\$?
    if [ \"\$status\" != \"0\" ];then
        echo \"Not able to change properly. You can still do popd.\"
    fi
else
    readarray -t results <<< \"\$(cat \$universal_checkouts_file)\"
     total_results=\${#results[@]}
    if [[ \"\$total_results\" != \"1\" ]]; then
        echo \"Found \$total_results Checkout Areas in Your PC. Which one to pursue?\"
        for((index=0;index<\$total_results;index++))
        do
            echo \"\$index  \${results[\$index]}\"
        done
        echo \"Please Enter index no. That would be selected to navigate.\"
        read choice
        while (( choice < 0 || choice >= total_results ))
        do
            echo \"Invalid index. Enter again.\"
            read choice
        done
        pushd \${results[\$choice]}\${path_relative_to_taginfo} >>/dev/null
    elif [[ \"\$total_results\" == \"1\" ]] && [[ \"\${results}\" != \"\" ]]; then
         pushd \${results}\${path_relative_to_taginfo} >>/dev/null
    else
        echo \"Found Nothing in Universal Checkout file. Please run uml\"
        return
    fi

fi
}

function _rcd()
{ ## autocompletion function for rcd
         taginfo_relative_path=\$(reverse_recursive_search taginfo)
        if [[ \"\$taginfo_relative_path\" == \"\" ]];then
             cur=\${COMP_WORDS[COMP_CWORD]}
             COMPREPLY=( \$(compgen -o dirnames  -- \$cur) )
            return
        fi
         taginfo_absolute_path=\$(readlink -e \$taginfo_relative_path)
        taginfo_absolute_path=\${taginfo_absolute_path/taginfo/..}
        IFS=\$'\\n' tmp=( \$(compgen -o dirnames -W \"\$(ls \"\$taginfo_absolute_path\")\" -- \"\${COMP_WORDS[\$COMP_CWORD]}\" ))
        COMPREPLY=( \"\${tmp[@]// /\\ }\" )
}
complete -o nospace -F _rcd rcd

function gsd () {
#++# gsd : Goto Selected Directory , pass a keyword(dir/filename) reverse lookup will be done & dir change accordingly.
 search_for=\$1
if [[ \"\$search_for\" == \"\" ]]; then
    echo \"Usage : gsd keyword(dir/filename)\"
    return
fi

 rel_path=\$(reverse_recursive_search \$search_for)
if [[ \"\$rel_path\" == \"\" ]]; then
    echo \"Not able to locate \$search_for recursively.\"
    return
else
    if [ -f \$rel_path ];then
        rel_path=\${rel_path%/*}
    fi    
fi
pushd \$rel_path > /dev/null
}

function lcd () {
#++# lcd : Locate & cd, Pass some keyword/filename & it will be searched in current dir context & goto that dir.
 search_for=\$1
if [[ \"\$search_for\" == \"\" ]]; then
    echo \"Usage : lcd keyword(dir/filename)\"
    return
fi
readarray -t results <<< \"\$(locate \$(pwd)*\${search_for})\"
 total_results=\${#results[@]}
if [[ \"\$total_results\" != \"1\" ]]; then
    echo \"Found \$total_results results. Which one to pursue?\"
    for((index=0;index<\$total_results;index++))
    do
        echo \"\$index  \${results[\$index]}\"
    done
    echo \"Please Enter index no. That would be selected to navigate.\"
    read choice
    while (( choice < 0 || choice >= total_results ))
    do
        echo \"Invalid index. Enter again.\"
        read choice
    done
    gsd \${results[\$choice]}
elif [[ \"\$total_results\" == \"1\" ]]; then
     gsd \${results}
else
    echo \"Found Nothing related to \$search_for\"
    return
fi
}

function get_compile_command () { #internal fxn.
if [ \"\$#\" -ne \"3\" ];then
    echo \"Usage : get_compile_command \\\$target \\\$compile_dir \\\$thread\"
    return
fi

 target=\$1
 compile_dir=\$2
 thread=\$3

case \"\$target\" in
  cef5)
local compile_cmd=\"./create_install -dir=\$compile_dir/../.. -swimg -cpu=ppc -target=\$target -kernel=LINUX26 -noupdate -nocheckout -db -pkt_switching=YES -l2_switching=YES -parallel=\$thread\"
    ;;
  xcc360g)
local compile_cmd=\"./create_install -dir=\$compile_dir/../.. -swimg -cpu=ppc -target=\$target -kernel=LINUX26 -noupdate -nocheckout -db -pkt_switching=YES -l2_switching=YES -parallel=\$thread\"
    ;;
  tj1700)
local compile_cmd=\"./create_install -dir=\$compile_dir/../.. -swimg -cpu=ppc -target=\$target -kernel=LINUX26 -noupdate -nocheckout -db -pkt_switching=YES -l2_switching=YES -parallel=\$thread\"
    ;;
  plc01)
local compile_cmd=\"./create_install -target=\$target -cpu=ppc -swimg -db -noupdate -dir=\$compile_dir/../../ -pkt_switching=YES -l2_switching=NO -kernel=LINUX26 -parallel=\$thread\"
    ;;
  osmc)
local compile_cmd=\"./create_install -dir=\$compile_dir/../../ -swimg -cpu=ppc -target=\$target -kernel=LINUX26 -noupdate -nocheckout -db -pkt_switching=YES -l2_switching=YES -parallel=\$thread\"
    ;;
  elan07)
local compile_cmd=\"./create_install -dir=\$compile_dir/../../ -target=\$target -swimg -cpu=ppc -nocheckout -maps -noupdate -smart=YES -kernel=LINUX24 -parallel=\$thread\"
    ;;
  teraxc)
local compile_cmd=\"./create_install -dir=\$compile_dir/../../ -swimg -cpu=ppc -target=\$target -kernel=LINUX26 -noupdate -nocheckout -db -maps -pkt_switching=YES -l2_switching=YES -gmpls=YES -otn=YES -parallel=\$thread\"
    ;;
  xa10g)
local compile_cmd=\"./create_install -dir=\$compile_dir/../../ -l2_switching=NO -verbose=5 -cpu=ppc -noupdate -pkt_switching=YES -target=\$target -kernel=LINUX26 -swimg -ssmgr=YES -db -build -parallel=\$thread\"
    ;;
  elan10)
local compile_cmd=\"./create_install -dir=\$compile_dir/../../ -l2_switching=NO -verbose=5 -cpu=ppc -noupdate -pkt_switching=YES -target=\$target -kernel=LINUX26 -swimg -ssmgr=YES -db -build -parallel=\$thread\"
    ;;
  cef4)
local compile_cmd=\"./create_install -dir=\$compile_dir/../../ -l2_switching=NO -verbose=5 -cpu=ppc -noupdate -pkt_switching=YES -target=\$target -kernel=LINUX26 -swimg -ssmgr=YES -db -build -parallel=\$thread\"
    ;;
  cef4C)
local compile_cmd=\"./create_install -dir=\$compile_dir/../../ -l2_switching=NO -verbose=5 -cpu=ppc -noupdate -pkt_switching=YES -target=\$target -kernel=LINUX26 -swimg -ssmgr=YES -db -build -parallel=\$thread\"
    ;;
  tj14xx)
local compile_cmd=\"./create_install -dir=\$compile_dir/../../ -l2_switching=NO -verbose=5 -cpu=ppc -noupdate -pkt_switching=YES -target=\$target -kernel=LINUX26 -swimg -ssmgr=YES -db -build -parallel=\$thread\"
    ;;
  tj14xxN)
local compile_cmd=\"./create_install -dir=\$compile_dir/../../ -noupdate -cpu=ppc -swimg -target=\$target -l2_switching=NO -nocheckout -db -pkt_switching=YES -kernel=LINUX26 -parallel=\$thread\"
    ;;
    *)
#    echo \"Unknown target Type. Please add this to the compile function.\"
#     should return null if target not found
    return;
esac
compilation_log=\"\$compile_dir/../../\${target}_compilation.log\"
cftf=\"\$compile_dir/../../\$compile_for_type_file\"
echo \"echo \$target > \$cftf ; echo -n > \$compilation_log ; tail -f \$compilation_log & backgroundPID=\\\$! ; onINT() { kill -9 \\\$backgroundPID 2>/dev/null; }; trap \"onINT\" SIGINT ; \$compile_cmd >> \$compilation_log 2>&1 && python \$sms_sending_script \$my_mobile_no \\\"BUILD READY FOR TARGET \${target} IN \${compile_dir%/tj100_mc*} \\\" || python \$sms_sending_script \$my_mobile_no \\\"BUILD BREAK FOR TARGET \${target} IN \${compile_dir%/tj100_mc*}\\\"\"
#echo \"\$compile_cmd\"
}

function mc () {
#++# mc : Mirror & Compile, cmc does checkout also. but written so that mirror and compile only be done.
if [ \"\$#\" -lt \"1\" ];then
    echo \"Usage : mc targets (example cef5 xcc360g etc.)\"
    return
fi
 targets=\"\$@\"
    gta
     temp=\$(readlink -e ./taginfo)
    temp=\${temp%taginfo}
    cd \$temp
     checkout_path=\$(readlink -e ./)
     rel_path=\$(reverse_recursive_search taginfo)
if [[ \"\$rel_path\" == \"\" ]]; then
    echo \"Not able to locate taginfo. Doesn't seem to be checkout or mirror area.\"
    return
else
    rel_path=\${rel_path%/*}
fi
pushd \$rel_path/.. > /dev/null
mirror_path=\$(pwd)

for target in \$targets; do
    if [[ -e \"\${mirror_path}/\${target}mirror\" ]]; then
        echo \"\${mirror_path}/\${target}mirror Already Exists. No need to mirror for this.\"
    else
        ~/cm-utils/mirror \$checkout_path \${mirror_path}/\${target}mirror
    fi
done
popd > /dev/null
cmpl
}

cimg () 
{ 
#++# cimg : Combine_latest of images.
    fresh_token=\$1
    taginfo_relative_path=\$(reverse_recursive_search taginfo);
    if [[ \"\$taginfo_relative_path\" == \"\" ]]; then
        echo \"It doesn't seem to be a checkout area.\";
        return;
    fi;
    taginfo_absolute_path=\$(readlink -e \$taginfo_relative_path);
    taginfo_absolute_path=\${taginfo_absolute_path%taginfo};
    if ! [[ -e \${taginfo_absolute_path}\${mirrors_of_checkout_file} ]]; then
        echo \"It seems you haven't created/updated mirrors_list file. Please Run fxn -> uml (=update_mirror_list)\";
        return;
    fi;
    readarray -t mirrors <<< \"\$(cat \${taginfo_absolute_path}\${mirrors_of_checkout_file})\";
    echo \"Resetting \$outer_latest_image & \$inner_latest_image\"
    echo -n > \${taginfo_absolute_path}/\$outer_latest_image
    echo -n > \${taginfo_absolute_path}/\$inner_latest_image
    echo -n > \${taginfo_absolute_path}/\$final_inner
    echo -n > \${taginfo_absolute_path}/\$final_outer
    timestamp_override_outer=\"0\"
    timestamp_override_inner=\"0\"
    total_results=\${#mirrors[@]};
    if [[ \"\$total_results\" != \"1\" ]]; then
        echo \"Found \$total_results Mirrors. Creating list of latest builds present in them.\";
        for ((index=0; index<\$total_results; index++))
        do
            this_mirror_latest=\$(ls -1rt \${mirrors[\$index]}*.img |grep -v \"download\\|\$combined_image_keyword\"| tail -n 1)
            this_mirror_latest_type=\${this_mirror_latest##*\\/}
            this_mirror_latest_type=\${this_mirror_latest_type%%[\$image_name_delimeters]*}
            if [[ \"\$(should_this_be_outer_image \$this_mirror_latest_type)\" == \"yes\" ]];then
            	echo \"\$this_mirror_latest\" >> \${taginfo_absolute_path}/\$outer_latest_image
            	if [ -e \${mirrors[\$index]}/\$timestamp_override_token ];then
            		echo \"\$this_mirror_latest\" > \${taginfo_absolute_path}/\$final_outer
            		let timestamp_override_outer=timestamp_override_outer+1
            	fi
            else
            	echo \"\$this_mirror_latest\" >> \${taginfo_absolute_path}/\$inner_latest_image
            	if [ -e \${mirrors[\$index]}/\$timestamp_override_token ];then
            		echo \"\$this_mirror_latest\" > \${taginfo_absolute_path}/\$final_inner
            		let timestamp_override_inner=timestamp_override_inner+1
            	fi
            fi
        done;

        if [[ \"\$timestamp_override_outer\" == \"0\" ]];then
        	ls -1rt \$(cat \${taginfo_absolute_path}/\$outer_latest_image) | tail -n 1 > \${taginfo_absolute_path}/\$final_outer
        fi

        if [[ \"\$timestamp_override_inner\" == \"0\" ]];then
        	ls -1rt \$(cat \${taginfo_absolute_path}/\$inner_latest_image) | tail -n 1 > \${taginfo_absolute_path}/\$final_inner
        fi
        
        temp_outer=\$(cat \${taginfo_absolute_path}/\$final_outer)
        outer_dir=\${temp_outer%\\/*}
        outer_file=\${temp_outer##*\\/}
        temp_inner=\$(cat \${taginfo_absolute_path}/\$final_inner)
        inner_dir=\${temp_inner%\\/*}
        inner_file=\${temp_inner##*\\/}
        inner_type=\${inner_file%%[\$image_name_delimeters]*}
        outer_type=\${outer_file%%[\$image_name_delimeters]*}
        path_to_mksquashfs=\"\$outer_dir/tj100_mc/scripts\"
        if [[ \"\$fresh_token\" == \"t\" ]];then
        	epoch_timestamp=\$(date +%s)
            combined_image_name=\"\${outer_type}-\${combined_image_keyword}-\${inner_type}-\${epoch_timestamp}.squash.img\"
        elif [[ \"\$fresh_token\" == \"\" ]];then
        	combined_image_name=\"\${outer_type}-\${combined_image_keyword}-\${inner_type}-constant_name.squash.img\"
        else
        	combined_image_name=\"\${outer_type}-\${combined_image_keyword}-\${inner_type}-\${\$fresh_token}.squash.img\"
        fi
        pushd \$outer_dir >/dev/null
        rm -rf \$outer_dir/\$image_extraction_dir 2>/dev/null
        echo \"Extracting \$outer_file\"
        tar -xzvf \${outer_file/.squash.img/.tgz}
        mkdir -p \$outer_dir/\$image_extraction_dir/\$inner_type
        cp \${temp_inner} \$outer_dir/\$image_extraction_dir/\$inner_type/\${inner_type}.squash.img
        cp \${temp_inner}.md5 \$outer_dir/\$image_extraction_dir/\$inner_type/\${inner_type}.squash.img.md5
        tj100_mc/scripts/create_squashfsimg.sh \$image_extraction_dir \$combined_image_name tj100_mc/scripts
        echo \"Combined the images successfully.\"
        ls -lrt
    else
        if [[ \"\$total_results\" == \"1\" ]] && [[ \"\${mirrors}\" != \"\" ]]; then
            echo \"Only Single Mirror is there. At least one Control Card & one Line Card Image is needed to combine.\"
            return;
        else
            echo \"No mirrors found for this checkout area.\";
            return;
        fi;
    fi;
}
function him () {
#++# him : ssh -X to himalya build server
\$scripts_path/gas 192.168.17.59 tj100rel reltj100
}

function sms () {
#++# sms : send sms to anyone.
echo \"Usage: sms Mobile_NO   Message.\"
mobile_no=\$1
if ! [[ \$mobile_no =~ \$renum ]];then
     echo \"Seems to be invalid MObile NO.\"
     return
fi

if  [[ \${#mobile_no} -ne 10 ]];then
     echo \"Enter without 0 or +91 in front of no. Only 10 digit no. is acceptable.\"
     return
fi
all_arg=\$@
message=\${all_arg#\${mobile_no} }
echo \"Mobile NO : \$mobile_no\"
echo \"\"
echo \"Message : \$message\"
echo \"Message Length : \${#message}\"
if [[ \"\${#message}\" -gt \"135\" ]];then
   echo \"Message lenght should not exceed 135 chars.\"
   return
fi

python \$sms_sending_script \"\$mobile_no\" \"\$message\"

}
function ulmd () {
#++# ulmd : update local md5 database.
echo \"Updating mirror database.\"
uml
echo \"Resetting \$universal_local_md5_file\"
echo -n \"\" > \$universal_local_md5_file
for mirror_area in \$(cat \$universal_mirrors_file)
do
   all_images=(\$(ls -1rt \${mirror_area}*.squash.img 2>/dev/null| grep -v \"download\" ))
   if [ \${#all_images[@]} -eq 0 ];then
      echo \"\$mirror_area seems to be Host build area. No image found.\"
   else
   for image in \${all_images[@]}
   do
       if [ -e \${image}.md5 ];then
          echo \"Found md5 for \$image\"
          img_md5=\$(cat \${image}.md5)
          echo \"\$img_md5 \$image\" >> \$universal_local_md5_file
       else
          echo \"Have to calculate md5sum of image \$image\"
          md5sum \$image >> \$universal_local_md5_file
       fi
   done
   fi
done
}

function urmd () {
#++# urmd : update release md5 database
    echo \"Sending commands to release server so that it will create \$md5_temp_on_release_server\";
    \$scripts_path/md5relinfo \$release_server_ip \$release_server_username \$release_server_password \$md5_temp_on_release_server;
    echo \"Server has created \$md5_temp_on_release_server\";
    echo \"Downloading that to \$universal_release_md5_file\";
    echo -n > \$universal_release_md5_file;
    ncftpget -u\$release_server_username -p\$release_server_password \$release_server_ip ~/ \$md5_temp_on_release_server;
    echo \"Done. Updated Release MD5 Details to latest.\"
}

function unidb () {
#++# unidb : update nodes inventory database for predefined subnets in \$node_subnets. Store it at \$all_nodes_dir .
for subnet in \${node_subnets[@]}
do
     echo \"Subnet \$subnet\"
     for node_ip in \$(nodes \$subnet)
     do
          echo \"Node : \$node_ip\"
          nis \$node_ip > \${all_nodes_dir}/\$node_ip
     done
done
echo \"Node Inventory Database Updated. Stored at \$all_nodes_dir\"
}
function ca () {
#++# ca : crash analysis.
\$scripts_path/ca.sh \$1 \$2 \$3 \$4 \$5 \$6 \$7 \$8 \$9 \${10} \${11}
}
function slat () {
#++# slat : fully slat the given node.
\$scripts_path/slat \$1 \$2
}
function wl () {
#++# wl : web login, give ip of node will open new window for that node and login.
possible_ip=(\$(fip143 \"\$@\"))
if ping -c 1 \$possible_ip >/dev/null ;then echo \"Opening Web UI\"; else  echo \"Node is down. Retry again...\" ; return ; fi
python \$scripts_path/python/web_node.py \$possible_ip
}
############################################Keep New Functions Above This Line#################################################
function ? () {
#++# ? : Show all custom written functions from bashrc.
    cat \$user_bashrc | grep \"#++#\" | grep -v \"#--#\" |tr -d \"#++#\" | grep -i \"\$*\" |grep .*:
}

" > $generated_scripts_output_path/myscripts/bashrc
echo "Generated $generated_scripts_output_path/myscripts/bashrc "

echo -n "#!/usr/bin/expect
    set timeout 600
    set ip_part [lindex \$argv 0];
    set slot [lindex \$argv 1];
#   set icc_ip_second_byte [lindex \$argv 2];
    set user \"guest\";
    set user_pass \"iltwat\";
    set su_user \"root\";
    set su_user_pass \"swtn100tj\";
    set null_value \"\";
    set half_ip \"192.168.\";
    set port \"2023\";
    set compressed_file_dir \"/etc/name\";
    set compressed_file_name \"plc02_download.tgz\";
    set temp_dir \"/tmp/parmil\";
    set out_of_temp_dir \"/tmp\";
    set file_to_modify \"card_defns.sh\";
    set string_to_replace \"export SW_REMOTE_PATH_1=\\\\\\\"\\\\\\/etc\\\\\\/name\\\\\\/builds\\\\\\/cef5\\\\\\\"\";
    set replace_with \"export SW_REMOTE_PATH_1=\\\\\\\"\\\\\\/etc\\\\\\/name\\\\\\/builds\\\\\\/parmil\\\\\\\"\";
    

if {[llength \$argv] <= 2} {
puts \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\
\\n               Usages: Script_Name \\[Node_IP\\] \\[Slot_no\\]
\\
\\n               Node_IP : 102 will be treated as 192.168.143.102\\
\\n                         241.244 will be treated as 192.168.241.244\\
\\n                         169.200.100 will be treated as 192.169.200.100\\
\\n                         172.124.143.102 will be Taken as complete IP as it is given.\\n
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {[llength \$argv] < 2} { exit;
}
}

#flexible IP addressing
#So that u can provide 102 or 241.244 or 169.143.102 or 172.124.36.102 as IP.
    regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$ip_part all first second third fourth
if { \$fourth != \$null_value } {
   set ip \"\$all\"
} elseif { \$third != \$null_value } {
   set ip \"192\\.\$first\\.\$second\\.\$third\"
} elseif { \$second != \$null_value } {
   set ip \"192\\.168\\.\$first\\.\$second\"
} elseif { \$first != \$null_value } {
   set ip \"192\\.168\\.143\\.\$first\"
} else { puts \"Invalid IP\"; exit; }
puts \"\\n\\nNODE IP is \$ip \\n\";

spawn telnet \$ip \$port
set node_spawn_id_2 \$spawn_id
expect \"*login*\"
send \"\$user\\r\"
expect \"*assword*\"
send \"\$user_pass\\r\"
expect \"*>\"
send \"su\\r\"
expect \"*assword*\"
send \"\$su_user_pass\\r\"
expect \"*#\"
send -i \$node_spawn_id_2 \"\\
total_icc=\`route|grep icc|wc -l\`;echo \\\$total_icc;\\r\\
basic_icc=\`route|grep icc|grep 127.\\[0-1\\]|wc -l\`;echo \\\$basic_icc;\\r\\
special_icc=\\\$(( \\\$total_icc - \\\$basic_icc ))\\r\\
if \\[ \\\"\\\$special_icc\\\" == \\\"0\\\" \\]; then\\r\\
route|grep icc|grep 127\\.1\\r\\
else\\r\\
route|grep icc|grep 127\\.\\[2-9\\]\\r\\
fi\\r\\
\\r\"
       expect {
               -re {127\\.(\\S+)\\.1\\.[0-9]} {
                                         set icc_ip_string \$expect_out(1,string)
                                         regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$icc_ip_string icc_ip_second_byte
                                      }
              }
send \"telnet 127.\$icc_ip_second_byte.1.\$slot \$port\\r\"
expect \"*login*\"
send \"\$user\\r\"
expect \"*assword*\"
send \"\$user_pass\\r\"
send \"su\\r\"
expect \"*assword*\"
send \"\$su_user_pass\\r\"
expect \"*#\"
send \"mkdir -p \$temp_dir;cd \$temp_dir;pwd;\\r\";
expect \"*#\";
send \"cp \$compressed_file_dir/\$compressed_file_name \$temp_dir/;cd \$temp_dir;ls;\\r\";
expect \"*#\";
send \"tar -xvzf \$temp_dir/\$compressed_file_name;ls;\\r\";
expect \"*#\";
send \"sed -i 's/\$string_to_replace/\$replace_with/' \$file_to_modify\\r\";
expect \"*#\";
send \"cat \$file_to_modify\\r\";
expect \"*#\"
send \"rm \$temp_dir/\$compressed_file_name\\r\"
expect \"*#\"
send \"tar -cvz * -f \$compressed_file_name;chmod 777 \$compressed_file_name;ls;\\r\";
expect \"*#\"
send \"cp \$temp_dir/\$compressed_file_name \$compressed_file_dir/\$compressed_file_name;\\r\";
expect \"*#\";
send \"ls -l \$compressed_file_dir/\$compressed_file_name;cd \$out_of_temp_dir;ls;rm -rf \$temp_dir;ls\\r\";
expect \"*#\";
interact


" > $generated_scripts_output_path/myscripts/modify_cef5_img_loc
echo "Generated $generated_scripts_output_path/myscripts/modify_cef5_img_loc "


" > $generated_scripts_output_path/myscripts/name_phone
echo "Generated $generated_scripts_output_path/myscripts/name_phone "

echo -n "#!/usr/bin/expect
    set timeout 30
    set ip_part [lindex \$argv 0];
    set image_path [lindex \$argv 1];
#   set image_type [lindex \$argv 2];
    set user \"guest\";
    set user_pass \"iltwat\";
    set su_user \"root\";
    set su_user_pass \"swtn100tj\";
    set cef5_dir \"/etc/name/builds/cef5\";
    set xcc_dir_tej_next \"/etc/bin/nameNext\";
    set xcc_dir_tej \"/etc/bin/name\";
    set xcc_dir_tej_prev \"/etc/bin/namePrevious\";
    set my_pc_user \"$your_pc_username\"; #<#<#$(whoami)#>#>#
    set my_pc_user_pass \"$your_pc_password\";
    set null_value \"\";
    set half_ip \"192.168.\";
    set port \"2023\";
    set release_build_server_ip \"192.168.0.14\";
    set release_build_server_username \"swtn100\";
    set release_build_server_password \"tn100sw\";
    set release_base_dir \"/home/swtn100/releases\";
    set release_build_mode_string \"rel\";
    set release_build_branch_name [lindex \$argv 2];
    set release_build_tag [lindex \$argv 3];
    set release_build_type [lindex \$argv 4];
    

if {(\$ip_part != \$release_build_mode_string) && (\$ip_part != \$null_value)} {
         #flexible IP addressing
         #So that u can provide 102 or 241.244 or 169.143.102 or 172.124.36.102 as IP.
         regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$ip_part all first second third fourth
         if { \$fourth != \$null_value } {
            set ip \"\$all\"
         } elseif { \$third != \$null_value } {
            set ip \"192\\.\$first\\.\$second\\.\$third\"
         } elseif { \$second != \$null_value } {
            set ip \"192\\.168\\.\$first\\.\$second\"
         } elseif { \$first != \$null_value } {
            set ip \"192\\.168\\.143\\.\$first\"
         } else { puts \"Invalid IP\"; exit; }
         puts \"\\nNODE IP is \$ip \\n\"
}

if {((\$image_path != \$release_build_mode_string) && ([llength \$argv] < 2)) && ((\$ip_part != \$release_build_mode_string) && ([llength \$argv] < 2)) } {
puts \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\
\\n               Usages:   1. up \\[Node_IP\\] \\[Image\\]\\
\\n                         2. up rel \\n\\
\\
\\n               Node_IP : 102 will be treated as 192.168.143.102\\
\\n                         241.244 will be treated as 192.168.241.244\\
\\n                         169.200.100 will be treated as 192.169.200.100\\
\\n                         172.124.143.102 will be Taken as complete IP as it is given.\\
\\
\\n               Image :   You can give in any manner. You can even use relative path or just the image name from the directory where image is.\\
\\n                         script will automatically calculate the complete path of image.\\
\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {((\$image_path != \$release_build_mode_string) && ([llength \$argv] < 2)) && ((\$ip_part != \$release_build_mode_string) && ([llength \$argv] < 2)) } {
 exit;
}
}

if { \$image_path != \$release_build_mode_string && \$ip_part != \$release_build_mode_string } {
    puts \"\\nScript will try to upload image from your pc.\\n\"

    #Get system IP
    spawn hostname -I
    expect \"192*\"
    set my_ipaddr \$expect_out(buffer)
    #other method to get IP.If above fails
    if { \$my_ipaddr == \$null_value } {
        spawn ifconfig
        expect -re {inet addr:192\\.168\\.(\\S+)}
        set my_ipaddr [concat \$half_ip\$expect_out(1,string)]
    }
    puts \"\\nMy PC IP is \$my_ipaddr\\n\"

#Trimming newline & return carriage from IP
set my_ipaddr [string trimright \"\$my_ipaddr\" '\\n']
set my_ipaddr [string trimright \"\$my_ipaddr\" '\\r']

#To handle the case when dir is NULL. so to get the pwd of image.
regexp \"^(\\.*/)?(\\[^/\\]*)\$\" \$image_path full_image_path dir_path file_name
if { \$dir_path == \$null_value } {
	   spawn pwd
	   expect \"/*\"
	   set img_pwd \$expect_out(buffer)
	   set dir_path [string trimright \"\$img_pwd\" '\\n']
	   set dir_path [string trimright \"\$dir_path\" '\\r']
}

#To handle addresses like ../../CEF5/tj100mc/../cef5.img
spawn readlink -e \$dir_path
expect \"/*\"
set dir_path \$expect_out(buffer)
if { \$dir_path == \$null_value } {
puts \"Invalid Image Path\"
exit;
}

#Trimming the existing newline & return carriage from dir_path & making it concatable.
set dir_path [string trimright \"\$dir_path\" '\\n']
set dir_path [string trimright \"\$dir_path\" '\\r']
set full_image_path [concat \$dir_path/\$file_name]

#After finishing the full_image_path final check if file exists or not.
if {[file exists \$full_image_path]} {
    puts \"File path seems ok!\"
} else {
    puts \"File doesn't exist. Please check the given Path\"; exit;
}

#Detecting the image type
if {[string match \"*cef5*img\" \$file_name]} {
set image_type \"cef5\";
puts \"Image Type Detected is \$image_type\"
} elseif {[string match \"*xcc360g*img\" \$file_name]} {
set image_type \"xcc360g\";
puts \"Image Type Detected is \$image_type\"
} elseif {[string match \"*tj1700*img\" \$file_name]} {
set image_type \"tj1700\";
puts \"Image Type Detected is \$image_type\"
} else { puts \"Unkown Type of image. Modify the script to add new type.\"; exit; }
if { \$file_name == \$null_value } {
puts \"File Name should not be NULL\";
exit;
}
puts \"\\nFull image path is \$full_image_path \\nDirectory Path is \$dir_path \\nFile Name is \$file_name\"
#Will check the image type and accordingly upload the image.
if { \$image_type == \"cef5\" } {
puts \"Uploading CEF5 image\"
spawn telnet \$ip \$port
set node_spawn_id \$spawn_id
expect \"*login*\"
send \"\$user\\r\"
expect \"*asswor*\"
send \"\$user_pass\\r\"
expect  \"*>\"
send \"su\\r\"
expect \"*asswor*:\" 
send \"\$su_user_pass\\r\";
expect \"*#\"
send \"cd \$cef5_dir\\r\";
expect {
    \"*No such file or directory*\" {
        send \"mkdir -p \$cef5_dir;cd \$cef5_dir;pwd;\\r\"
    }

    \"*#\" {
        send \"rm -rf \$cef5_dir/*;\\r pwd\\r\"
    }
}
expect \"*#\"
send \"ncftpget -u\$my_pc_user -p\$my_pc_user_pass \$my_ipaddr . \$full_image_path\\.md5\\r\"
expect \"*#\"
send \"ncftpget -u\$my_pc_user -p\$my_pc_user_pass \$my_ipaddr . \$full_image_path\\r\"
expect \"*#\"
send \"ls;pwd\\r\"
expect \"*#\"
interact
}

if { \$image_type == \"xcc360g\" } {
puts \"Uploading XCC360g image\"
spawn telnet \$ip \$port
set node_spawn_id \$spawn_id
expect \"*login*\"
send \"\$user\\r\"
expect \"*asswor*\"
send \"\$user_pass\\r\"
expect  \"*>\"
send \"su\\r\"
expect \"*asswor*:\"
send \"\$su_user_pass\\r\";
expect \"*#\"
send \"ls \$xcc_dir_tej\\r\"
expect \"*img\"
set current_img \$expect_out(buffer)
if {![string match \"*xcc360g*img\" \$current_img]} {
puts \"\\n\\nThe current image type being used at node is different than what u r uploading.\\n\\
 Please retry with correct image.\\n Current image being used is \$current_img\"
exit;
}
send \"mount -o remount rw /etc/bin\\r\"
expect \"*#\"
send \"cd \$xcc_dir_tej_next\\r\"
expect \"*#\"
send \"rm -rf \$xcc_dir_tej_next/*;\\r pwd;\\rls\\r\"
expect \"*#\"
send \"ncftpget -u\$my_pc_user -p\$my_pc_user_pass \$my_ipaddr . \$full_image_path\\r\"
expect \"*#\"
send \"ls;pwd\\r\"
expect \"*#\"
interact
}

if { \$image_type == \"tj1700\" } {
puts \"Uploading XCC80g(tj1700) image\"
spawn telnet \$ip \$port
set node_spawn_id \$spawn_id
expect \"*login*\"
send \"\$user\\r\"
expect \"*asswor*\"
send \"\$user_pass\\r\"
expect  \"*>\"
send \"su\\r\"
expect \"*asswor*:\"
send \"\$su_user_pass\\r\";
expect \"*#\"
send \"ls \$xcc_dir_tej\\r\"
expect \"*img\"
set current_img \$expect_out(buffer)
if {![string match \"*tj1700*img\" \$current_img]} {
puts \"\\n\\nThe current image type being used at node is different than what u r uploading.\\n\\
Please retry with correct image.\\n Current image being used is \$current_img\"
exit;
}
send \"mount -o remount rw /etc/bin\\r\"
expect \"*#\"
send \"cd \$xcc_dir_tej_next\\r\"
expect \"*#\"
send \"rm -rf \$xcc_dir_tej_next/*;\\r pwd;\\rls\\r\"
expect \"*#\"
send \"ncftpget -u\$my_pc_user -p\$my_pc_user_pass \$my_ipaddr . \$full_image_path\\r\"
expect \"*#\"
send \"ls;pwd\\r\"
expect \"*#\"
interact
}

} elseif { (\$image_path == \$release_build_mode_string) || (\$ip_part == \$release_build_mode_string)} {
if {[llength \$argv] < 4} {
puts \"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\
\\n        Usages: up \\[Node_IP\\] \\[rel\\] \\[Release Branch Name(without BR)\\] \\[Branch Tag\\] \\[Image Type(Optional. Automatically detects if not give)\\]\\n\\
\\
\\n        Example : up 102 rel 10_0_2 a3 tj1700(this is Optional. script will automatically detect if its xcc360g or whatever.)\\
\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {[llength \$argv] < 4} { exit;
}
}

puts \"\\nScript will try to upload from release build server: \$release_build_server_ip\\n\";
puts \"Uploading image\"
spawn telnet \$ip \$port
set node_spawn_id \$spawn_id
expect \"*login*\"
send \"\$user\\r\"
expect \"*asswor*\"
send \"\$user_pass\\r\"
expect  \"*>\"
send \"su\\r\"
expect \"*asswor*:\"
send \"\$su_user_pass\\r\";
expect \"*#\"
send \"ls --color=never \$xcc_dir_tej\\r\"
expect -re {(\\S+)-ppc}
set current_img_type \$expect_out(1,string)
regsub -all {\\[+.*[0-9]m} \$current_img_type {} new_str
set new_str [string trimleft \"\$new_str\" '\\^']
set new_str [string trimleft \"\$new_str\" '\\[']
#regsub -all {[([0-9]{1,3}((;[0-9]{1,3})*)?)?[m|K]} \$current_img_type {} new_str
#% sed s/\\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g \$current_img_type
#[0;0m kind of color code is being removed here
set current_img_type \$new_str
if { \$release_build_type == \$null_value } {
	set release_build_type \$current_img_type
	puts \"Script found that release_build_type is null so setting it to \$release_build_type\";
}
if {\$release_build_type != \$current_img_type} {
puts \"\\n\\nThe current image type being used at node is different than what u r uploading(\$release_build_type).\\n\\
Please retry with correct image.\\n Current image being used is \$current_img_type\"
exit;
}
set full_image_path \${release_base_dir}/REL_\${release_build_branch_name}/a_x/\${release_build_tag}/builds/\${release_build_type}-ppc-REL_\${release_build_branch_name}_\${release_build_tag}.squash.img
send \"mount -o remount rw /etc/bin\\r\"
expect \"*#\"
send \"cd \$xcc_dir_tej_next\\r\"
expect \"*#\"
send \"rm -rf \$xcc_dir_tej_next/*;\\r pwd;\\rls\\r\"
#expect \"*#\"
#send \"ncftpget -u\$release_build_server_username -p\$release_build_server_password \$release_build_server_ip . \$full_image_path\\.md5\\r\"
expect \"*#\"
send \"ncftpget -u\$release_build_server_username -p\$release_build_server_password \$release_build_server_ip . \$full_image_path\\r\"
expect \"*#\"
send \"ls;pwd\\r\"
puts \"\\nRelease builds are mostly unified tarkit. That means you have to delete image from \$cef5_dir\\n\";
expect \"*#\"
puts \"\\nRelease builds are mostly unified tarkit. That means you have to delete image from \$cef5_dir\\n\";
interact
} else { puts \"\\nInvalid Usages :( \\n\"; exit;}
" > $generated_scripts_output_path/myscripts/iupload
echo "Generated $generated_scripts_output_path/myscripts/iupload "

echo -n "#!/usr/bin/env expect 
if {[llength \$argv] <= 2} {
puts \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\
\\n               Usages: slat \\[Node_IP\\] \\[Card_Slot(Optional)\\]\\n\\
\\
\\n               Node_IP : 102 will be treated as 192.168.143.102\\
\\n                         241.244 will be treated as 192.168.241.244\\
\\n                         169.200.100 will be treated as 192.169.200.100\\
\\n                         172.124.143.102 will be Taken as complete IP as it is given.\\
\\
\\n               Card_Slot:Give only if want to goto that card directly. If not given you will taken to node not to card.\\
\\n                         Script will try to get icc ip automatically.Ex:For BR_10_0_2 its 127.7.1.slot but for BR_8_0_1 its 127.1.1.slot\\n
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {[llength \$argv] < 1} { exit;
}
}
 # timeout -1 means infinite
    set timeout 300
    set ip_part [lindex \$argv 0];
    set slot [lindex \$argv 1];
#    set icc_ip_second_byte [lindex \$argv 2];
    set user \"guest\";
    set user_pass \"iltwat\";
    set su_user \"root\";
    set su_user_pass \"swtn100tj\";
    set null_value \"\";
    set port \"2023\";

#flexible IP addressing
#So that u can provide 102 or 241.244 or 169.143.102 or 172.124.36.102 as IP.
    regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$ip_part all first second third fourth
if { \$fourth != \$null_value } {
   set ip \"\$all\"
} elseif { \$third != \$null_value } {
   set ip \"192\\.\$first\\.\$second\\.\$third\"
} elseif { \$second != \$null_value } {
   set ip \"192\\.168\\.\$first\\.\$second\"
} elseif { \$first != \$null_value } {
   set ip \"192\\.168\\.143\\.\$first\"
} else { puts \"Invalid IP\"; exit; }
puts \"\\n\\nNODE IP is \$ip \\n\"

if {[llength \$argv] == 1} {
        spawn telnet \$ip \$port
        set node_spawn_id \$spawn_id
        expect \"*login*\"
        send \"\$user\\r\"
        expect \"*assword*\"
        send \"\$user_pass\\r\"
        expect \"*>\"
        send \"su\\r\"
        expect \"*assword*\"
        send \"\$su_user_pass\\r\"
        expect \"*#\"
        send \"cat /usr/sbin/name/version.h\\r\"
        expect \"*#\"
        send \"cd \\/etc\\/name\\/log\\r\"
        expect \"*#\"
		send \"/usr/sbin/name/restore_defaults.bash restoredefaults\\r\"
		expect \"*\"
        send \"exit \\r\"
        expect \"*>\"
        send \"exit \\r\"
        interact
        close \$node_spawn_id
        #stty raw -echo
        #expect_after {
        #        -i \$user_spawn_id
        #        \"y\" {send \"rm -fr SysConf.* backconf.*\\rcp defaultCfg\\/* .\\r\"; exp_continue}
        #        \"n\" {send \"\\r\\r\"; exp_continue}
        #}
        #expect \"> \"
        #send \"ls /usr/sbin/name | grep 'initialize.sh'
}

if {[llength \$argv] == 2} {
spawn telnet \$ip \$port
#       spawn telnet 10.51.182.\$node_ip 2023
       set node_spawn_id_2 \$spawn_id
       expect \"*login*\"
       send \"\$user\\r\"
       expect \"*assword*\"
       send \"\$user_pass\\r\"
       expect \"*>\"
       send \"su\\r\"
       expect \"*assword*\"
       send \"\$su_user_pass\\r\"
       expect \"*#\"
send -i \$node_spawn_id_2 \"\\
total_icc=\`route|grep icc|wc -l\`;echo \\\$total_icc;\\r\\
basic_icc=\`route|grep icc|grep 127.\\[0-1\\]|wc -l\`;echo \\\$basic_icc;\\r\\
special_icc=\\\$(( \\\$total_icc - \\\$basic_icc ))\\r\\
if \\[ \\\"\\\$special_icc\\\" == \\\"0\\\" \\]; then\\r\\
route|grep icc|grep 127\\.1\\r\\
else\\r\\
route|grep icc|grep 127\\.\\[2-9\\]\\r\\
fi\\r\\
\\r\"
       expect {
               -re {127\\.(\\S+)\\.1\\.[0-9]} {
               				 set icc_ip_string \$expect_out(1,string)
             				 regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$icc_ip_string icc_ip_second_byte
               			      }
              } 
#       send \"cd \\/tmp\\r\"
#       expect \"# \"
#       send \"rm *.hex\\r\"
#       expect \"# \"
#	send \"ncftpget -uhexftp -piltwat 192.168.0.14 /tmp /home/hexftp/hex/mc/plc02/elk/fpga_edited/\$wld\\r\"
#	expect \"# \"
       send \"telnet 127.\$icc_ip_second_byte.1.\$slot \$port\\r\"
       expect \"*login*\"
       send \"\$user\\r\"
       expect \"*assword*\"
       send \"\$user_pass\\r\"
       send \"su\\r\"
       expect \"*assword*\"
       send \"\$su_user_pass\\r\"
       expect \"*#\"
       send \"cd \\/etc\\/name\\/log\\r\"
       expect \"# \"
       send \"export LD_LIBRARY_PATH=/usr/sbin/name/sharedobj\\r\"
#send \"cd \\/tmp\\r\"
#        expect \"# \"
#        send \"ncftpget -uguest -piltwat 127.1.1.254 . /tmp/\$wld\\r\"
#        expect \"# \"
#        send \"mv \$wld elk.hex\\r\"
#        expect \"# \"

 send \"tail \\-f *log00*\\r\"
     expect \"# \"
        interact
}
" > $generated_scripts_output_path/myscripts/slat
echo "Generated $generated_scripts_output_path/myscripts/slat "

" > $generated_scripts_output_path/myscripts/name_nph
echo "Generated $generated_scripts_output_path/myscripts/name_nph "

echo -n "#!/usr/bin/perl

use HTTP::Request::Common qw(POST);
use LWP::UserAgent;
use LWP::Simple;
use HTML::Parser;

find_name(@ARGV); 

sub find_name() {
	\$name = shift;
	\$key = (shift or \"name\");
	\$ua = new LWP::UserAgent;
	#my \$url = 'http://postfix/cgi-bin/name/tis.cgi';
	my \$url = 'http://192.168.0.8/cgi-bin/name/tis.cgi?action=searchUserInfo&key=name&keyval=';
	my \$res = \$ua->request(POST \$url,
			[ action => searchUserInfo,
			keyval => \$name,
			key => \$key],
		      );

	if(\$res->is_success)  {
		#print \$res->content;
		my \$p = HTML::Parser->new(api_version => 3);
		\$p->handler( start => \\&start_handler, \"tagname,self\");
		\$p->handler( end => \\&end_handler, \"tagname,self\" );  
		\$p->unbroken_text(1);
		print \"\\n\";
		\$p->parse(\$res->content) || die \"Dieing \$!\"; 
		print \"\\n\";

	} else {
		print \"Error: \" . \$res->status_line . \"\\n\";
	}                                                                                                                         
}

sub start_handler
{
        my \$tag = shift;
        my \$self = shift;
 
        if(\$tag eq \"tr\") { print \"\\n\"; }
        elsif (\$tag eq \"td\") {
                \$self->handler(text => sub { my \$t = shift; \$t =~ s/\\s+/ /g; print \"\$t\\t\"; }, \"dtext\");
        }
}

sub end_handler
{
        my \$tag = shift;
        my \$self = shift;
        if (\$tag eq \"td\") { \$self->handler(text => undef); }
}
" > $generated_scripts_output_path/myscripts/phone
echo "Generated $generated_scripts_output_path/myscripts/phone "

echo -n "#!/usr/bin/env expect 
##########################################################Generic Auto Telnet (gat)###########################################################
if {[llength \$argv] < 4} {
puts \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\
\\n               Usages: gat \\[IP_or_IP_part\\]   Username      Password     Super_User_Password\\(Optional\\)\\n 
\\
\\n               Node_IP : 102 will be treated as 192.168.143.102\\
\\n                         241.244 will be treated as 192.168.241.244\\
\\n                         169.200.100 will be treated as 192.169.200.100\\
\\n                         172.124.143.102 will be Taken as complete IP as it is given.\\n
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {[llength \$argv] < 3} { exit;
}
}
 # timeout -1 means infinite
    set timeout -1
    set ip_part [lindex \$argv 0];
    set user [lindex \$argv 1];
    set user_pass [lindex \$argv 2];
    set remote_release_md5_details_path [lindex \$argv 3];
    set null_value \"\";
#    set release_details_path \"/tmp/releases_details.txt\"
    set release_images_path \"/home/swtn100/releases/\"
#flexible IP addressing
#So that u can provide 102 or 241.244 or 169.143.102 or 172.124.36.102 as IP.
    regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$ip_part all first second third fourth
if { \$fourth != \$null_value } {
   set ip \"\$all\"
} elseif { \$third != \$null_value } {
   set ip \"192\\.\$first\\.\$second\\.\$third\"
} elseif { \$second != \$null_value } {
   set ip \"192\\.168\\.\$first\\.\$second\"
} elseif { \$first != \$null_value } {
   set ip \"192\\.168\\.143\\.\$first\"
} else { puts \"Invalid IP\"; exit; }
puts \"\\nEntity IP is \$ip \\n\"

if {[llength \$argv] == 4} {
        spawn telnet \$ip
        set node_spawn_id \$spawn_id
        expect \"*login*\"
        send \"\$user\\r\"
	expect  {
		\"*asswor*\" {
				send \"\$user_pass\\r\"
				exp_continue
			   }
     \"*command not found*\" {
				send \"\\r\"
				exp_continue
			   }
 
             \"*incorrect*\" {
                                return 1
                           }

		     \"*\$*\" {
			         send \"stty -echo \\r rel_md5_details=\\\"\$remote_release_md5_details_path\\\" ; touch \\\$rel_md5_details ; pushd \$release_images_path ; for directory in \\\$\\(ls -1d REL*\\); do if pushd \\\$directory/a_x/ 2>/dev/null ;then for sub_dir in \\\$\\(ls -1d a* 2>/dev/null\\); do if pushd \\\$sub_dir/builds 2>/dev/null ;then for image in \\\$\\(ls -1rt *.squash.img 2>/dev/null\\); do if grep \\\"\\\$\\(readlink -e \\\$image\\)\\\" \\\$rel_md5_details >/dev/null ;then echo \\\"Found \\\$image in \\\$rel_md5_details. No need to recalculate md5sum.\\\"; else image_full_path=\\\$\\(readlink -e \\\$image\\); md5sum \\\$image_full_path >> \\\$rel_md5_details; echo \\\"Computed the md5 value for \\\$image & stored in \\\$rel_md5_details\\\"; fi; done; popd >/dev/null; fi; done; popd >/dev/null; fi ;done; echo \\\"DONE\\\" \\r\"
                     expect \"*DONE\"
                     #interact
                     exit ;
			       }

		   default {
				interact
			   }
		}
}

" > $generated_scripts_output_path/myscripts/md5relinfo
echo "Generated $generated_scripts_output_path/myscripts/md5relinfo "

echo -n "#!/usr/bin/env expect 
if {[llength \$argv] <= 2} {
puts \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\
\\n               Usages: this_script \\[Node_IP\\] \\[Download_to_this_path(Optional: default will be used as ./ )\\]\\n\\
\\
\\n               Node_IP : 102 will be treated as 192.168.143.102\\
\\n                         241.244 will be treated as 192.168.241.244\\
\\n                         169.200.100 will be treated as 192.169.200.100\\
\\n                         172.124.143.102 will be Taken as complete IP as it is given.\\
\\
\\n               Card_Slot:Give only if want to goto that card directly. If not given you will taken to node not to card.\\
\\n                         Script will try to get icc ip automatically.Ex:For BR_10_0_2 its 127.7.1.slot but for BR_8_0_1 its 127.1.1.slot\\n
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {[llength \$argv] < 1} { exit;
}
}
#   exp_internal 1
 # timeout -1 means infinite
    set timeout 300
    set NO_CRASH 2
    set null_value \"\";
    set ip_part [lindex \$argv 0];
    set download_at_this_path [lindex \$argv 1];
    if { \$download_at_this_path == \$null_value } {
                                                   set download_at_this_path \".\";
                                                 } 
    set slot [lindex \$argv 2];
    set user \"guest\";
    set user_pass \"iltwat\";
    set su_user \"root\";
    set su_user_pass \"swtn100tj\";
    set port \"2023\";
    set sleep_time \"4\";
    set log_dir_path \"/etc/name/log/\";
    set maps_dir_path \"/etc/name/log/\";
    set img_md5info_file_path \"/etc/name/log/img_md5info\";
    set control_card_img_regexp \"/etc/bin/name/*.img\";
    set intelligent_card_img_regexp \"/etc/name/builds/*/*.img\";
    set img_md5info_command \"md5sum \$control_card_img_regexp \$intelligent_card_img_regexp >\$img_md5info_file_path 2>/dev/null & disown\";
#flexible IP addressing
#So that u can provide 102 or 241.244 or 169.143.102 or 172.124.36.102 as IP.
    regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$ip_part all first second third fourth
if { \$fourth != \$null_value } {
   set ip \"\$all\"
} elseif { \$third != \$null_value } {
   set ip \"192\\.\$first\\.\$second\\.\$third\"
} elseif { \$second != \$null_value } {
   set ip \"192\\.168\\.\$first\\.\$second\"
} elseif { \$first != \$null_value } {
   set ip \"192\\.168\\.143\\.\$first\"
} else { puts \"Invalid IP\"; exit; }
puts \"\\n\\nNODE IP is \$ip \\n\"

if { \$slot == \$null_value } {
        spawn telnet \$ip \$port
        set node_spawn_id \$spawn_id
        expect \"*login*\"
        send \"\$user\\r\"
        expect \"*assword*\"
        send \"\$user_pass\\r\"
        expect \"*>\"
        send \"su\\r\"
        expect \"*assword*\"
        send \"\$su_user_pass\\r\"
        expect \"*#\"
        send \"cd \$log_dir_path \\r\" 
        expect \"*#\"
        send \"stty -echo\\r\"
		expect \"*\"
        send \"ltd=(\\\$(grep -nriI \\\"stackdump\\\" . | awk 'BEGIN { FS = \\\":\\\" } { printf(\\\$1\\\"\\\\n\\\") }' | uniq ))\\r\"
        expect \"*\"
        expect -re {(\\S+)\\r\\n}
        send \"if \\[\\[ \\\${#ltd} -ne 0 \\]\\];then tmp=(\\\$(for log in \\\${ltd\\[@\\]};do readlink -f \\\$log | tr '\\\\n' ' ' ;done));echo \\\${tmp\\[@\\]} ; else echo NOT_FOUND ; fi\\r\"        
        expect -re {(\\S+)\\r\\n}
        set logs_to_get \$expect_out(buffer)
        send \"stty echo\\r \$img_md5info_command \\r\"
        expect \"*\"
        send \"exit\\r\"
        close \$node_spawn_id
        set logs_to_get [string trimright \"\$logs_to_get\" '\\n']
        set logs_to_get [string trimright \"\$logs_to_get\" '\\r']
        set getlog [split \$logs_to_get \" \"]
        set finallog [lsearch -all -inline -not -regexp \$getlog \"bash.*#\"]
        if {[lsearch -exact \$finallog \"NOT_FOUND\"] >= 0} {
            puts \"Log having Crash is coming as NOT_FOUND. So there is no crash. Exiting ...!!!\"
            exit \$NO_CRASH 
           }
        set filenames {}
        set daemons_tmp {}
        set daemons {}
        set daemon_maps {}
        foreach file_path \$finallog {
                                      set file_name [file tail \$file_path]
                                      lappend filenames \$file_name
                                      set daemon_name [regsub {dlog.*} \$file_name \"\"]
                                      set daemon_name [regsub {^init} \$daemon_name \"\"]
                                      lappend daemons_tmp [string tolower \$daemon_name]
                                    }
        set daemons [lsort -unique \$daemons_tmp]
        foreach daemon \$daemons { set dmn_tmp \"\" ; set dmn_tmp2 \"\" ; append dmn_tmp \$daemon \".maps\" ; append dmn_tmp2 \$maps_dir_path \$dmn_tmp ; lappend daemon_maps \$dmn_tmp2 }
        puts \"logs to get are \$finallog\"
        puts \"file names are \$filenames\"
        puts \"daemons are \$daemons\"
        puts \"daemon maps are \$daemon_maps\"
        puts \"Sleeping for \$sleep_time before doing ncftpget. So that md5info file get generated.\"
        sleep \$sleep_time
        eval spawn ncftpget -u\$user -p\$user_pass \$ip \$download_at_this_path \$finallog \$daemon_maps \$img_md5info_file_path
        set ncftp_spawn_id \$spawn_id
        interact
        #stty raw -echo
        #expect_after {
        #        -i \$user_spawn_id
        #        \"y\" {send \"rm -fr SysConf.* backconf.*\\rcp defaultCfg\\/* .\\r\"; exp_continue}
        #        \"n\" {send \"\\r\\r\"; exp_continue}
        #}
        #expect \"> \"
        #send \"ls /usr/sbin/name | grep 'initialize.sh'
}

# if {[llength \$argv] == 2} {
if { \$slot != \$null_value} {
puts \"for line cards still have to implement this.\"
exit
spawn telnet \$ip \$port
#       spawn telnet 10.51.182.\$node_ip 2023
       set node_spawn_id_2 \$spawn_id
       expect \"*login*\"
       send \"\$user\\r\"
       expect \"*assword*\"
       send \"\$user_pass\\r\"
       expect \"*>\"
       send \"su\\r\"
       expect \"*assword*\"
       send \"\$su_user_pass\\r\"
       expect \"*#\"
send -i \$node_spawn_id_2 \"\\
total_icc=\`route|grep icc|wc -l\`;echo \\\$total_icc;\\r\\
basic_icc=\`route|grep icc|grep 127.\\[0-1\\]|wc -l\`;echo \\\$basic_icc;\\r\\
special_icc=\\\$(( \\\$total_icc - \\\$basic_icc ))\\r\\
if \\[ \\\"\\\$special_icc\\\" == \\\"0\\\" \\]; then\\r\\
route|grep icc|grep 127\\.1\\r\\
else\\r\\
route|grep icc|grep 127\\.\\[2-9\\]\\r\\
fi\\r\\
\\r\"
       expect {
               -re {127\\.(\\S+)\\.1\\.[0-9]} {
               				 set icc_ip_string \$expect_out(1,string)
             				 regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$icc_ip_string icc_ip_second_byte
               			      }
              } 
#       send \"cd \\/tmp\\r\"
#       expect \"# \"
#       send \"rm *.hex\\r\"
#       expect \"# \"
#	send \"ncftpget -uhexftp -piltwat 192.168.0.14 /tmp /home/hexftp/hex/mc/plc02/elk/fpga_edited/\$wld\\r\"
#	expect \"# \"
       send \"telnet 127.\$icc_ip_second_byte.1.\$slot \$port\\r\"
       expect \"*login*\"
       send \"\$user\\r\"
       expect \"*assword*\"
       send \"\$user_pass\\r\"
       send \"su\\r\"
       expect \"*assword*\"
       send \"\$su_user_pass\\r\"
       expect \"*#\"
       send \"cd \\/etc\\/name\\/log\\r\"
       expect \"# \"
       send \"export LD_LIBRARY_PATH=/usr/sbin/name/sharedobj\\r\"
#send \"cd \\/tmp\\r\"
#        expect \"# \"
#        send \"ncftpget -uguest -piltwat 127.1.1.254 . /tmp/\$wld\\r\"
#        expect \"# \"
#        send \"mv \$wld elk.hex\\r\"
#        expect \"# \"

 send \"tail \\-f *log00*\\r\"
     expect \"# \"
        interact
}
" > $generated_scripts_output_path/myscripts/ca_maps_logs_downloader
echo "Generated $generated_scripts_output_path/myscripts/ca_maps_logs_downloader "

echo -n "#!/bin/bash
user=\$(whoami)
if [ \"\$user\" != \"root\" ]; then
    echo \"Can not run with non-root priviledge\";
    exit;
fi
number_of_parameters=\$#;
checkout_path=\$1; #also used to go to evolution mode
checkout_branch_name=\$2; #will contain option in evolution mode
user=\"$your_pc_username\"; #<#<#$(whoami)#>#>#
su_user=\"root\";
home_path=\"$parent_path_of_checkout_path\"; #<#<#$HOME#>#>#
cm_utils_path=\"$your_cm_utils_path\"; #<#<#$HOME#>#>#
evolution_mode_string=\"evolution\";
this_script=\${0};
first_input_string=\$checkout_path;
evolution_option=\$checkout_branch_name;
module_type=\$3;
branch_tag=\$3; ## yet to be implemented for tagged checkout.
module_name=\$4;
script_to_evolve=\$this_script;
module_file=\$5;
evolution_perl_script=\"evolution.pl\";
card_type=\"xcc360g\"; #generally we use this one in compile script. can change it.
release_server_ip=\"192.168.0.14\"; #used for sidepanel fix script.
release_server_username=\"swtn100\"; #used for sidepanel fix script.
release_server_password=\"tn100sw\"; #used for sidepanel fix script.
tgz_file_name=\"xcc360g-ppc-side_panel_fix.tgz\"; #used for sidepanel fix script.
tgz_file_full_path=\"/home/swtn100/side_panel_fix_build/\$tgz_file_name\"; #used for sidepanel fix script.

if [ \$number_of_parameters -lt \"2\" ] && [ \"\$first_input_string\" != \"\$evolution_mode_string\" ];then
echo Usages: checkout_path checkout_branch_name branch_tag\\(Optional if want tagged checkout then only. Ex: REL_10_0_2_a2\\);
echo \"OR\";
echo \"Usages: evolution & other parameters (to include other tj100_mc file or any other module file) \";
exit;
fi

if [ \"\$first_input_string\" != \"\$evolution_mode_string\" ];then

echo \"NORMAL Mode Operations. THIS SCRIPT WILL CREATE OTHER SCRIPTS\";

declare -a tj100_mc_diffs=\\
(
#modify#tj100_mc#array#start
\"BR_10_0_2\"
\"NEOS10_CEF5_DEV\"
\"BR_8_0_1\"
#modify#tj100_mc#array#end
)

echo \"Embedded tj100_mc_diffs are following\";
for i in \"\${tj100_mc_diffs[@]}\"
do
echo \"\$i\"
done

tj100_mc_diff_file_path=\"\$home_path/\$checkout_path/tj100_mc_diffs_and_extra_files\"; #edit only when automatic patching fails
tj100_mc_diff_file_name=\"\"; #edit only when automatic patching fails and u want to give manual diff_path
if [ \"\$tj100_mc_diff_file_name\" == \"\" ]; then
echo \"tj100_mc_diff_file_name is null in script so trying to get it automatically\";
case \"\$checkout_branch_name\" in
#modify#tj100_mc#case#start

#modify#tj100_mc#case#BR_10_0_2#start 
  *BR_10_0_2*)
    tj100_mc_diff_file_name=\"tj100_mc_BR_10_0_2.diff\";
    ;;
#modify#tj100_mc#case#BR_10_0_2#end

#modify#tj100_mc#case#NEOS10_CEF5_DEV#start
  *NEOS10_CEF5_DEV*)
    tj100_mc_diff_file_name=\"tj100_mc_NEOS10_CEF5_DEV.diff\";
    ;;
#modify#tj100_mc#case#NEOS10_CEF5_DEV#end

#modify#tj100_mc#case#BR_8_0_1#start
  *BR_8_0_1*)
    tj100_mc_diff_file_name=\"tj100_mc_BR_8_0_1.diff\";
    ;;
#modify#tj100_mc#case#BR_8_0_1#end

#modify#tj100_mc#case#end
   *)
    echo \"We don't have \$checkout_branch_name tj100_mc diff.So please get tj100_mc diff for \$checkout_branch_name specify in \$this_script\";
    echo \"Don't forget that there are two variables tj100_mc_diff_file_path & tj100_mc_diff_file_name in \$this_script give values accordingly.\";
    exit 1;
esac
fi
echo \"tj100_mc_diff_file_name is \$tj100_mc_diff_file_name\";
mirror_name=\"MIRROR_\${checkout_branch_name}_\${branch_tag}\";
scripts_path=\"\$home_path/\$checkout_path/simulator_scripts_for_\$checkout_branch_name\";
#here home path need not to be like /home/user kind of home path defined above is the base path where you want to make the folder 
#in which you are going to create checkout_path 
#structure is something like this. 
# \$home_path/\$checkout_path/\$checkout_branch_name
# \$home_path/\$checkout_path/\$mirror_name   (of above branch)
# this base_path is given so that if you don't have space in your /home/\$USER then you can mention paths like 
# home_path=/drive1   now simulator will be created in the /drive1/CHECKOUTPATH/BRANCHNAME


rm /bin/sh
ln -s /bin/bash /bin/sh
lookup_path=\"\$home_path/\$checkout_path\"
if [ -d \$lookup_path ];then
   echo \"\$home_path/\$checkout_path already exists. Please delete it or give a different checkout name(path)\"
exit;
fi
su \$user -c \"mkdir -p \$scripts_path\";
su \$user -c \"mkdir -p \$tj100_mc_diff_file_path\";

echo \"GENERATING OTHER SCRIPTS AND TJ100MC DIFF FILES\";
echo \"Writing \$scripts_path/checkoutnm_simulator.sh\";
echo \"\\
user=\\\$(whoami)
if [ \\\"\\\$user\\\" == \\\"root\\\" ]; then
    echo \\\"Do not checkout with root priviledge\\\";
    exit;
fi

if [ \\\$# -lt \\\"6\\\" ];then
echo Usages: checkout_path checkout_branch_name home_path cm_utils_path tj100_mc_diff_file_path tj100_mc_diff_file_name branch_tag\\(Optional\\);
exit;
fi

checkout_path=\\\$1;
checkout_branch_name=\\\$2;
home_path=\\\$3;
cm_utils_path=\\\$4;
tj100_mc_diff_file_path=\\\$5;
tj100_mc_diff_file_name=\\\$6;
branch_tag=\\\$7;
mkdir \\\$home_path/\\\$checkout_path
cd \\\$home_path/\\\$checkout_path

if [ -z \\\"\\\$branch_tag\\\" ]
then
  echo \\\"branch_tag is NULL so going for UnTagged checkout.\\\";
  \\\$cm_utils_path/cm-utils/checkout --dir=\\\$home_path/\\\$checkout_path/\\\$checkout_branch_name \\\$checkout_branch_name
  else
  echo \\\"branch_tag is NOT NULL. branch_tag is : \\\$branch_tag\\\";
  touch \\\$home_path/\\\$checkout_path/this_is_tagged_checkout.tag_is_\\\$branch_tag
  \\\$cm_utils_path/cm-utils/checkout --dir=\\\$home_path/\\\$checkout_path/\\\$checkout_branch_name \\\$checkout_branch_name -tag=\\\$branch_tag
fi

echo \\\"Checkout is completed now will start patching nm simulator files with corresponding tj100_mcdiff file\\\";

#    patch attached diff by :
cd \\\$home_path/\\\$checkout_path/\\\$checkout_branch_name/tj100_mc
patch -p1 -i \\\$tj100_mc_diff_file_path/\\\$tj100_mc_diff_file_name
OUT=\\\$?

if [ \\\$OUT -eq 0 ];then
   	echo \\\"Patching done successfully. No problem. :-) \\\"
else
   	REP='n';
   	echo \\\"Patching failed. Please patch manually using other shell. After patching manually enter C or c to continue.\\\"
   	while [[ ! \\\$REP =~ ^[Cc] ]]; do
   	echo \\\"If manually patched. Enter c or C to continue \\\";
   	read REP
   	done
fi

echo \\\"Continuing\\\";
echo \\\"Patch done Manually or automatically\\\";

\" > \$scripts_path/checkoutnm_simulator.sh;

echo \"Writing \$scripts_path/patch_and_mirror.sh\";
echo \"\\
user=\\\$(whoami)
if [ \\\"\\\$user\\\" == \\\"root\\\" ]; then
    echo \\\"Do not patch with root priviledge\\\";
    exit;
fi

if [ \\\$# -ne \\\"5\\\" ];then
echo Usages: checkout_path checkout_branch_name home_path cm_utils_path mirror_name;
exit;
fi

checkout_path=\\\$1;
checkout_branch_name=\\\$2;
home_path=\\\$3;
cm_utils_path=\\\$4;
mirror_name=\\\$5;
#YOUR PATCHING HAPPENS HERE

#echo \\\"#patching the tj100_mc_diff\\\";
#cd \\\$home_path/\\\$checkout_path/\\\$checkout_branch_name/tj100_mc
#patch -p1 -i /home/parmil/Downloads/tj100_mc_diff

echo \\\"All patching done now will create mirror of it\\\";
\\\$cm_utils_path/cm-utils/mirror \\\$home_path/\\\$checkout_path/\\\$checkout_branch_name/ \\\$home_path/\\\$checkout_path/\\\$mirror_name


\" > \$scripts_path/patch_and_mirror.sh;

echo \"Writing \$scripts_path/compile_simulator.sh\";
echo \"\\
user=\\\$(whoami)
if [ \\\"\\\$user\\\" == \\\"root\\\" ]; then
    echo \\\"Can not compile with root priviledge\\\";
    exit;
fi

if [ \\\$# -ne \\\"5\\\" ];then
    echo Usages: checkout_path home_path mirror_name threads card_type;
    exit;
fi

checkout_path=\\\$1;
home_path=\\\$2;
mirror_name=\\\$3;
threads=\\\$4
card_type=\\\$5

init_time=\\\$(date)
cd \\\$home_path/\\\$checkout_path/\\\$mirror_name/tj100_mc/src
source ../scripts/makeenv
makeenv \\\$card_type host LINUX26 \\\$PWD NO YES YES
cd interfaces/

if [ \\\$threads == \\\"1\\\" ];then
make
else
make -j\\\$threads
fi

cd ..
./version.pl
cd app/tj1700/nm/

if [ \\\$threads == \\\"1\\\" ];then
make
else
make -j\\\$threads
fi

echo \\\"compilation started at  : \\\"\\\$init_time
echo \\\"compilation finished at : \\\"\\\$(date)
echo \\\"Threads Used : \\\$threads\\\"
echo \\\"Card Type : \\\$card_type\\\"
\" > \$scripts_path/compile_simulator.sh;

echo \"Writing \$scripts_path/onetime.sh\";
echo \"\\
user=\\\$(whoami)
if [ \\\"\\\$user\\\" != \\\"root\\\" ]; then
    echo \\\"Can not run with non-root priviledge\\\";
    exit;
fi

if [ \\\$# -ne \\\"3\\\" ];then
echo Usages: checkout_path home_path mirror_name;
exit;
fi

checkout_path=\\\$1;
home_path=\\\$2;
mirror_name=\\\$3;
echo \\\"One time setup script started\\\";

mkdir /etc/name
mkdir /etc/name/log
mkdir /etc/name/config
mkdir /etc/name/config/db
mkdir /etc/name/config/backup
mkdir /usr/sbin/name
mkdir /usr/sbin/name/ems
mkdir /usr/sbin/name/ems/js
mkdir /usr/sbin/name/ems/js/treeview
cd \\\$home_path/\\\$checkout_path/\\\$mirror_name/packages/treeview/

cp \$tj100_mc_diff_file_path/license.dat /etc/name/
cd \\\$home_path/\\\$checkout_path/\\\$mirror_name/tj100_mc/src/app/tj1700/nm/
echo \\\"One time setup completed\\\";

\" > \$scripts_path/onetime.sh;

echo \"Writing \$scripts_path/sidepanelnotworking.sh\";
echo \"\\
user=\\\$(whoami)
if [ \\\"\\\$user\\\" != \\\"root\\\" ]; then
    echo \\\"Can not run with non-root priviledge\\\";
    exit;
fi

if [ \\\$# -ne \\\"1\\\" ];then
    echo Usages: home_path;
    exit;
fi

home_path=\\\$1;

mkdir \\\$home_path/sidepaneltmp
cd \\\$home_path/sidepaneltmp
#  //copy  \\\"tgz image for your control card\\\" from tn100build to your computer
# // Like for  REL_10_0_0_a15_1, i would do following :
ncftpget -u\$release_server_username -p\$release_server_password \$release_server_ip . \$tgz_file_full_path
tar -xvzf \$tgz_file_name
#//name directory will be created.
cd name
cp -rf ems /usr/sbin/name
cd \\\$home_path
rm -rf \\\$home_path/sidepaneltmp

\" > \$scripts_path/sidepanelnotworking.sh;

echo \"Writing \$scripts_path/run_nm_simulator.sh\";
echo \"\\
user=\\\$(whoami)
if [ \\\"\\\$user\\\" != \\\"root\\\" ]; then
    echo \\\"Can not run with non-root priviledge\\\";
    exit;
fi

if [ \\\$# -ne \\\"3\\\" ];then
echo Usages: checkout_path home_path mirror_name;
exit;
fi

checkout_path=\\\$1;
home_path=\\\$2;
mirror_name=\\\$3;
echo Copy command executing
cd \\\$home_path/\\\$checkout_path/\\\$mirror_name/packages/treeview/

cp -rf ftiens4.js ua.js /usr/sbin/name/ems/js/treeview/
cp -rf \\\$home_path/\\\$checkout_path/\\\$mirror_name/tj100_mc/src/app/common/nm/ems/js/treeview/NodeToc.js  /usr/sbin/name/ems/js/treeview/
cp -rf \\\$home_path/\\\$checkout_path/\\\$mirror_name/tj100_mc/src/app/common/nm/ems/js/* /usr/sbin/name/ems/js/
cp -rf \\\$home_path/\\\$checkout_path/\\\$mirror_name/modules/ce/src/app/common/nm/ems/js/* /usr/sbin/name/ems/js/tj2k/
cp -rf \\\$home_path/\\\$checkout_path/\\\$mirror_name/tj100_mc/scripts/TZData.conf /usr/sbin/name/
cp -rf \\\$home_path/\\\$checkout_path/\\\$mirror_name/tj100_mc/src/licenses/vendor/tj2k_vendor.dat /etc/name/config/

cd \\\$home_path/\\\$checkout_path/\\\$mirror_name/tj100_mc/src/app/tj1700/nm/
echo Export commands executing
export HIGHTEMP_THRESHOLD=60
export SANITY_TIMEOUT=10000
export TJ_LICENSE_FILE=/etc/name/license.dat
export LD_LIBRARY_PATH=\\\$home_path/\\\$checkout_path/\\\$mirror_name/tj100_mc/src/sharedobj/
export WEB_SERVER_PORT=20080
export SNMP_LOG_LEVEL=0
export BP_EEPROM_ENABLE=YES
export ENABLE_HW_WATCHDOG=YES
export SIMULATOR=YES
export SIGD_TIMEOUT=180000

snmp_pids=\\\`ps -ef | grep -iw \\\"[s]nmpd\\\" | awk '{print \\\$2}'\\\`
nm_pids=\\\`ps -ef| grep -iw \\\"[n]m\\.d\\\" | awk '{print \\\$2}'\\\`

echo Checking and killing snmpd if already running
if [ \\\"\\\$snmp_pids\\\" != \\\"\\\" ]; then
for signal in \\\"-15\\\" \\\"-1\\\" \\\"-9\\\"
do
  pids=\\\`ps -ef | grep -iw \\\"[s]nmpd\\\" | awk '{print \\\$2}'\\\`
  kill \\\$signal \\\$pids 2> /dev/null
  echo Killed pid \\\$pids with signal \\\$signal
done
fi

echo Checking if nm.d is already running and killing it.
if [ \\\"\\\$nm_pids\\\" !=  \\\"\\\" ]; then
for signal in \\\"-15\\\" \\\"-1\\\" \\\"-9\\\"
do
  pids=\\\`ps -ef| grep -iw \\\"[n]m\\.d\\\" | awk '{print \\\$2}'\\\`
  kill \\\$signal \\\$pids 2> /dev/null
  echo Killed pid \\\$pids with signal \\\$signal
done
fi
echo No snmp or nm.d is running!!! Ready to launch nm.d

gdb nm.d

\" > \$scripts_path/run_nm_simulator.sh;

echo \"Writing \$scripts_path/simulator_master_script.sh\";
echo \"\\
#!/bin/bash
user=\\\$(whoami)
if [ \\\"\\\$user\\\" != \\\"root\\\" ]; then
    echo \\\"Can not run with non-root priviledge\\\";
    exit;
fi

checkout_path=\\\"\$1\\\";
checkout_branch_name=\\\"\$2\\\";
option=\\\"\\\$1\\\";
threads=\\\"\\\$2\\\";
if [ \\\"\\\$threads\\\" == \\\"\\\" ];then
    threads=1
fi
user=\\\"\$user\\\";
su_user=\\\"\$su_user\\\";
home_path=\\\"\$home_path\\\";
cm_utils_path=\\\"\$cm_utils_path\\\";
tj100_mc_diff_file_path=\\\"\$tj100_mc_diff_file_path\\\";
tj100_mc_diff_file_name=\\\"\$tj100_mc_diff_file_name\\\";
mirror_name=\\\"\$mirror_name\\\";
scripts_path=\\\"\$scripts_path\\\";
branch_tag=\\\"\$branch_tag\\\";
card_type=\\\"\$card_type\\\";
tj100_mc_diff_full_path=\\\$tj100_mc_diff_file_path/\\\$tj100_mc_diff_file_name
if [ -f \\\$tj100_mc_diff_full_path ];then
   echo \\\"\\\$tj100_mc_diff_full_path exists. OK!!! :-) \\\"
else
echo \\\"\\\$tj100_mc_diff_full_path doesn't exist. Please get a proper tj100_mc diff for \\\$checkout_branch_name then try again. Bye Bye :(\\\"
exit;
fi

echo \\\$option
if [ \\\$# -lt \\\"1\\\" ] || [ \\\$# -gt \\\"2\\\" ];then
	echo \\\"Usages: Option Threads(Optional.Default:1, Used while compiling simulator)\\\";
	echo Options: 
	echo \\\"1 : All Steps (Checkout + Patch_&_Mirror + OnetimeSetup + Fix_Side_Panel_Not_Working + Compile + Run_Simulator)\\\" 
	echo \\\"2 : Skip Checkout,Patch_&_Mirror,OnetimeSetup and Side_Panel. Start from Compile. (Compile + Run_Simulator)\\\"
	echo \\\"3 : Just Run the nm.d\\\"
	exit;
fi

echo \\\"THIS SCRIPT WILL CREATE THE FINAL NM.D USING OTHER SCRIPTS\\\";

if [ \\\$option == \\\"1\\\" ];then
	rm /bin/sh
	ln -s /bin/bash /bin/sh
	lookup_path=\\\"\\\$home_path/\\\$checkout_path/\\\$checkout_branch_name\\\"
	if [ -d \\\$lookup_path ];then
	   	echo \\\"\\\$home_path/\\\$checkout_path/\\\$checkout_branch_name already exists. Please delete it or give a different checkout name(path)\\\"
		exit;
	fi
	echo Using checkoutnm_simulator.sh checkingout after that patching also;
	su \\\$user -c \\\"source \\\$scripts_path/checkoutnm_simulator.sh \\\$checkout_path \\\$checkout_branch_name \\\$home_path \\\$cm_utils_path \\\$tj100_mc_diff_file_path \\\$tj100_mc_diff_file_name \\\$branch_tag\\\";
	echo Using \\\$scripts_path/patch_and_mirror.sh after patch creating mirror also;
	su \\\$user -c \\\"source \\\$scripts_path/patch_and_mirror.sh \\\$checkout_path \\\$checkout_branch_name \\\$home_path \\\$cm_utils_path \\\$mirror_name\\\";
fi

if [ \\\$option \\\\< \\\"3\\\" ];then
	echo Using \\\$scripts_path/compile_simulator.sh compiling till now without root
	su \\\$user -c \\\"source \\\$scripts_path/compile_simulator.sh \\\$checkout_path \\\$home_path \\\$mirror_name \\\$threads \\\$card_type\\\";
	echo Now onwards all scripts will be running in root level
fi

if [ \\\$option == \\\"1\\\" ];then #have to put here otherwise its messing up with compile script sourcing.
        echo Using \\\$scripts_path/onetime.sh for onetime setup
        source \\\$scripts_path/onetime.sh \\\$checkout_path \\\$home_path \\\$mirror_name
        echo Using \\\$scripts_path/sidepanelnotworking.sh so that sidepanel issue can be fixed
        source \\\$scripts_path/sidepanelnotworking.sh \\\$home_path
fi

echo Using \\\$scripts_path/run_nm_simulator.sh to run nm
source \\\$scripts_path/run_nm_simulator.sh \\\$checkout_path \\\$home_path \\\$mirror_name

\" > \$scripts_path/simulator_master_script.sh;

echo \"Generating tj100_mc diffs in \$tj100_mc_diff_file_path\";

#modify#tj100_mc#file#start

#modify#tj100_mc#file#BR_10_0_2#start
echo -n \"diff --git a/src/DebugFrameWork/DebugMgr.cpp b/src/DebugFrameWork/DebugMgr.cpp
index c0dbff0..4e6b569 100755
--- a/src/DebugFrameWork/DebugMgr.cpp
+++ b/src/DebugFrameWork/DebugMgr.cpp
@@ -1,5 +1,9 @@
 #include <iomanip>
-#include <vector>
+#ifndef EMULATOR
+    #include <vector.h>
+#else
+    #include <vector>
+#endif
 #include <stdio.h>
 #include <ctype.h>
 #include <strings.h>
@@ -20,7 +24,9 @@
 #include <limits.h>
 #include <errno.h>
 #include <time.h>
-//#include <asm/user.h>
+#ifndef EMULATOR
+    #include <asm/user.h>
+#endif
 #include <sys/wait.h>
 #include <sched.h>
 #include <sys/resource.h>
diff --git a/src/DebugFrameWork/DebugMgr.h b/src/DebugFrameWork/DebugMgr.h
index 0ecd6d6..c35b269 100755
--- a/src/DebugFrameWork/DebugMgr.h
+++ b/src/DebugFrameWork/DebugMgr.h
@@ -13,7 +13,11 @@
 
 
 #include <bits/siginfo.h>
-#include <string>
+#ifndef EMULATOR
+ #include <string>
+#else
+#include <cstring>
+#endif
 #include <map>
 #include <sstream>
 #include \\\"SocketMgr.h\\\"
diff --git a/src/DebugFrameWork/SegHndlr.cpp b/src/DebugFrameWork/SegHndlr.cpp
index 9bad984..c30b722 100755
--- a/src/DebugFrameWork/SegHndlr.cpp
+++ b/src/DebugFrameWork/SegHndlr.cpp
@@ -187,12 +187,15 @@ void print_backtrace(int signum, siginfo_t * info, void *ptr)
     }
     while (bp && ip)
     {
+#ifndef EMULATOR
         if (!dladdr(ip, &dlinfo))
         {
          
           fprintf(stderr, \\\"could n't get symbol info:\\\\n\\\");
           break;
         }
+#else
+#endif
 
         const char *symname = dlinfo.dli_sname;
 
diff --git a/src/app/common/blocks/NetD/Netd_ECC_Agent/makefile b/src/app/common/blocks/NetD/Netd_ECC_Agent/makefile
index e28a385..5a0d808 100755
--- a/src/app/common/blocks/NetD/Netd_ECC_Agent/makefile
+++ b/src/app/common/blocks/NetD/Netd_ECC_Agent/makefile
@@ -34,7 +34,7 @@ ADDED_C++_INCLUDES = -I\\\$(SOFTWARE_ROOT)/hal/common \\\\
 					 -I\\\$(ETHCOMMON_ROOT) \\\\
 					 -I\\\$(ETHCOMMON_ROOT)/include \\\\
 					 -I\\\$(ETHCOMMON_ROOT)/hal/common
-ADDED_C++FLAGS = -DTHREADED -DCOSMO_CAL -Werror
+ADDED_C++FLAGS = -DTHREADED -DCOSMO_CAL 
 
 ################################################################################
 include \\\$(SOFTWARE_ROOT)/make/rules.tn100
diff --git a/src/app/common/blocks/NetD/Netd_Mgr/makefile b/src/app/common/blocks/NetD/Netd_Mgr/makefile
index ec2dabb..d1ee851 100644
--- a/src/app/common/blocks/NetD/Netd_Mgr/makefile
+++ b/src/app/common/blocks/NetD/Netd_Mgr/makefile
@@ -35,7 +35,7 @@ ADDED_C++_INCLUDES =-I \\\$(SOFTWARE_ROOT)/hal/common \\\\
                     -I \\\$(ETHCOMMON_ROOT) \\\\
                     -I \\\$(ETHCOMMON_ROOT)/include 
 
-ADDED_C++FLAGS = -DTHREADED -DCOSMO_CAL -Werror
+ADDED_C++FLAGS = -DTHREADED -DCOSMO_CAL 
 
 ################################################################################
 include \\\$(SOFTWARE_ROOT)/make/rules.tn100
diff --git a/src/app/common/blocks/dhcp/dhcp.cpp b/src/app/common/blocks/dhcp/dhcp.cpp
index 1957d2a..3696aac 100755
--- a/src/app/common/blocks/dhcp/dhcp.cpp
+++ b/src/app/common/blocks/dhcp/dhcp.cpp
@@ -1,8 +1,10 @@
 #include <string>
-#include <cstring>
 #include <stdio.h>
+#ifndef EMULATOR
+#include <string>
+#else
 #include <cstring>
-
+#endif
 #include \\\"dhcp.h\\\"
 static const string dhcp_config_file(\\\"/etc/name/config/dhcpd.conf\\\");
 static const string dhcp_leases_file(\\\"/etc/name/config/dhcpd.leases\\\");
diff --git a/src/app/common/nm/nm/webpages/genpages/datalib/makefile b/src/app/common/nm/nm/webpages/genpages/datalib/makefile
index 3630e07..4532861 100755
--- a/src/app/common/nm/nm/webpages/genpages/datalib/makefile
+++ b/src/app/common/nm/nm/webpages/genpages/datalib/makefile
@@ -10,7 +10,7 @@
 ################################################################################
 
 ADDED_C_INCLUDES = -I\\\$(SOFTWARE_ROOT)/app/common/nm
-ADDED_CFLAGS = #-Werror
+#ADDED_CFLAGS = #-Werror
 ADDED_C++_INCLUDES = \\\\
 	-I\\\$(SOFTWARE_ROOT)/app/common \\\\
 	-I\\\$(SOFTWARE_ROOT)/app/common/nm \\\\
@@ -18,7 +18,7 @@ ADDED_C++_INCLUDES = \\\\
 	-I\\\$(ETHTRANSPORT_ROOT)/include \\\\
 	-I\\\$(ETHCOMMON_ROOT)/include \\\\
 	-I\\\$(ETHCOMMON_ROOT)/app/common/nm
-ADDED_C++FLAGS = -Werror
+#ADDED_C++FLAGS = -Werror
 
 
 ################################################################################
diff --git a/src/app/common/nm/snmp/SnmpAgent.cpp b/src/app/common/nm/snmp/SnmpAgent.cpp
index 75241d7..7ed323f 100755
--- a/src/app/common/nm/snmp/SnmpAgent.cpp
+++ b/src/app/common/nm/snmp/SnmpAgent.cpp
@@ -50,6 +50,7 @@ Handle<SnmpAgent> SnmpAgent::getSnmpAgent()
 //------------------------------------------------------------------------
 
 extern string oemName;
+extern bool simulatorMode;
 
 static bool enableSNMPProvision ()
 {
@@ -59,6 +60,7 @@ static bool enableSNMPProvision ()
 extern NESecuritySettings *theNESecuritySettings;
 void SnmpAgent::run()
 {
+    if(simulatorMode) return;
 #ifdef NM_DBGMGR_SUPPORT
     DebugMgr::registerThreadId(\\\"SnmpAgent\\\",\\\"SnmpAgent listening thread\\\");
 #endif
diff --git a/src/cal/conn/UdpServerOS.h b/src/cal/conn/UdpServerOS.h
index e034fd1..936e1b5 100755
--- a/src/cal/conn/UdpServerOS.h
+++ b/src/cal/conn/UdpServerOS.h
@@ -3,7 +3,11 @@
 
 #include <iostream>
 #include <map>
+#ifndef EMULATOR
 #include <string>
+#else
+#include <cstring>
+#endif
 #include \\\"serverOS.h\\\"
 #include <include/tj_types.h>
 using namespace std;
diff --git a/src/hal/common/makefile b/src/hal/common/makefile
index 62989f1..7576ca3 100755
--- a/src/hal/common/makefile
+++ b/src/hal/common/makefile
@@ -44,7 +44,7 @@ ADDED_C++_INCLUDES = -I\\\$(SOFTWARE_ROOT)/hal/drivers/char \\\\
 ADDED_C++FLAGS = 
 
 ifneq (\\\$(MODE), EMULATOR)
-	ADDED_C++FLAGS += -Werror
+	ADDED_C++FLAGS += 
 endif
 
 \\\$(SOFTWARE_ROOT)/common/cardCharacteristics.o: ADDED_C++FLAGS += -fexceptions 
diff --git a/src/hal/devices/VtTermWrapper.cpp b/src/hal/devices/VtTermWrapper.cpp
index b62023a..4735cfc 100755
--- a/src/hal/devices/VtTermWrapper.cpp
+++ b/src/hal/devices/VtTermWrapper.cpp
@@ -471,7 +471,7 @@ VtTermWrapper::VtTermWrapper(vtTerm *vt_terms[], const UInt32 &num_vt_terms,
 vtTerm(vt_stm_multiplicity), numVtTerms(num_vt_terms)
 {
     vtTerms = new vtTerm *[num_vt_terms];
-    memcpy(vtTerms, vt_terms, (num_vt_terms * sizeof(vtTerm *)));
+    //memcpy(vtTerms, vt_terms, (num_vt_terms * sizeof(vtTerm *)));
     vtStmMultiplicity = vt_stm_multiplicity;
 
     callbackDataArray = new VtEventHandlerWrapper[numVtTerms];
diff --git a/src/lib/threadPool.cpp b/src/lib/threadPool.cpp
index 058d0ac..e4d156b 100755
--- a/src/lib/threadPool.cpp
+++ b/src/lib/threadPool.cpp
@@ -68,7 +68,7 @@ ThreadPool::ThreadPool(int num_threads)
     waitingForThreadResource = 0;
     mNumThreads = num_threads;
     sem_init(&ThreadPool::mSemThread, 0, 1);
-    SEM_WAIT(&ThreadPool::mSemThread) ; // Initial state is 1 (non-blocked)
+    SEM_WAIT(&mSemThread) ; // Initial state is 1 (non-blocked)
 }
 
 
@@ -175,7 +175,7 @@ threadElement* ThreadPool::getThread(char *name, int pri, void(*run)(void *),
                 TRC( \\\"ThreadPool::getThread: WaitingForThreadResource on Semaphore\\\");
             }
 
-            SEM_WAIT (&ThreadPool::mSemThread) ;
+            SEM_WAIT (&mSemThread) ;
         }
     }
     return t;
diff --git a/src/sstream b/src/sstream
deleted file mode 100755
index 45e05b1..0000000
--- a/src/sstream
+++ /dev/null
@@ -1,25 +0,0 @@
-#if __GNUC__ < 3
-#ifdef UNIX
-#include <stl/linuxsstream.h>
-#endif
-
-#ifdef VXWORKS 
-#include <stl/stringstream.h>
-#endif
-
-#ifdef WIN32
-#error
-#endif
-#else
-#if (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)
-        #ifdef TCARD_EDC01 
-            #include \\\"/opt/MIPS/OCTEON-SDK/tools/mips64-octeon-linux-gnu/include/c++/4.3.3/sstream\\\"
-        #else
-#include \\\"/opt/ELDK42/ppc_85xx/usr/include/c++/4.2.2/sstream\\\"
-        #endif
-#else 
-#include \\\"/opt/ELDK41/ppc_6xx/usr/include/c++/4.0.0/sstream\\\"
-#endif
-#endif
-
-
diff --git a/src/string b/src/string
deleted file mode 100755
index 895d4a7..0000000
--- a/src/string
+++ /dev/null
@@ -1,20 +0,0 @@
-#if __GNUC__ < 3
-#ifdef WIN32
-#error
-#else
-#include <stl/std_string.h>
-#endif
-#else
-#if (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)
-        #ifdef TCARD_EDC01 
-            #include \\\"/opt/MIPS/OCTEON-SDK/tools/mips64-octeon-linux-gnu/include/c++/4.3.3/string\\\"
-        #else
-#include \\\"/opt/ELDK42/ppc_85xx/usr/include/c++/4.2.2/string\\\"
-        #endif
-#else 
-#include \\\"/opt/ELDK41/ppc_6xx/usr/include/c++/4.0.0/string\\\"
-#endif
-    #include \\\"string.h\\\"
-#endif
-
-
\" > \$tj100_mc_diff_file_path/tj100_mc_BR_10_0_2.diff
#modify#tj100_mc#file#BR_10_0_2#end

#modify#tj100_mc#file#NEOS10_CEF5_DEV#start
echo -n \"diff --git a/src/DebugFrameWork/DebugMgr.cpp b/src/DebugFrameWork/DebugMgr.cpp
index 2ad571c..fa6d9e6 100755
--- a/src/DebugFrameWork/DebugMgr.cpp
+++ b/src/DebugFrameWork/DebugMgr.cpp
@@ -1,5 +1,9 @@
 #include <iomanip>
-#include <vector>
+#ifndef EMULATOR
+    #include <vector.h>
+#else
+    #include <vector>
+#endif
 #include <stdio.h>
 #include <ctype.h>
 #include <strings.h>
@@ -20,7 +24,9 @@
 #include <limits.h>
 #include <errno.h>
 #include <time.h>
-//#include <asm/user.h>
+#ifndef EMULATOR
+    #include <asm/user.h>
+#endif
 #include <sys/wait.h>
 #include <sched.h>
 #include <sys/resource.h>
diff --git a/src/DebugFrameWork/DebugMgr.h b/src/DebugFrameWork/DebugMgr.h
index 0cbd8b9..e91e540 100755
--- a/src/DebugFrameWork/DebugMgr.h
+++ b/src/DebugFrameWork/DebugMgr.h
@@ -13,7 +13,11 @@
 
 
 #include <bits/siginfo.h>
-#include <string>
+#ifndef EMULATOR
+ #include <string>
+#else
+#include <cstring>
+#endif
 #include <map>
 #include <sstream>
 #include \\\"SocketMgr.h\\\"
diff --git a/src/DebugFrameWork/SegHndlr.cpp b/src/DebugFrameWork/SegHndlr.cpp
index 3b83b5f..5a84c8c 100755
--- a/src/DebugFrameWork/SegHndlr.cpp
+++ b/src/DebugFrameWork/SegHndlr.cpp
@@ -187,12 +187,15 @@ void print_backtrace(int signum, siginfo_t * info, void *ptr)
     }
     while (bp && ip)
     {
+#ifndef EMULATOR
         if (!dladdr(ip, &dlinfo))
         {
          
           fprintf(stderr, \\\"could n't get symbol info:\\\\n\\\");
           break;
         }
+#else
+#endif
 
         const char *symname = dlinfo.dli_sname;
 
diff --git a/src/app/common/blocks/NetD/Netd_ECC_Agent/makefile b/src/app/common/blocks/NetD/Netd_ECC_Agent/makefile
index e28a385..5a0d808 100755
--- a/src/app/common/blocks/NetD/Netd_ECC_Agent/makefile
+++ b/src/app/common/blocks/NetD/Netd_ECC_Agent/makefile
@@ -34,7 +34,7 @@ ADDED_C++_INCLUDES = -I\\\$(SOFTWARE_ROOT)/hal/common \\\\
 					 -I\\\$(ETHCOMMON_ROOT) \\\\
 					 -I\\\$(ETHCOMMON_ROOT)/include \\\\
 					 -I\\\$(ETHCOMMON_ROOT)/hal/common
-ADDED_C++FLAGS = -DTHREADED -DCOSMO_CAL -Werror
+ADDED_C++FLAGS = -DTHREADED -DCOSMO_CAL 
 
 ################################################################################
 include \\\$(SOFTWARE_ROOT)/make/rules.tn100
diff --git a/src/app/common/blocks/NetD/Netd_Mgr/makefile b/src/app/common/blocks/NetD/Netd_Mgr/makefile
index cc192c2..8b5108b 100644
--- a/src/app/common/blocks/NetD/Netd_Mgr/makefile
+++ b/src/app/common/blocks/NetD/Netd_Mgr/makefile
@@ -35,7 +35,7 @@ ADDED_C++_INCLUDES =-I \\\$(SOFTWARE_ROOT)/hal/common \\\\
                     -I \\\$(ETHCOMMON_ROOT) \\\\
                     -I \\\$(ETHCOMMON_ROOT)/include 
 
-ADDED_C++FLAGS = -DTHREADED -DCOSMO_CAL -Werror
+ADDED_C++FLAGS = -DTHREADED -DCOSMO_CAL 
 
 ################################################################################
 include \\\$(SOFTWARE_ROOT)/make/rules.tn100
diff --git a/src/app/common/blocks/dhcp/dhcp.cpp b/src/app/common/blocks/dhcp/dhcp.cpp
index 1957d2a..3696aac 100755
--- a/src/app/common/blocks/dhcp/dhcp.cpp
+++ b/src/app/common/blocks/dhcp/dhcp.cpp
@@ -1,8 +1,10 @@
 #include <string>
-#include <cstring>
 #include <stdio.h>
+#ifndef EMULATOR
+#include <string>
+#else
 #include <cstring>
-
+#endif
 #include \\\"dhcp.h\\\"
 static const string dhcp_config_file(\\\"/etc/name/config/dhcpd.conf\\\");
 static const string dhcp_leases_file(\\\"/etc/name/config/dhcpd.leases\\\");
diff --git a/src/app/common/nm/nm/webpages/genpages/datalib/makefile b/src/app/common/nm/nm/webpages/genpages/datalib/makefile
index adc2614..84bebc4 100755
--- a/src/app/common/nm/nm/webpages/genpages/datalib/makefile
+++ b/src/app/common/nm/nm/webpages/genpages/datalib/makefile
@@ -17,7 +17,7 @@ ADDED_C++_INCLUDES = \\\\
 	-I\\\$(SWITCHING_ROOT)/app/common/nm \\\\
 	-I\\\$(ETHTRANSPORT_ROOT)/include \\\\
 	-I\\\$(ETHCOMMON_ROOT)/include
-ADDED_C++FLAGS = -Werror
+ADDED_C++FLAGS = 
 
 
 ################################################################################
diff --git a/src/app/tj1700/nm/impl/tj1700Shelf.cpp b/src/app/tj1700/nm/impl/tj1700Shelf.cpp
index bffb159..289b86f 100755
--- a/src/app/tj1700/nm/impl/tj1700Shelf.cpp
+++ b/src/app/tj1700/nm/impl/tj1700Shelf.cpp
@@ -41,7 +41,7 @@ Handle<Card> TJ1700ShelfImpl::getSelfCard()
 {
 	int slot,self_slot;
     SystemVariantType sysType;
-    mChassisMgr->getSystemType(sysType);
+    //mChassisMgr->getSystemType(sysType);
 
     if ( SYSTEM_TJ16006 == sysType )
         self_slot = TJ16006_PSS1_SLOT_NO;
@@ -72,7 +72,7 @@ bool TJ1700ShelfImpl::CardCreationPreCondition(unsigned slot, unsigned  cardtype
             slot);
 
     SystemVariantType sysType;
-    mChassisMgr->getSystemType(sysType);
+    //mChassisMgr->getSystemType(sysType);
 
     switch (cardtype){
         case Card::card_BackPlane:
diff --git a/src/cal/conn/UdpServerOS.h b/src/cal/conn/UdpServerOS.h
index e034fd1..936e1b5 100755
--- a/src/cal/conn/UdpServerOS.h
+++ b/src/cal/conn/UdpServerOS.h
@@ -3,7 +3,11 @@
 
 #include <iostream>
 #include <map>
+#ifndef EMULATOR
 #include <string>
+#else
+#include <cstring>
+#endif
 #include \\\"serverOS.h\\\"
 #include <include/tj_types.h>
 using namespace std;
diff --git a/src/hal/common/makefile b/src/hal/common/makefile
index 8b4e710..5b346dc 100755
--- a/src/hal/common/makefile
+++ b/src/hal/common/makefile
@@ -44,7 +44,7 @@ ADDED_C++_INCLUDES = -I\\\$(SOFTWARE_ROOT)/hal/drivers/char \\\\
 ADDED_C++FLAGS = 
 
 ifneq (\\\$(MODE), EMULATOR)
-	ADDED_C++FLAGS += -Werror
+	ADDED_C++FLAGS += 
 endif
 
 \\\$(SOFTWARE_ROOT)/common/cardCharacteristics.o: ADDED_C++FLAGS += -fexceptions 
diff --git a/src/hal/devices/VtTermWrapper.cpp b/src/hal/devices/VtTermWrapper.cpp
index b62023a..4735cfc 100755
--- a/src/hal/devices/VtTermWrapper.cpp
+++ b/src/hal/devices/VtTermWrapper.cpp
@@ -471,7 +471,7 @@ VtTermWrapper::VtTermWrapper(vtTerm *vt_terms[], const UInt32 &num_vt_terms,
 vtTerm(vt_stm_multiplicity), numVtTerms(num_vt_terms)
 {
     vtTerms = new vtTerm *[num_vt_terms];
-    memcpy(vtTerms, vt_terms, (num_vt_terms * sizeof(vtTerm *)));
+    //memcpy(vtTerms, vt_terms, (num_vt_terms * sizeof(vtTerm *)));
     vtStmMultiplicity = vt_stm_multiplicity;
 
     callbackDataArray = new VtEventHandlerWrapper[numVtTerms];
diff --git a/src/lib/threadPool.cpp b/src/lib/threadPool.cpp
index 058d0ac..e4d156b 100755
--- a/src/lib/threadPool.cpp
+++ b/src/lib/threadPool.cpp
@@ -68,7 +68,7 @@ ThreadPool::ThreadPool(int num_threads)
     waitingForThreadResource = 0;
     mNumThreads = num_threads;
     sem_init(&ThreadPool::mSemThread, 0, 1);
-    SEM_WAIT(&ThreadPool::mSemThread) ; // Initial state is 1 (non-blocked)
+    SEM_WAIT(&mSemThread) ; // Initial state is 1 (non-blocked)
 }
 
 
@@ -175,7 +175,7 @@ threadElement* ThreadPool::getThread(char *name, int pri, void(*run)(void *),
                 TRC( \\\"ThreadPool::getThread: WaitingForThreadResource on Semaphore\\\");
             }
 
-            SEM_WAIT (&ThreadPool::mSemThread) ;
+            SEM_WAIT (&mSemThread) ;
         }
     }
     return t;
diff --git a/src/sstream b/src/sstream
deleted file mode 100755
index 7fbb6ba..0000000
--- a/src/sstream
+++ /dev/null
@@ -1,19 +0,0 @@
-#if __GNUC__ < 3
-#ifdef UNIX
-#include <stl/linuxsstream.h>
-#endif
-
-#ifdef VXWORKS 
-#include <stl/stringstream.h>
-#endif
-
-#ifdef WIN32
-#error
-#endif
-#else
-#if (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)
-#include \\\"/opt/ELDK42/ppc_85xx/usr/include/c++/4.2.2/sstream\\\"
-#else 
-#include \\\"/opt/ELDK41/ppc_6xx/usr/include/c++/4.0.0/sstream\\\"
-#endif
-#endif
diff --git a/src/string b/src/string
deleted file mode 100755
index 9ac4e0b..0000000
--- a/src/string
+++ /dev/null
@@ -1,14 +0,0 @@
-#if __GNUC__ < 3
-#ifdef WIN32
-#error
-#else
-#include <stl/std_string.h>
-#endif
-#else
-#if (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)
-#include \\\"/opt/ELDK42/ppc_85xx/usr/include/c++/4.2.2/string\\\"
-#else 
-#include \\\"/opt/ELDK41/ppc_6xx/usr/include/c++/4.0.0/string\\\"
-#endif
-#endif
-
\" > \$tj100_mc_diff_file_path/tj100_mc_NEOS10_CEF5_DEV.diff
#modify#tj100_mc#file#NEOS10_CEF5_DEV#end



#modify#tj100_mc#file#BR_8_0_1#start
echo -n \"diff --git a/src/DebugFrameWork/DebugMgr.cpp b/src/DebugFrameWork/DebugMgr.cpp
index 2ad571c..fa6d9e6 100755
--- a/src/DebugFrameWork/DebugMgr.cpp
+++ b/src/DebugFrameWork/DebugMgr.cpp
@@ -1,5 +1,9 @@
 #include <iomanip>
-#include <vector>
+#ifndef EMULATOR
+    #include <vector.h>
+#else
+    #include <vector>
+#endif
 #include <stdio.h>
 #include <ctype.h>
 #include <strings.h>
@@ -20,7 +24,9 @@
 #include <limits.h>
 #include <errno.h>
 #include <time.h>
-//#include <asm/user.h>
+#ifndef EMULATOR
+    #include <asm/user.h>
+#endif
 #include <sys/wait.h>
 #include <sched.h>
 #include <sys/resource.h>
diff --git a/src/DebugFrameWork/DebugMgr.h b/src/DebugFrameWork/DebugMgr.h
index 0cbd8b9..e91e540 100755
--- a/src/DebugFrameWork/DebugMgr.h
+++ b/src/DebugFrameWork/DebugMgr.h
@@ -13,7 +13,11 @@
 
 
 #include <bits/siginfo.h>
-#include <string>
+#ifndef EMULATOR
+ #include <string>
+#else
+#include <cstring>
+#endif
 #include <map>
 #include <sstream>
 #include \\\"SocketMgr.h\\\"
diff --git a/src/DebugFrameWork/SegHndlr.cpp b/src/DebugFrameWork/SegHndlr.cpp
index a4d85b9..d36b381 100755
--- a/src/DebugFrameWork/SegHndlr.cpp
+++ b/src/DebugFrameWork/SegHndlr.cpp
@@ -187,12 +187,15 @@ void print_backtrace(int signum, siginfo_t * info, void *ptr)
     }
     while (bp && ip)
     {
+#ifndef EMULATOR
         if (!dladdr(ip, &dlinfo))
         {
          
           fprintf(stderr, \\\"could n't get symbol info:\\\\n\\\");
           break;
         }
+#else
+#endif
 
         const char *symname = dlinfo.dli_sname;
 
diff --git a/src/app/common/blocks/NetD/Netd_ECC_Agent/makefile b/src/app/common/blocks/NetD/Netd_ECC_Agent/makefile
index e28a385..5a0d808 100755
--- a/src/app/common/blocks/NetD/Netd_ECC_Agent/makefile
+++ b/src/app/common/blocks/NetD/Netd_ECC_Agent/makefile
@@ -34,7 +34,7 @@ ADDED_C++_INCLUDES = -I\\\$(SOFTWARE_ROOT)/hal/common \\\\
 					 -I\\\$(ETHCOMMON_ROOT) \\\\
 					 -I\\\$(ETHCOMMON_ROOT)/include \\\\
 					 -I\\\$(ETHCOMMON_ROOT)/hal/common
-ADDED_C++FLAGS = -DTHREADED -DCOSMO_CAL -Werror
+ADDED_C++FLAGS = -DTHREADED -DCOSMO_CAL 
 
 ################################################################################
 include \\\$(SOFTWARE_ROOT)/make/rules.tn100
diff --git a/src/app/common/blocks/NetD/Netd_Mgr/makefile b/src/app/common/blocks/NetD/Netd_Mgr/makefile
index cc192c2..8b5108b 100644
--- a/src/app/common/blocks/NetD/Netd_Mgr/makefile
+++ b/src/app/common/blocks/NetD/Netd_Mgr/makefile
@@ -35,7 +35,7 @@ ADDED_C++_INCLUDES =-I \\\$(SOFTWARE_ROOT)/hal/common \\\\
                     -I \\\$(ETHCOMMON_ROOT) \\\\
                     -I \\\$(ETHCOMMON_ROOT)/include 
 
-ADDED_C++FLAGS = -DTHREADED -DCOSMO_CAL -Werror
+ADDED_C++FLAGS = -DTHREADED -DCOSMO_CAL 
 
 ################################################################################
 include \\\$(SOFTWARE_ROOT)/make/rules.tn100
diff --git a/src/app/common/nm/nm/webpages/genpages/datalib/makefile b/src/app/common/nm/nm/webpages/genpages/datalib/makefile
index adc2614..84bebc4 100755
--- a/src/app/common/nm/nm/webpages/genpages/datalib/makefile
+++ b/src/app/common/nm/nm/webpages/genpages/datalib/makefile
@@ -17,7 +17,7 @@ ADDED_C++_INCLUDES = \\\\
 	-I\\\$(SWITCHING_ROOT)/app/common/nm \\\\
 	-I\\\$(ETHTRANSPORT_ROOT)/include \\\\
 	-I\\\$(ETHCOMMON_ROOT)/include
-ADDED_C++FLAGS = -Werror
+ADDED_C++FLAGS = 
 
 
 ################################################################################
diff --git a/src/app/tj1700/nm/impl/tj1700Shelf.cpp b/src/app/tj1700/nm/impl/tj1700Shelf.cpp
index 5b725cc..5afbd86 100755
--- a/src/app/tj1700/nm/impl/tj1700Shelf.cpp
+++ b/src/app/tj1700/nm/impl/tj1700Shelf.cpp
@@ -41,8 +41,10 @@ Handle<Card> TJ1700ShelfImpl::getSelfCard()
 {
 	int slot,self_slot;
     SystemVariantType sysType;
-    mChassisMgr->getSystemType(sysType);
-
+    if(mChassisMgr)
+    {
+    	mChassisMgr->getSystemType(sysType); 
+    }
     if ( SYSTEM_TJ16006 == sysType )
         self_slot = TJ16006_PSS1_SLOT_NO;
     else
@@ -72,8 +74,10 @@ bool TJ1700ShelfImpl::CardCreationPreCondition(unsigned slot, unsigned  cardtype
             slot);
 
     SystemVariantType sysType;
-    mChassisMgr->getSystemType(sysType);
-
+	if(mChassisMgr)
+	{
+    		mChassisMgr->getSystemType(sysType);
+	}
     switch (cardtype){
         case Card::card_BackPlane:
             if (slot != 0){
@@ -397,9 +401,8 @@ void TJ1700ShelfImpl::createSimulatedCards(const string & /* nodeConfStr */)
         //createMibCard(5, Card::card_XCC360G, \\\"\\\\t-CardType\\\\tcard_XCC360G\\\", true);
 
         Handle<Card_ELAN04> hElan04Card;
-
+		Handle<Card> hCEF5Card;
         {
-            Handle<Card> hCEF5Card;
             createMibCard(1, Card::card_CEF5, nullString, true);
             hCEF5Card = getCard(1);
             hElan04Card = DYNAMIC_CAST<Card, Card_ELAN04>(hCEF5Card);
@@ -416,7 +419,6 @@ void TJ1700ShelfImpl::createSimulatedCards(const string & /* nodeConfStr */)
         }
         {
 
-            Handle<Card> hCEF5Card;
             createMibCard(2, Card::card_CEF5, nullString, true);
             hCEF5Card = getCard(2);
             hElan04Card = DYNAMIC_CAST<Card, Card_ELAN04>(hCEF5Card);
@@ -433,7 +435,6 @@ void TJ1700ShelfImpl::createSimulatedCards(const string & /* nodeConfStr */)
 
         }
         {
-            Handle<Card> hCEF5Card;
             createMibCard(3, Card::card_CEF5, nullString, true);
             hCEF5Card = getCard(3);
             hElan04Card = DYNAMIC_CAST<Card, Card_ELAN04>(hCEF5Card);
@@ -448,9 +449,23 @@ void TJ1700ShelfImpl::createSimulatedCards(const string & /* nodeConfStr */)
                 hElan04Card->commit(pluginUser);
             }
         }
-
-        createMibCard(4, Card::card_AGG20, \\\"\\\\t-NumOfSTM64s\\\\t2\\\", true);
-        createMibCard(7, Card::card_AGG40, nullString, true);
+        {
+            createMibCard(4, Card::card_CEF5, nullString, true);
+            hCEF5Card = getCard(4);
+            hElan04Card = DYNAMIC_CAST<Card, Card_ELAN04>(hCEF5Card);
+            if (hElan04Card)
+            {   
+                hElan04Card->setValues(\\\"\\\\t-NumOfFEPorts\\\\t16\\\\t-NumOfGEPorts\\\\t4\\\\t-NumOfEthernetPorts\\\\t20\\\\t-NumOfVCGPorts\\\\t10\\\");
+                hElan04Card->setNumOfVCGPorts(20);
+                hElan04Card->setNumOfSFPports(0);
+                hElan04Card->setNumOfTwistedPairPorts(16);
+                tjAssertMessage(hElan04Card->verify(), __FUNCTION__
+                        << \\\": verify() failed for setting Elan04Card params in slot 4\\\");
+                hElan04Card->commit(pluginUser);
+            }   
+        }
+       // createMibCard(4, Card::card_AGG20, \\\"\\\\t-NumOfSTM64s\\\\t2\\\", true);
+       // createMibCard(7, Card::card_AGG40, nullString, true);
         //createMibCard(7, Card::card_AGG20, \\\"\\\\t-NumOfSTM64s\\\\t2\\\", true);
 #ifdef L2_SWITCHING_SUPPORT
         Handle<Card> hCard;
@@ -485,15 +500,27 @@ void TJ1700ShelfImpl::createSimulatedCards(const string & /* nodeConfStr */)
                     << \\\": verify() failed for setting Elan04Card params in slot 9\\\");
             hElan04Card->commit(pluginUser);
         }
-
-        Handle<Card> hCEF5Card;
+       /* 
+        createMibCard(9, Card::card_CEF5, nullString, true);
+        hCEF5Card = getCard(9);
+        hElan04Card = DYNAMIC_CAST<Card, Card_ELAN04>(hCEF5Card);
+        if (hElan04Card) {
+            hElan04Card->setValues(\\\"\\\\t-NumOfFEPorts\\\\t16\\\\t-NumOfGEPorts\\\\t4\\\\t-NumOfEthernetPorts\\\\t20\\\");
+            hElan04Card->setNumOfVCGPorts(0);
+            hElan04Card->setNumOfSFPports(0);
+            hElan04Card->setNumOfTwistedPairPorts(16);
+            tjAssertMessage(hElan04Card->verify(), __FUNCTION__
+                    << \\\": verify() failed for setting Elan04Card params in slot 9\\\");
+            hElan04Card->commit(pluginUser);
+        }
+*/
         createMibCard(10, Card::card_CEF5, nullString, true);
         hCEF5Card = getCard(10);
         hElan04Card = DYNAMIC_CAST<Card, Card_ELAN04>(hCEF5Card);
         if (hElan04Card)
         {
-            hElan04Card->setValues(\\\"\\\\t-NumOfFEPorts\\\\t16\\\\t-NumOfGEPorts\\\\t4\\\\t-NumOfEthernetPorts\\\\t20\\\\t-NumOfVCGPorts\\\\t10\\\");
-            hElan04Card->setNumOfVCGPorts(20);
+            hElan04Card->setValues(\\\"\\\\t-NumOfFEPorts\\\\t16\\\\t-NumOfGEPorts\\\\t4\\\\t-NumOfEthernetPorts\\\\t20\\\");
+            hElan04Card->setNumOfVCGPorts(0);
             hElan04Card->setNumOfSFPports(0);
             hElan04Card->setNumOfTwistedPairPorts(16);
             tjAssertMessage(hElan04Card->verify(), __FUNCTION__
@@ -502,6 +529,8 @@ void TJ1700ShelfImpl::createSimulatedCards(const string & /* nodeConfStr */)
         }
 
 #else
+		createMibCard(2, Card::card_AGG21, nullString, true);
+		createMibCard(3, Card::card_AGG21, nullString, true);
 		createMibCard(9, Card::card_AGG21, nullString, true);
         createMibCard(10, Card::card_AGG21, nullString, true);
 #endif
diff --git a/src/cal/conn/UdpServerOS.h b/src/cal/conn/UdpServerOS.h
index e034fd1..936e1b5 100755
--- a/src/cal/conn/UdpServerOS.h
+++ b/src/cal/conn/UdpServerOS.h
@@ -3,7 +3,11 @@
 
 #include <iostream>
 #include <map>
+#ifndef EMULATOR
 #include <string>
+#else
+#include <cstring>
+#endif
 #include \\\"serverOS.h\\\"
 #include <include/tj_types.h>
 using namespace std;
diff --git a/src/hal/common/makefile b/src/hal/common/makefile
index 8b4e710..5b346dc 100755
--- a/src/hal/common/makefile
+++ b/src/hal/common/makefile
@@ -44,7 +44,7 @@ ADDED_C++_INCLUDES = -I\\\$(SOFTWARE_ROOT)/hal/drivers/char \\\\
 ADDED_C++FLAGS = 
 
 ifneq (\\\$(MODE), EMULATOR)
-	ADDED_C++FLAGS += -Werror
+	ADDED_C++FLAGS += 
 endif
 
 \\\$(SOFTWARE_ROOT)/common/cardCharacteristics.o: ADDED_C++FLAGS += -fexceptions 
diff --git a/src/hal/devices/VtTermWrapper.cpp b/src/hal/devices/VtTermWrapper.cpp
index b62023a..4735cfc 100755
--- a/src/hal/devices/VtTermWrapper.cpp
+++ b/src/hal/devices/VtTermWrapper.cpp
@@ -471,7 +471,7 @@ VtTermWrapper::VtTermWrapper(vtTerm *vt_terms[], const UInt32 &num_vt_terms,
 vtTerm(vt_stm_multiplicity), numVtTerms(num_vt_terms)
 {
     vtTerms = new vtTerm *[num_vt_terms];
-    memcpy(vtTerms, vt_terms, (num_vt_terms * sizeof(vtTerm *)));
+    //memcpy(vtTerms, vt_terms, (num_vt_terms * sizeof(vtTerm *)));
     vtStmMultiplicity = vt_stm_multiplicity;
 
     callbackDataArray = new VtEventHandlerWrapper[numVtTerms];
diff --git a/src/lib/threadPool.cpp b/src/lib/threadPool.cpp
index 058d0ac..e4d156b 100755
--- a/src/lib/threadPool.cpp
+++ b/src/lib/threadPool.cpp
@@ -68,7 +68,7 @@ ThreadPool::ThreadPool(int num_threads)
     waitingForThreadResource = 0;
     mNumThreads = num_threads;
     sem_init(&ThreadPool::mSemThread, 0, 1);
-    SEM_WAIT(&ThreadPool::mSemThread) ; // Initial state is 1 (non-blocked)
+    SEM_WAIT(&mSemThread) ; // Initial state is 1 (non-blocked)
 }
 
 
@@ -175,7 +175,7 @@ threadElement* ThreadPool::getThread(char *name, int pri, void(*run)(void *),
                 TRC( \\\"ThreadPool::getThread: WaitingForThreadResource on Semaphore\\\");
             }
 
-            SEM_WAIT (&ThreadPool::mSemThread) ;
+            SEM_WAIT (&mSemThread) ;
         }
     }
     return t;
diff --git a/src/sstream b/src/sstream
deleted file mode 100755
index 7fbb6ba..0000000
--- a/src/sstream
+++ /dev/null
@@ -1,19 +0,0 @@
-#if __GNUC__ < 3
-#ifdef UNIX
-#include <stl/linuxsstream.h>
-#endif
-
-#ifdef VXWORKS 
-#include <stl/stringstream.h>
-#endif
-
-#ifdef WIN32
-#error
-#endif
-#else
-#if (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)
-#include \\\"/opt/ELDK42/ppc_85xx/usr/include/c++/4.2.2/sstream\\\"
-#else 
-#include \\\"/opt/ELDK41/ppc_6xx/usr/include/c++/4.0.0/sstream\\\"
-#endif
-#endif
diff --git a/src/string b/src/string
deleted file mode 100755
index 9ac4e0b..0000000
--- a/src/string
+++ /dev/null
@@ -1,14 +0,0 @@
-#if __GNUC__ < 3
-#ifdef WIN32
-#error
-#else
-#include <stl/std_string.h>
-#endif
-#else
-#if (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)
-#include \\\"/opt/ELDK42/ppc_85xx/usr/include/c++/4.2.2/string\\\"
-#else 
-#include \\\"/opt/ELDK41/ppc_6xx/usr/include/c++/4.0.0/string\\\"
-#endif
-#endif
-
\" > \$tj100_mc_diff_file_path/tj100_mc_BR_8_0_1.diff
#modify#tj100_mc#file#BR_8_0_1#end



#modify#tj100_mc#file#end

echo \"Generating licence.dat in \$tj100_mc_diff_file_path\";
echo -n \"\\
VERSION 2
NodeType TJMC1700
ProductCode TJ1600C
NodeConfiguration ADM64
OSPF YES
SNMP YES
SILVX_MGR YES
EMS_GUI YES
MODE SDH_OR_SONET
AU-MODE AU4_OR_AU3
SSM YES
NES_DOC NO
OVERHEAD_TUNNEL YES
CAPABILITY STM64
DHCP YES
ALLOW_ALL_SFP YES
REDUNDANCYMODE REDUNDANT
OrderWire YES
AUTO_DISCOVERY YES
BLSR YES
BLSR_EXTRA_TRAFFIC_SUPPORTED YES
BLSR_ENUT_SUPPORTED YES
FMECA  YES
TERMSERVER YES
LOGIN_APP YES
RADIUS YES
\" > \$tj100_mc_diff_file_path/license.dat

echo \"Generated all files now goto the checkout directory to find all files needed\";
echo \"changing permissions of \$scripts_path & \$tj100_mc_diff_file_path\";
chmod -R 777 \$scripts_path \$tj100_mc_diff_file_path;
echo DONE
##############################################################################################################################################
#After this you can call the master_script if you want with apropriate option. 
#I am exiting here only.
exit;
##############################################################################################################################################
\$scripts_path/simulator_master_script.sh 1
#comment the exit statement and master script will start with option 1 that means fresh checkout.

else
#This is evolution mode.
echo \"\\nWelcome to evolution mode :)\\n\";
echo \"Generating \$evolution_perl_script in current directory.\";
echo -n \"#!/usr/bin/perl
############################################################# Mutater Perl Script ########################################
#the extra string used as #~!@# is for self protection(of mutation perl script) while mutating the orginal script file.
use warnings;
\\\$option=\\\$ARGV[0];
\\\$module_type=\\\$ARGV[1];
\\\$module_name=\\\$ARGV[2];
\\\$input_file_path=\\\$ARGV[3];
\\\$adding_module_file=\\\$ARGV[4];
\\\$output_file_path=\\\$input_file_path.\\\"_evolved\\\";
\\\$num_args = \\\$#ARGV + 1;
if ( ((\\\$num_args != 5) && (\\\$option !~ /delete/)) || ((\\\$option =~ /delete/) && (\\\$num_args != 4)) ) {
	print \\\"\\\\nUsage: mutate.pl add/update/delete module_type module_name input_file_path adding_module_file\\\\nIncase of delete only 3 args\\\\n\\\";
	exit;
}

open(DATA1,\\\"<\\\$input_file_path\\\") or die \\\"Can't open script_file\\\";
@file = <DATA1>;
open(DATA2, \\\">\\\$output_file_path\\\");
if(\\\$num_args == 5)
{
	open(DATA3,\\\"<\\\$adding_module_file\\\") or die \\\"Can't open module_file\\\";
	@module_file = <DATA3>;
}

if ( (\\\$option =~ /add/) )
{
	use Switch;
	switch(\\\$module_type){
		case \\\"tj100_mc\\\"     { print \\\"Calling add function for \\\$module_type\\\\n\\\"; add(); }
		case \\\"licence\\\"      { print \\\"Calling add function for \\\$module_type\\\\n\\\"; add(); }
		else                { print \\\"Unknown module_type\\\\n\\\" }
	}
}

elsif ( (\\\$option =~ /update/) )
{
	use Switch;
	switch(\\\$module_type){
		case \\\"tj100_mc\\\"     { print \\\"Calling update function for \\\$module_type\\\\n\\\"; update(); }
		case \\\"licence\\\"      { print \\\"Calling update function for \\\$module_type\\\\n\\\"; update(); }
		else                { print \\\"Unknown module_type\\\\n\\\" }
	}
}

elsif ( (\\\$option =~ /delete/) )
{
	use Switch;
	switch(\\\$module_type){
		case \\\"tj100_mc\\\"     { print \\\"Calling delete function for \\\$module_type\\\\n\\\"; delete_module(); }
		case \\\"licence\\\"      { print \\\"Calling delete function for \\\$module_type\\\\n\\\"; delete_module(); }
		else                { print \\\"Unknown module_type\\\\n\\\" }
	}
}

else
{
	print \\\"Unknown Option.\\\\n\\\";
}

close( DATA2 );
close( DATA1 );
if(\\\$num_args == 5)
{
	close( DATA3 );
}

sub add {

COPY: foreach my \\\$line (@file) 
      { 

	      if ( (\\\$line =~ /#modify#\\\$module_type#array#end/) && (\\\$line !~ /#~!@#/) ) #~!@#
	      {
		      print DATA2 \\\"\\\\\\\"\\\$module_name\\\\\\\"\\\\n\\\";
		      print DATA2 \\\$line;
	      }

	      elsif ( (\\\$line =~ /#modify#\\\$module_type#case#end/) && (\\\$line !~ /#~!@#/) ) #~!@#
	      {
     print DATA2 \\\"\\\\
#modify#\\\$module_type#case#\\\$module_name#start
  *\\\$module_name*)
    \\\${module_type}_diff_file_name=\\\\\\\"\\\${module_type}_\\\${module_name}.diff\\\\\\\";
    ;;
#modify#\\\$module_type#case#\\\$module_name#end

\\\";
              print DATA2 \\\$line;
	      }

	      elsif ( (\\\$line =~ /#modify#\\\$module_type#file#end/) && (\\\$line !~ /#~!@#/) ) #~!@#
	      {
print DATA2 \\\"\\\\
#modify#\\\$module_type#file#\\\$module_name#start
echo -n \\\\\\\"\\\";
			foreach my \\\$module_file_line (@module_file)
			{
			\\\$module_file_line =~ s/([\\\\\\\$\\\"\\\`\\\\\\\\])/\\\\\\\\\\\$1/g;
			print DATA2 \\\$module_file_line;
			}
		print DATA2 \\\"\\\\\\\" > \\\\\\\$\\\${module_type}_diff_file_path/\\\${module_type}_\\\$module_name.diff\\\";
		print DATA2 \\\"\\\\n#modify#\\\$module_type#file#\\\$module_name#end\\\\n\\\\n\\\";    
		print DATA2 \\\$line;
	      }
	      else
	      {
			print DATA2 \\\$line;
	      }
      }

}

sub update {
	\\\$my_flag=0;
COPY: foreach my \\\$line (@file)
      {
	      if ( (\\\$line =~ /#modify#\\\$module_type#file#\\\$module_name#start/) && (\\\$line !~ /#~!@#/) ) #~!@#
	      {
		      \\\$my_flag=1;
		      print DATA2 \\\"\\\\
#modify#\\\$module_type#file#\\\$module_name#start
echo -n \\\\\\\"\\\";
		      foreach my \\\$module_file_line (@module_file)
		      {
			      \\\$module_file_line =~ s/([\\\\\\\$\\\"\\\`\\\\\\\\])/\\\\\\\\\\\$1/g;
			      print DATA2 \\\$module_file_line;
		      }
		      print DATA2 \\\"\\\\\\\" > \\\\\\\$\\\${module_type}_diff_file_path/\\\${module_type}_\\\$module_name.diff\\\";
		      print DATA2 \\\"\\\\n#modify#\\\$module_type#file#\\\$module_name#end\\\\n\\\\n\\\";
	      }
	      elsif ((\\\$line !~ /#modify#\\\$module_type#file#\\\$module_name#end/) && (\\\$my_flag == 1) && (\\\$line !~ /#~!@#/)) #~!@#
	      {
		      next;
	      }

	      elsif ((\\\$line =~ /#modify#\\\$module_type#file#\\\$module_name#end/) && (\\\$my_flag == 1) && (\\\$line !~ /#~!@#/)) #~!@#
	      {
		      \\\$my_flag=0;
		      next;
	      }

	      else
	      {
		      print DATA2 \\\$line;
	      }

      }

}


sub delete_module {
	\\\$my_flag=0;
COPY: foreach my \\\$line (@file)
      {

	      if ( (\\\$line =~ /^#modify#\\\$module_type#array#start\\\$/) && (\\\$line !~ /#~!@#/) ) #~!@#
	      {
		      \\\$my_flag=1;
		      print DATA2 \\\$line;
		      next;
	      }
	      elsif ((\\\$line !~ /^\\\\\\\"\\\$module_name\\\\\\\"\\\$/) && (\\\$my_flag == 1) && (\\\$line !~ /#~!@#/)) #~!@#
	      {
		      print DATA2 \\\$line;
	      }

	      elsif ((\\\$line =~ /^\\\\\\\"\\\$module_name\\\\\\\"\\\$/) && (\\\$my_flag == 1) && (\\\$line !~ /#~!@#/)) #~!@#
	      {
		      \\\$my_flag=2;
		      next;
	      }

	      elsif ( (\\\$line =~ /#modify#\\\$module_type#case#\\\$module_name#start/) && (\\\$line !~ /#~!@#/) ) #~!@#
	      {
		      \\\$my_flag=4;
		      next;
	      }
	      elsif ((\\\$line !~ /#modify#\\\$module_type#case#\\\$module_name#end/) && (\\\$my_flag == 4) && (\\\$line !~ /#~!@#/)) #~!@#
	      {
		      next;
	      }

	      elsif ((\\\$line =~ /#modify#\\\$module_type#case#\\\$module_name#end/) && (\\\$my_flag == 4) && (\\\$line !~ /#~!@#/)) #~!@#
	      {
		      \\\$my_flag=2;
		      next;
	      }

	      elsif ( (\\\$line =~ /#modify#\\\$module_type#file#\\\$module_name#start/) && (\\\$line !~ /#~!@#/) ) #~!@#
	      {
		      \\\$my_flag=3;
		      next;
	      }

	      elsif ((\\\$line !~ /#modify#\\\$module_type#file#\\\$module_name#end/) && (\\\$my_flag == 3) && (\\\$line !~ /#~!@#/)) #~!@#
	      {
		      next;
	      }

	      elsif ((\\\$line =~ /#modify#\\\$module_type#file#\\\$module_name#end/) && (\\\$my_flag == 3) && (\\\$line !~ /#~!@#/)) #~!@#
	      {
		      \\\$my_flag=2;
		      next;
	      }
	      else
	      {
		      print DATA2 \\\$line;
	      }

      }

}

\" > ./\$evolution_perl_script;

echo \"Generated \$evolution_perl_script\"; 

if ( [ \$number_of_parameters -ne \"4\" ] && [ \"\$evolution_option\" = \"delete\" ] ) || ( [ \$number_of_parameters -ne \"5\" ] && [ \"\$evolution_option\" != \"delete\" ] );then
echo \"Usages: \$script_to_evolve evolution add/delete/update  module_type(ex: tj100_mc)  module_name(ex: BR_10_0_2) module_file(BR_10_0_2tj100mc.diff)\";
echo \"In case of delete no need to mention module_file\";
echo \"Deleting \$evolution_perl_script\";
rm \$evolution_perl_script
exit;
fi

case \"\$evolution_option\" in
  add)
    perl ./\$evolution_perl_script \$evolution_option \$module_type \$module_name \$script_to_evolve \$module_file
    ;;
  update)
    perl ./\$evolution_perl_script \$evolution_option \$module_type \$module_name \$script_to_evolve \$module_file
    ;;
  delete)
    perl ./\$evolution_perl_script \$evolution_option \$module_type \$module_name \$script_to_evolve
    ;;
   *)
    echo \"\$evolution_option: Invalid evolution option \";
    exit 1;
esac

echo \"\$this_script evolved & resulted script is \${this_script}_evolved in current directory.\";
echo \"Evolution completed. Deleting \$evolution_perl_script\";
rm \$evolution_perl_script
exit;
fi

" > $generated_scripts_output_path/myscripts/sim.sh
echo "Generated $generated_scripts_output_path/myscripts/sim.sh "

echo -n "#!/usr/bin/env expect 
if {[llength \$argv] <= 2} {
puts \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\
\\n               Usages: node \\[Node_IP\\] \\[Card_Slot(Optional)\\]\\n\\
\\
\\n               Node_IP : 102 will be treated as 192.168.143.102\\
\\n                         241.244 will be treated as 192.168.241.244\\
\\n                         169.200.100 will be treated as 192.169.200.100\\
\\n                         172.124.143.102 will be Taken as complete IP as it is given.\\
\\
\\n               Card_Slot:Give only if want to goto that card directly. If not given you will taken to node not to card.\\
\\n                         Script will try to get icc ip automatically.Ex:For BR_10_0_2 its 127.7.1.slot but for BR_8_0_1 its 127.1.1.slot\\n
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {[llength \$argv] < 1} { exit;
}
}
 # timeout -1 means infinite
    set timeout 300
    set ip_part [lindex \$argv 0];
    set slot [lindex \$argv 1];
#    set icc_ip_second_byte [lindex \$argv 2];
    set user \"guest\";
    set user_pass \"iltwat\";
    set su_user \"root\";
    set su_user_pass \"swtn100tj\";
    set null_value \"\";
    set port \"2023\";

#flexible IP addressing
#So that u can provide 102 or 241.244 or 169.143.102 or 172.124.36.102 as IP.
    regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$ip_part all first second third fourth
if { \$fourth != \$null_value } {
   set ip \"\$all\"
} elseif { \$third != \$null_value } {
   set ip \"192\\.\$first\\.\$second\\.\$third\"
} elseif { \$second != \$null_value } {
   set ip \"192\\.168\\.\$first\\.\$second\"
} elseif { \$first != \$null_value } {
   set ip \"192\\.168\\.143\\.\$first\"
} else { puts \"Invalid IP\"; exit; }
puts \"\\n\\nNODE IP is \$ip \\n\"

if {[llength \$argv] == 1} {
        spawn telnet \$ip \$port
        set node_spawn_id \$spawn_id
        expect \"*login*\"
        send \"\$user\\r\"
        expect \"*assword*\"
        send \"\$user_pass\\r\"
        expect \"*>\"
        send \"su\\r\"
        expect \"*assword*\"
        send \"\$su_user_pass\\r\"
        expect \"*#\"
        send \"cat /usr/sbin/name/version.h\\r\"
        expect \"*#\"
        send \"cd \\/etc\\/name\\/log\\r\"
        expect \"*#\"
		send \"tail \\-f /etc/name/log/*log00*\\r\"
		expect \"*\"
interact
        #stty raw -echo
        #expect_after {
        #        -i \$user_spawn_id
        #        \"y\" {send \"rm -fr SysConf.* backconf.*\\rcp defaultCfg\\/* .\\r\"; exp_continue}
        #        \"n\" {send \"\\r\\r\"; exp_continue}
        #}
        #expect \"> \"
        #send \"ls /usr/sbin/name | grep 'initialize.sh'
}

if {[llength \$argv] == 2} {
spawn telnet \$ip \$port
#       spawn telnet 10.51.182.\$node_ip 2023
       set node_spawn_id_2 \$spawn_id
       expect \"*login*\"
       send \"\$user\\r\"
       expect \"*assword*\"
       send \"\$user_pass\\r\"
       expect \"*>\"
       send \"su\\r\"
       expect \"*assword*\"
       send \"\$su_user_pass\\r\"
       expect \"*#\"
send -i \$node_spawn_id_2 \"\\
total_icc=\`route|grep icc|wc -l\`;echo \\\$total_icc;\\r\\
basic_icc=\`route|grep icc|grep 127.\\[0-1\\]|wc -l\`;echo \\\$basic_icc;\\r\\
special_icc=\\\$(( \\\$total_icc - \\\$basic_icc ))\\r\\
if \\[ \\\"\\\$special_icc\\\" == \\\"0\\\" \\]; then\\r\\
route|grep icc|grep 127\\.1\\r\\
else\\r\\
route|grep icc|grep 127\\.\\[2-9\\]\\r\\
fi\\r\\
\\r\"
       expect {
               -re {127\\.(\\S+)\\.1\\.[0-9]} {
               				 set icc_ip_string \$expect_out(1,string)
             				 regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$icc_ip_string icc_ip_second_byte
               			      }
              } 
#       send \"cd \\/tmp\\r\"
#       expect \"# \"
#       send \"rm *.hex\\r\"
#       expect \"# \"
#	send \"ncftpget -uhexftp -piltwat 192.168.0.14 /tmp /home/hexftp/hex/mc/plc02/elk/fpga_edited/\$wld\\r\"
#	expect \"# \"
       send \"telnet 127.\$icc_ip_second_byte.1.\$slot \$port\\r\"
       expect \"*login*\"
       send \"\$user\\r\"
       expect \"*assword*\"
       send \"\$user_pass\\r\"
       send \"su\\r\"
       expect \"*assword*\"
       send \"\$su_user_pass\\r\"
       expect \"*#\"
       send \"cd \\/etc\\/name\\/log\\r\"
       expect \"# \"
       send \"export LD_LIBRARY_PATH=/usr/sbin/name/sharedobj\\r\"
#send \"cd \\/tmp\\r\"
#        expect \"# \"
#        send \"ncftpget -uguest -piltwat 127.1.1.254 . /tmp/\$wld\\r\"
#        expect \"# \"
#        send \"mv \$wld elk.hex\\r\"
#        expect \"# \"

 send \"tail \\-f *log00*\\r\"
     expect \"# \"
        interact
}
" > $generated_scripts_output_path/myscripts/node
echo "Generated $generated_scripts_output_path/myscripts/node "

echo -n "#!/bin/bash
#Crash Analysis Master Script. Controls all other scripts.
number_of_parameters=\$#;
if [ \$number_of_parameters -lt \"1\" ];then
echo \"Usages: \$0 IP_PART\"
exit;
fi
####################################### FUNCTIONS ############################################
function fip143 () { #internal fxn taken  from bashrc
    if [[ \$1 = *.*.*.* ]] ; then
        echo \$1
    elif [[ \$1 = *.*.* ]] ; then
        echo 192.\$1
    elif [[ \$1 = *.* ]] ; then
        echo 192.168.\$1
    elif [[ \$1 -lt 255 ]] ; then
        echo 192.168.143.\$1
    fi
}

function get_daemon_map () {
input_daemon_name=\$1
input_daemon_name=\${input_daemon_name%.d.map*}
input_daemon_map=\"\${input_daemon_name}.d.map\"
input_daemon_map=\${input_daemon_map,,}
match_in_this_dir=\$2
if pushd \$match_in_this_dir >/dev/null;then
   daemons=(\$(ls -1 *.d.map))
   use_path=\$(pwd)
   popd >/dev/null
fi
for dmn in \${daemons[@]}
do
    temp=\${dmn##*\\/}
    temp=\${temp,,}
    if [[ \"\$temp\" == \"\$input_daemon_map\" ]];then
       echo \"\$use_path/\$dmn\"
       return 0
    fi
done
return 1
}
##############################################################################################
############################ ARG HANDLING AND DEF SECTION ####################################
reip='^[0-9\\.]+\$'
retgz='.*-maps.tgz\$'
max_ping_retry=10
control_card_image_path=\"/etc/bin/name/\"
intelligent_card_imag_path=\"/etc/name/builds/\"
release_server_ip=\"192.168.0.14\"
release_server_username=\"swtn100\"
release_server_password=\"tn100sw\"

if  [[ \$1 =~ \$reip ]] ; then
    ip_part=\$1;
    full_ip=\$(fip143 \$ip_part)
    results_path=\$2
    log_maps_downloader_script_path=\$3
    crash_analyzer_perl_script_path=\$4
    universal_local_md5_file=\$5
    universal_release_md5_file=\$6
elif [[ \$1 =~  'rel' ]] ; then
    release_branch=\$2;
    release_tag=\$3;
    crash_logs_path=\$4;
    if [ \$number_of_parameters -lt \"4\" ];then
       echo \"rel RELEASE_BRANCH BRANCH_TAG CRASH_LOG_PATH all are not passed\"
       exit 1
    fi    
    results_path=\$5
    log_maps_downloader_script_path=\$6
    crash_analyzer_perl_script_path=\$7
    universal_local_md5_file=\$8
    universal_release_md5_file=\$9
elif [[ \$1 =~  \$retgz ]] ; then
    maps_tgz_file_path=\$1;
    crash_logs_path=\$2;
    if [ \$number_of_parameters -lt \"2\" ];then
       echo \"MAPS_TGZ_FILE_PATH  CRASH_LOG_PATH all are not passed\"
       exit 1
    fi
    results_path=\$3
    log_maps_downloader_script_path=\$4
    crash_analyzer_perl_script_path=\$5
    universal_local_md5_file=\$6
    universal_release_md5_file=\$7
else
    echo \"Not able to understand what args you are passing.\"
    exit 1
fi
########################################################################################################
###################################### ROLL BACK TO THESE IF NULL ######################################
##these extra agrs are being used so that we can have flexiblity from bashrc while calling this script.
##below is the default setting block. if above args are not passed.
if [[ \"\$results_path\" == \"\" ]];then
	 results_path=~/crash_analysis
fi

if [[ \"\$log_maps_downloader_script_path\" == \"\" ]];then
	 log_maps_downloader_script_path=~/myscripts/ca_maps_logs_downloader
fi

if [[ \"\$crash_analyzer_perl_script_path\" == \"\" ]];then
	 crash_analyzer_perl_script_path=~/myscripts/unbound_stacktracer.pl
fi

if [[ \"\$universal_local_md5_file\" == \"\" ]];then
	 universal_local_md5_file=~/.universal_local_md5_list
fi

if [[ \"\$universal_release_md5_file\" == \"\" ]];then
	 universal_release_md5_file=~/.universal_release_md5_list
fi
##########################################################################################################
##################################### AVOID DISASTER. CHECK BEFORE TAKEOFF ###############################
if ! [ -e \$results_path ];then
      mkdir -p \$results_path
fi

if ! [ -e \$log_maps_downloader_script_path ];then
   echo \"log_maps_downloader_script_path is needed for script to work properly.Please check if you have passed wrongly or edit hardcoded section of script.\"
   exit 1;
fi

if ! [ -e \$crash_analyzer_perl_script_path ];then
   echo \"crash_analyzer_perl_script_path is needed for script to work properly.Please check if you have passed wrongly or edit hardcoded section of script.\"
   exit 1;
fi

if ! [ -e \$universal_local_md5_file ];then
   echo \"universal_local_md5_file is needed for script to work properly.Please check if you have passed wrongly or edit hardcoded section of script.\"
   exit 1;
fi

if ! [ -e \$universal_release_md5_file ];then
      echo \"universal_release_md5_file is needed for script to work properly.Please check if you have passed wrongly or edit hardcoded section of script.\"
      exit 1;
fi
############################################################################################################
###################################### HELPER SCRIPTS OUTPUT PARAMETERS ####################################
base_path_per_node=\$results_path/node_\$ip_part
download_maps_logs_here=\$base_path_per_node/from_node
img_md5info_file_path=\$download_maps_logs_here/img_md5info
download_extract_maps_tgz_here=\$base_path_per_node
tgz_maps_path=\$download_extract_maps_tgz_here/maps
split_logs_in_this=\$base_path_per_node/split/
combined_info=\$base_path_per_node/all_info
backup_to_this=\$base_path_per_node/backup
analysis_result_ext=\"analysis\"
if [ -e \$split_logs_in_this ];then
   mkdir -p \$backup_to_this
   echo \"Found Existing crash analysis in \$split_logs_in_this\"
   echo \"Backing Up to \$backup_to_this\"
   all_analysis=(\$(find \$split_logs_in_this -name \"*.\$analysis_result_ext\"))
   if [ \${#all_analysis[@]} -ne 0 ];then
      for analysis_result in \${all_analysis[@]}
      do
         echo \"Copying \$analysis_result\"
         cp \$analysis_result \$backup_to_this/
      done
      all_analysis=()
   else 
      echo \"Seems That last Crash analysis didn't went well because there are no previous .\$analysis_result_ext files\"
   fi
fi

echo \"Creating \$split_logs_in_this \$download_maps_logs_here\"
mkdir -p \$download_maps_logs_here \$split_logs_in_this \$tgz_maps_path
############################################################################################################
############################################# Make Sure Node is UP #########################################
if [[ \"\$full_ip\" != \"\" ]];then
     count=\$max_ping_retry;
     is_node_up=0;
     while [[ \$count -ne 0 ]] ; do
         ping -c 1 \$full_ip >/dev/null                     # Try with one packet.
         rc=\$?
         if [[ \$rc -eq 0 ]] ; then
             ((count = 1))                      # If okay, flag to exit loop.
             is_node_up=1;
         else
            echo \"Node still unreachable.\"
         fi
         ((count = count - 1))                  # So we don't go forever.
     done
     if [[ \"\$is_node_up\" == \"1\" ]];then
          echo \"Node is UP. Now going Further.\"
     else
          echo \"Finally Node is unreachable. Re run. Exiting...\"
          exit 1;
     fi
fi
############################################################################################################
############################################ LETS DO THIS !!!!!! ###########################################
                                       ######## Downloading #######
echo \"Downloading crash info of node \$full_ip to \$download_maps_logs_here\"
echo \"Calling \$log_maps_downloader_script_path\"
\$log_maps_downloader_script_path \$full_ip \$download_maps_logs_here
status_code=\$?
if [[ \$status_code -eq 2 ]];then
   echo \"Downloader script retured status code 2 which means that this node \$full_ip had no crash till now. Exiting...\"
   exit 1
elif [[ \$status_code -ne 0 ]];then
   echo \"Downloader script retured status code \$status_code. Exiting...\"
   exit 1
else
   echo \"Downloaded the stuff from node \$full_ip to \$download_maps_logs_here\"
fi
                        ######### Read img_md5 data & get corresponding maps ########
echo \"Extracting control card md5 from \$img_md5info_file_path\"
control_card_current_image_md5=\$(cat \$img_md5info_file_path | grep \"\$control_card_image_path\" | awk '{print \$1}')
if [[ \${control_card_current_image_md5} == \"\" ]];then
   echo \"It seems that \$img_md5info_file_path is blank or not proper. May be your log_maps_downloader should wait extra 1-2 seconds until md5info is generated.\"
   echo \"Just put some sleep in downloader script. so that it wait for creation of md5info. Its not final reason. Just Guessing :) Exiting...\"
   exit;
fi
echo \"control_card_current_image_md5 is \$control_card_current_image_md5\"
echo \"Searching in \$universal_local_md5_file\"
image_local_path=\$(grep \"\$control_card_current_image_md5\" \$universal_local_md5_file | awk '{print \$2}')
image_release_server_path=\$(grep \"\$control_card_current_image_md5\" \$universal_release_md5_file | awk '{print \$2}')
if [[ \"\$image_local_path\" != \"\" ]];then
     echo \"The image being used in the node is \$image_local_path\"
     local_map_tgz_file=\${image_local_path/.squash.img/-maps.tgz}
     if [ -e \$local_map_tgz_file ];then
        echo \"Extracting \$local_map_tgz_file in \$tgz_maps_path\"
        tar -xzvf \$local_map_tgz_file -C \$tgz_maps_path
     else
        echo \"Not able to locate \$local_map_tgz_file. on local machine. Exiting...\"
        exit 1;
     fi
elif [[ \"\$image_release_server_path\" != \"\" ]];then
     echo \"Node is using release build. Path of which is: \$image_release_server_path\"
     release_server_map_tgz_file=\${image_release_server_path/.squash.img/-maps.tgz}
     release_server_map_tgz_file_name=\${release_server_map_tgz_file##*\\/}
     echo \"Downloading corresponding map \$release_server_map_tgz_file to \$download_extract_maps_tgz_here\"
     ncftpget -u\$release_server_username -p\$release_server_password \$release_server_ip \$download_extract_maps_tgz_here \$release_server_map_tgz_file;
     status_code=\$?
     if [[ \$status_code -ne 0 ]];then
         echo \"Unable to download the file \$release_server_map_tgz_file. Exiting...\"
         exit 1;
     fi
     if ! [ -e \$download_extract_maps_tgz_here/\$release_server_map_tgz_file_name ];then
          echo \"Downloaded file doesn't exits, or some problem with name stripping.\"
          echo \"Unable to locate \$download_extract_maps_tgz_here/\$release_server_map_tgz_file_name. Exiting...\"
          exit 1;
     fi
     echo \"Now extracting the \$download_extract_maps_tgz_here/\$release_server_map_tgz_file_name file to \$tgz_maps_path\"
     tar -xzvf \$download_extract_maps_tgz_here/\$release_server_map_tgz_file_name -C \$tgz_maps_path
     echo \"Extraction completed maps dir is \$tgz_maps_path\"
else
     echo \"MD5 Value \$control_card_current_image_md5 corresponds to neither a release build nor your pc private builds.\"
     echo \"It might be possible that either you haven't updated your local & release builds md5 database. OR This is someone else 's private build.\"
     echo \"Please get the maps.tgz & then try with different way using the script.(Local method). Exiting...\"
     exit 1;
fi
echo \"\"
echo \"\"
echo \"HURRRRRRRAY!!! WE HAVE GOT THE MAPS FOLDER. :)\"
echo \"\"
                                        ######## Splitting #######
echo \"Splitting \$download_maps_logs_here according to daemons in \$split_logs_in_this\"
rm -rf \$split_logs_in_this/*
SAVEIFS=\$IFS;
grep -nriI \"stackdump\" \$download_maps_logs_here |
while read -r line ; do
  IFS=\":\";
  set -- \$line;
  filename=\$1; line_no=\$2;
  mix=\$3;mix=\${mix//\\// };minutes=\$4;seconds=\$5;
  tmp_line=\${line//:/ }
  IFS=\" \";
  set -- \$tmp_line
  task_name=\$8   #don't know why its not working with \$6. it should be \$6 but it seems / is also taken as field separator here.
  set -- \$mix
  day=\$1;month=\$2;year=\$3;hours=\$4
  let year=year+2000
  final_date=\"\$year/\$month/\$day \$hours:\$minutes:\$seconds\"
  window=30;
  daemon=\${filename##*\\/}; daemon=\${daemon#*init}; daemon=\${daemon%%dlog*};
  epoch_time=\$(date --date=\"\$final_date\" '+%s');
  echo \"\$epoch_time \$filename \$line_no \$daemon \$task_name\";
done | sort -k1 -r > \$combined_info
IFS=\" \";
cat \$combined_info| while read info ; do
   set -- \$info;
   epoch_time=\$1
   filename=\$2
   line_no=\$3
   daemon=\$4
   task_name=\$5
   echo \$info
   log_count=\$(ls -1 \$split_logs_in_this/\$daemon/*\${daemon}* 2>/dev/null|wc -l)
   if [ \$log_count -eq 0 ];then
      mkdir -p \$split_logs_in_this/\$daemon/
      crash_no=\$log_count
   else
      crash_no=\$log_count
   fi
   tail -n +\$line_no \$filename | head -\${window} > \$split_logs_in_this/\$daemon/\${crash_no}_\${daemon}_\${task_name}_\${epoch_time}
done
IFS=\$SAVEIFS;
echo \"\"
echo \"AWWWWWWWWWWWESSSSSSSSSSSOMMMMMMMMMMMMMME. DONE SPLITTING.\"
echo \"\"
echo \"Splitted logs.\"
                                 ######Go for processing logs #######
echo \"Now Going for processing of these logs\"
for daemon in \$(ls -1 \$split_logs_in_this)
do
if pushd \$split_logs_in_this/\$daemon;then
   echo \"Doing Crash Analysis for daemon \$daemon\"
   for crash_file in \$(ls -1rt 2>/dev/null)
   do
      echo \"Crash Analysis for file \$crash_file\"
      task_name=\$(echo \"\$crash_file\" | awk 'BEGIN{FS=\"_\"} {print \$3}')
      use_this_linker_map=\$(get_daemon_map \$daemon \$tgz_maps_path)
      splitted_file_full_path=\$(readlink -e \$crash_file)
      daemon_lower=\${daemon,,}
      if ! [ -e \$use_this_linker_map ];then
           echo \"Got this as linker map \$use_this_linker_map. Which doesn't exist.\"
           echo \"check your maps folder for proper map file.\"
           exit
      fi
      echo \"Debug Info\"
      echo \"perl \$crash_analyzer_perl_script_path TARGET \$splitted_file_full_path \$task_name \$download_maps_logs_here/\${daemon_lower}.maps \$use_this_linker_map \${splitted_file_full_path}.\$analysis_result_ext\"

      perl \$crash_analyzer_perl_script_path TARGET \$splitted_file_full_path \$task_name \$download_maps_logs_here/\${daemon_lower}.maps \$use_this_linker_map \${splitted_file_full_path}.\$analysis_result_ext
   done
popd >/dev/null
fi
done

while [ 1 ]
do
all_analysis=(\$(find \$split_logs_in_this -name \"*.\$analysis_result_ext\" -printf '%T@ %p\\n' | sort -k 1n | sed 's/^[^ ]* //'))
total_results=\${#all_analysis[@]}
if [ \$total_results -eq 0 ];then
   echo \"Seems that there was no crash that is successfully Analyzed. :( \"
   echo \"Exiting...\"
fi 
echo \"Found \$total_results crashes analyzed :) Which one to see?\"
for((index=0;index<\$total_results;index++))
do
    tmp=\${all_analysis[\$index]}
    tmp=\${tmp##*\\/}
    display=\$tmp
    SAVEIFS=\$IFS
    IFS=\"_\"
    set -- \$tmp
    tmp=\$4
    IFS=\$SAVEIFS
    tmp=\${tmp%.\$analysis_result_ext}
    time_stamp=\$(date -d @\$tmp +'%Y-%m-%d %H:%M:%S')    
    echo \"\$index   \$time_stamp   \$display\"
done
echo \"Please Enter index no. That would be selected to navigate.(TO QUIT ENTER q )\"
read choice
while (( choice < 0 || choice >= total_results ))
do
    echo \"Invalid index. Enter again.\"
    read choice
    if [[ \"\$choice\" == \"q\" ]];then
        break;
    fi
done
if [[ \"\$choice\" == \"q\" ]];then
    echo \"quitting...\"
    break;
else
    c++filt < \${all_analysis[\$choice]}
fi
done
" > $generated_scripts_output_path/myscripts/ca.sh
echo "Generated $generated_scripts_output_path/myscripts/ca.sh "

echo -n "#!/usr/bin/perl  
use File::Basename;
my \$TOTAL_ARGS = \$#ARGV + 1;
if (\$TOTAL_ARGS < 6)
{
print \"USAGE:\$0 <ENV:TARGET/HOST> <Log File Path> <Task Name(NM/UNKNOWN etc.)> <Process Map File Path> <Daemon map .d.map full path> <Result File Path with File Name>\\n\";
exit;
}
\$ENVIRONMENT=shift;
my \$LOG_FILE_PATH = shift;
my(\$LOG_FILE_NAME, \$LOG_FILE_DIR, \$LOG_FILE_EXT) = fileparse(\$LOG_FILE_PATH);
my \$TASK_NAME=shift;
my \$PROCESS_MAP_PATH = shift;
my(\$PROCESS_MAP_FILE_NAME, \$PROCESS_MAP_FILE_DIR, \$PROCESS_MAP_FILE_EXT) = fileparse(\$PROCESS_MAP_PATH);
my \$DAEMON_LINKER_MAP_PATH = shift;
my(\$DAEMON_NAME,\$LINKER_MAPS_DIR, \$DAEMON_TMP) = fileparse(\$DAEMON_LINKER_MAP_PATH, qr/\\..*/);
\$LINKER_MAPS_DIR =~ s/\\/\$//g;
my \$RESULTS_PATH = shift;
my(\$RESULT_FILE_NAME, \$RESULT_FILE_DIR, \$RESULT_FILE_EXT) = fileparse(\$RESULTS_PATH);
my \$DAEMON_LINKER_MAP_PATH = \$LINKER_MAPS_DIR.\"/\".\$DAEMON_NAME.\".d.map\";

if(\$ENVIRONMENT !~ /TARGET|HOST/i){
	print \"ENV: TARGET or HOST \\n\";
	exit;
}

if(!(-e \$LOG_FILE_PATH)){
	print \"LOG_FILE_PATH not found.Hence Exiting\\n\";
	exit;
}

if(!(-e \$RESULT_FILE_DIR)){
    print \"RESULT_FILE_DIR, not found.Hence Making it.\\n\";
    system(\"mkdir -p \$RESULT_FILE_DIR\");
}

if(!(-e \$PROCESS_MAP_PATH)){
    print \"PROCESS_MAP_PATH not found.Hence Exiting\\n\";
    exit;
}

if(!(-d \$LINKER_MAPS_DIR)){
    print \"LINKER_MAPS_DIR dir doesn't exist.Hence Exiting\\n\";
    exit;
}

if(! defined \$TASK_NAME) {
    print \"TASK_NAME not passed in args.\";
    exit;
}

if(! defined \$DAEMON_NAME) {
    print \"DAEMON_NAME not passed in args.\";
    exit;
}

if(-e \$RESULTS_PATH){
	system(\"rm \$RESULTS_PATH\\n\");
}

# if ( \$daemon =~ m/^init/) {
#     \$daemon =~ s/init//g;
# }

# Since the name of the daemon might involve upper case characters , the .d.maps file will also have upper case characters.
# Lets not change the name of the daemon file but we can change the name of the log file
# Also we can change the name of the .maps file without too much trouble
# So we can modify the name of the log file to the same as that of the daemon .d file
# FIXME : Will this work for init files as well ? 
%hash = getStackInfo(\$LOG_FILE_PATH);
print_hash(%hash);
my %daemon_map_hash = get_address_hash(\"\$DAEMON_LINKER_MAP_PATH\");  # processed only once

process(%hash);

print \"Please look at \$RESULTS_PATH for results \\n\";
print \"Happy Debugging\\n\";


#-------------------------------------------------#
#     Routine to get the Statck Info              #
#   Gets the pid and associated addresses         #
#-------------------------------------------------#

sub getStackInfo {
	my \$file = shift;
	open(FH,\"< \$file\");
	my %hash = ();

	while(my \$line = <FH>){
		if(\$line =~ /^(.*): \$TASK_NAME (.*): StackDump : (.*)/i){
			\$date = \$1;
			\$pid = \$3;
			\$hash{\"\$pid\"} = ();
			print \"Found a Stack dump :-) at date \$date for  pid \$pid \\n\";
			while((\$line = <FH>) && (\$line !~ /\$TASK_NAME started with pid/)){
				if(\$line =~ /\$TASK_NAME :(.*): (\\d+) (\\w+)/){
					push @{array_.\$pid}, \$3;
								
				}
			}
			\$hash{\"\$pid\"} = \\@{array_.\$pid};
			\$time{\"\$pid\"} = \$date;
		}	
	} 
	close(FH);
	if(keys %hash){
		return(%hash);
	}else{
		print \"No StackDump found in \$file \\n\";
		exit;
	}
}

#---------------------------------#
#   Routine to print hash         #
#---------------------------------#
sub print_hash {
	my(%hash) = @_;
	open(FH,\">>\$RESULTS_PATH\");
	foreach \$key (keys %hash){
		print FH \"-------------------------------\\n\";
		print FH \"THE PID = \$key \\n\";
		print FH \"THE TIME OF CRASH : \$time{\$key}\\n\";		
		print FH \"-------------------------------\\n\";
		print FH \"The crash address are : \\n\";
		\$array = \$hash{\$key};
		\$i = 0;
		while(\$array->[\$i]){
			print FH \" \$array->[\$i] \\n\";
			\$i++;
		}
	}
	close(FH);
	
}

#---------------------------------#
#   Routine to process hash       #
#---------------------------------#

sub process {
	my(%hash) = @_;	
	foreach my \$key (keys %hash){

	open(PID,\">>\$RESULTS_PATH\");
#### Have one format here .. to print pid of daemon
format PID =



============================================================================================
  \$TASK_NAME D CRASH : @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            \$time{\$key}
=============================================================================================
. 
#\$~ = \"PID\";
write(PID) ;
	close(PID);

		my \$array = \$hash{\$key};
		my \$i = 0;
		while(\$array->[\$i]){
#			print \"IN process \$key values are \$array->[\$i] \\n\";
			my \$lookup_file =  findFileToProcess(\$array->[\$i],\$key);
			if(\$lookup_file =~ /\$DAEMON_LINKER_MAP_PATH/){
				processmap(\$array->[\$i]);
			}else{
				processpidfile(\$array->[\$i],\$PROCESS_MAP_PATH);
			}	
			\$i++;
		}
	}
}

#----------------------------------------------------------------#
#   Returns the file which has be looked into for processing     #
#----------------------------------------------------------------#

sub findFileToProcess {
	my(\$address) = @_;
	my \$hex_address = hex(\$address);

	if(\$ENVIRONMENT eq \"TARGET\"){ 
		\$bin_boundry = 0x10000000;
		if(\$hex_address > \$bin_boundry){
#			print \"*** \$address should be looked in \$daemon.d.map file \\n\";
			return(\$DAEMON_LINKER_MAP_PATH);
		}else{
#			print \"*** \$address should be looked in *.so.map file \\n\";
			return(\$PROCESS_MAP_PATH);
		}
	}else{
		\$bin_boundry = 0x40000000;

		if(\$hex_address > \$bin_boundry){
#			print \"*** \$address should be looked in *.so.map file \\n\";
			return(\$DAEMON_LINKER_MAP_PATH);
		}else{
#			print \"*** \$address should be looked in \$daemon.d.map file \\n\";
			return(\$PROCESS_MAP_PATH);
		}

	}

}

#----------------------------------------------------------------#
#   Returns the function for the specified address               #
#----------------------------------------------------------------#

sub findFunction{
	my(\$address, \$lookup_file,\$pid) = @_;
	if(\$lookup_file =~ /\$DAEMON_LINKER_MAP_PATH/){
		return(processmap(\$address));
	}else{
		return(processpidfile(\$address,\$PROCESS_MAP_PATH.\$pid));
	}
}

#------------------------------------------------#
#  Gets the address hash from the file           #
#------------------------------------------------#
sub get_address_hash {
	my(\$file) = @_;
	my %address_hash = ();
	if(open(FH , \"<\$file\")){
	}else{
		print \"\$file could not be opened \\n\" ;
		return;
	}
	while(my \$line = <FH>){
		if(\$line =~ /(.*)(0x(\\w+))(\\s+) (.*)\$/){
			\$address_hash{\$2} = \$5; 
		}
	}
	close(FH);
	return %address_hash;
}

#---------------------------------------------#
#   finds the the errorneous function         #
#---------------------------------------------#
sub getFunctionName {
	my(\$address,%address_hash) = @_;
	my @address_array = ();
	@address_array = sort by_hex keys(%address_hash);
#	print \"After sorting\\n\";
	for(my \$i=0;\$i<\$#address_array;\$i++){
		if(hex(\$address_array[\$i]) > hex(\$address)){
#			print \"HIGHER ADDRESS = \$address_array[\$i]\\n\";
#			print \"LOWER ADDRESS = \$address_array[\$i-1]\\n\";
#			print \"The Culprit ----- \$address_hash{\$address_array[\$i-1]}\\n\";
            my \$offset = hex(\$address) - hex(\$address_array[\$i-1]);
			return \$address_hash{\$address_array[\$i-1]}.\" + \$offset instruction opcodes\";
			#last;
		}
	}
}

#------------------------------------------------#
#   finds the the function in map file           #
#------------------------------------------------#

sub processmap {
	my(\$address) = @_;
	my \$file = \$DAEMON_NAME.\".d.map\";
	open(FUNCTION,\">>\$RESULTS_PATH\");
	my \$err_func = getFunctionName(\$address,%daemon_map_hash);
	if(!\$err_func){
		\$err_func = \"Not found\";
	}

#have one format here ... To print address and function name
format FUNCTION =
@<<<<<<<<<|^<<<<<<<<<<<<<<<<<<<< |^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\$address      \$file                \$err_func
~~        		                 |^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	                              \$err_func	
-------------------------------------------------------------------------------------------------------
. 
write(FUNCTION) ;
	
	close(FUNCTION);

#	print \"Errored function for \$address is \$err_func \\n\";
	return;
}

#---------------------------------------------------#
#   finds the the function through in pidfile file   #
#---------------------------------------------------#

sub processpidfile {
	my(\$address,\$file) = @_;
	my @address_array = ();
	my %address_hash = ();
	my \$so_name = \"\";
	my \$offset = \"\";
	open(DAEMON_MAP , \"<\$file\");
	my \$so_file = \"\";
	my \$prev_so_file = \"\";
	my \$old_base_add = \"\";
	while(my \$line = <DAEMON_MAP>){
		my(\$address_range,\$temp1,\$temp2,\$time,\$temp3,\$so_file) = split(\" \",\$line);
		my(\$new_base_add,\$new_last_add) = split(\"-\",\$address_range); 	
		if(\$so_file eq \$prev_so_file){	
			\$new_base_add = \$old_base_add;
		}else{
			\$old_base_add = \$new_base_add;
			\$prev_so_file = \$so_file;
		}
		\$address_range = \"\$new_base_add-\$new_last_add\";
		\$address_hash{\$so_file} = \$address_range;
	}
	close(DAEMON_MAP);
	foreach my \$key (keys %address_hash){
		my(\$base_add,\$last_add) = split(\"-\",\$address_hash{\$key});
		if((hex(\$base_add) <= hex(\$address)) && (hex(\$last_add) >= hex(\$address))){
#			print \"Found the bad .so -- it is \$address_hash{\$key} \\n\";
			\$key =~ /(.*)sharedobj\\/(.*)/;
			\$so_name = \$2;
#			print \"The name of the so is \$so_name\\n\"; 
			\$offset = hex(\$address) - hex(\$base_add);
			\$offset = sprintf \"%lx\",\$offset;
#			print \"Offset in the .so file is \".\$offset.\" \\n\";
			last;
		}
	}
	findSoFunction(\$address,\$so_name,\$offset);
	return;
}

#---------------------------------------#
#   Finds the function in the .so file  #
#---------------------------------------#
sub findSoFunction {
	my(\$address,\$file,\$offset) = @_;
	my %address_hash = ();
	my \$err_function = \"\";
	if(\$file){
		\$file =~ /lib(.*).so/;
		my \$so_file = \$1.\".lo.so.map\";
		if(!(-e \"\$LINKER_MAPS_DIR/\$so_file\")){
#			print \"\$so_file is not present in the \$mapPath\\n\";
		 	\$err_function = \"\$so_file is not present in the \$LINKER_MAPS_DIR\";
		}else{
			%address_hash = get_address_hash(\"\$LINKER_MAPS_DIR/\$so_file\");
			\$err_function = getFunctionName(\$offset,%address_hash);
		 	if(!\$err_function){
#				print \"Function for \$offset not found\\n\";
				\$err_function = \"Function for \$offset not found\";
			}else{
#				print \"Errored function for \$offset is \$err_function \\n\";
			}
		}
	}else{
		\$err_function = \"Corresponding .so for \$address not found in \$PROCESS_MAP_FILE_NAME\";	
	}

### Have one format here .. to print address , so-name and err_func
format SO_FUNCTION =
@<<<<<<<<<|^<<<<<<<<<<<<<<<<<<<< |^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\$address      \$file                  \$err_function
~~                  			 |^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	    				  \$err_function
---------------------------------------------------------------------------------------------------------
. 
write(SO_FUNCTION) ;
	
	close(SO_FUNCTION);


}

#---------------------------------#
#   Sorts the array on hex value  #
#---------------------------------#

sub by_hex {
	return( hex(\$a) <=> hex(\$b) );
}

" > $generated_scripts_output_path/myscripts/unbound_stacktracer.pl
echo "Generated $generated_scripts_output_path/myscripts/unbound_stacktracer.pl "

echo -n "#!/usr/bin/env expect 
##########################################################Generic Auto FTP (gaf)###########################################################
if {[llength \$argv] < 3} {
puts \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\
\\n               Usages: gat \\[IP_or_IP_part\\]   Username      Password     Super_User_Password\\(Optional\\)\\n 
\\
\\n               Node_IP : 102 will be treated as 192.168.230.102\\
\\n                         241.244 will be treated as 192.168.241.244\\
\\n                         169.200.100 will be treated as 192.169.200.100\\
\\n                         172.124.143.102 will be Taken as complete IP as it is given.\\n
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {[llength \$argv] < 3} { exit;
}
}
 # timeout -1 means infinite
    set timeout 300
    set ip_part [lindex \$argv 0];
    set user [lindex \$argv 1];
    set user_pass [lindex \$argv 2];
    set su_user_pass [lindex \$argv 3];
    set null_value \"\";

#flexible IP addressing
#So that u can provide 102 or 241.244 or 169.143.102 or 172.124.36.102 as IP.
    regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$ip_part all first second third fourth
if { \$fourth != \$null_value } {
   set ip \"\$all\"
} elseif { \$third != \$null_value } {
   set ip \"192\\.\$first\\.\$second\\.\$third\"
} elseif { \$second != \$null_value } {
   set ip \"192\\.168\\.\$first\\.\$second\"
} elseif { \$first != \$null_value } {
   set ip \"192\\.168\\.230\\.\$first\"
} else { puts \"Invalid IP\"; exit; }
puts \"\\nEntity IP is \$ip \\n\"

        spawn ftp \$ip
        set node_spawn_id \$spawn_id
        expect \"*:\"
        send \"\$user\\r\"
        expect \"*asswor*\"
        send \"\$user_pass\\r\"
		interact

" > $generated_scripts_output_path/myscripts/gaf
echo "Generated $generated_scripts_output_path/myscripts/gaf "

echo -n "#!/usr/bin/env expect 
##########################################################Generic Auto SSH (gas)###########################################################
if {[llength \$argv] < 3} {
puts \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\
\\n               Usages: gat \\[IP_or_IP_part\\]   Username      Password\\n 
\\
\\n               Node_IP : 102 will be treated as 192.168.230.102\\
\\n                         241.244 will be treated as 192.168.241.244\\
\\n                         169.200.100 will be treated as 192.169.200.100\\
\\n                         172.124.143.102 will be Taken as complete IP as it is given.\\n
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {[llength \$argv] < 3} { exit;
}
}
 # timeout -1 means infinite
    set timeout 300
    set ip_part [lindex \$argv 0];
    set user [lindex \$argv 1];
    set user_pass [lindex \$argv 2];
    set su_user_pass [lindex \$argv 3];
    set null_value \"\";

#flexible IP addressing
#So that u can provide 102 or 241.244 or 169.143.102 or 172.124.36.102 as IP.
    regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$ip_part all first second third fourth
if { \$fourth != \$null_value } {
   set ip \"\$all\"
} elseif { \$third != \$null_value } {
   set ip \"192\\.\$first\\.\$second\\.\$third\"
} elseif { \$second != \$null_value } {
   set ip \"192\\.168\\.\$first\\.\$second\"
} elseif { \$first != \$null_value } {
   set ip \"192\\.168\\.230\\.\$first\"
} else { puts \"Invalid IP\"; exit; }
puts \"\\nEntity IP is \$ip \\n\"
spawn ssh \$user@\$ip -X
set node_spawn_id \$spawn_id
expect {
	    \"*yes/no*\" {
			        send \"yes\\r\"
			        exp_continue
				    }

	    \"*asswor*\" {
			        send \"\$user_pass\\r\"
				    }
}
if {[llength \$argv] == 4} {
expect \"*\$*\"
puts \"Going for Super User Login\"
send \"su\\r\"
expect \"*asswor*\"
send \"\$su_user_pass\\r\"
interact
}
interact
" > $generated_scripts_output_path/myscripts/gas
echo "Generated $generated_scripts_output_path/myscripts/gas "

echo -n "#!/usr/bin/expect -f
if {[llength \$argv] <= 2} {
puts \"\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\
\\n               Usages: diag \\[IP Option\\] \\[Diag\\] \\[User (Optional)\\] \\[Password (Optional)\\]\\n\\
\\
\\n               IP Option:Enter 1 for 192.168.143.16\\
\\n                         Enter 2 for 192.168.143.17\\
\\n                         Enter 3 for 192.168.241.16\\
\\n                         Enter 4 for 192.168.3.52\\n\\
\\
\\n               Diag : Value without using 70**\\
\\n               User : Default is being used as \\\"root\\\".You may specify your username to override default\\
\\n               Password : Default Password is choosen according to the ip of Term-server(can be overriden)\\n\\
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {[llength \$argv] < 2} { exit;
}
}
   set ip_option [lindex \$argv 0];
   set diag [lindex \$argv 1];
   set user [lindex \$argv 2];
   set user_pass [lindex \$argv 3];
   set null_value \"\"
   set diag_base 7000
   set term_diag [expr \$diag_base + \$diag]
   set node_user \"guest\"
   set node_user_pass \"iltwat\"
   set node_su_user \"root\"
   set node_su_user_pass \"swtn100tj\"
   set default_term_server_user \"root\"
   set default_term_server_user_pass \"tslinux\"
   puts \"Turning off all output untill killing the process.\"
   log_user 0

switch \$ip_option {
    {1} {
            set ip \"192.168.143.16\"
    }
    {2} {
            set ip \"192.168.143.17\"
    }
    {3} { 
    	    set ip \"192.168.241.16\"
	    set default_term_server_user_pass \"iltwat\"
    }
    {4} {
            set ip \"192.168.3.52\"
    }
    default {
               puts \"Invalid Term Server IP Option \$ip_option\\n\\n Enter 1 for 192.168.143.16\\n Enter 2 for 192.168.143.17\\n Enter 3 for 192.168.241.16\\n\"
	       exit; 
    }
}

if { \$user == \$null_value } {
   set user \"\$default_term_server_user\"
}
if { \$user_pass == \$null_value } {
   set user_pass \"\$default_term_server_user_pass\"
}

spawn telnet \$ip
set node_spawn_id \$spawn_id
expect \"*login*\"
send \"\$user\\r\"
expect \"*assword*\"
#sleep 1; #Dont go so fast
send \"\$user_pass\\r kill -9 \\\$(ps -ef | grep  \\[t\\]tyS\$diag | awk '{print \\\$1}') 2>/dev/null ; exit \\r\"
interact
close \$node_spawn_id

log_user 1
#now trying to connect via diag
	spawn telnet \$ip \$term_diag
	set node_spawn_id_2 \$spawn_id
	expect \"*Escape character is*\"
	send \"\$node_user\\r\"
	expect  {
		     \"*asswor*\"            {
				                    send \"\$node_user_pass\\r\"
				                    exp_continue
			                       }

             \"*command not found*\" {
				                    send \"\\r\"
				                    exp_continue
			                       }

             \"*Dune >\"             {
                                    interact
                                   }

             \"bcmHal*>\"            {
                                    interact
                                   }

             \"*>\"                  {
                                    send \"su\\r\"
			                        expect \"*asswor*\"
				                    send \"\$node_su_user_pass\\r\"
				                    exp_continue
                                   }

             \"*#\"                  {
      	                            send \"#tail -f /etc/name/log/*log00*&\\r\"
				                    interact
                                   }

             \"*again*\"             {
                                    send \"\$node_user\\r\"
			                        expect \"*asswor*\"
				                    send \"\$node_user_pass\\r\"
                                    exp_continue
                                   }

		     default               {
			                        interact
			                       }
		    }
" > $generated_scripts_output_path/myscripts/diag
echo "Generated $generated_scripts_output_path/myscripts/diag "

echo -n "192.168.230.134 ajit iltwat
192.168.230.48 sparsh orangejuice
192.168.230.80 parmil iltwat
192.168.230.82 eshangoyal iltwat
192.168.230.12 abhijit iltwat
192.168.230.32 pawan iltwat
192.168.230.37 ravipa iltwat
192.168.230.88 varun iltwat
192.168.250.105 ananthp iltwat
192.168.230.15 priyank iltwat
192.168.230.45 shashwat iltwat123
192.168.230.41 satya iltwat
192.168.230.66 kanishta iltwat
192.168.230.159 ambarish iltwat1
192.168.143.143 guest iltwat
192.168.240.44 labuser iltwat
192.168.143.144 guest iltwat
192.168.143.150 guest iltwat
192.168.143.184 siofed iltwat
192.168.0.14 swtn100 tn100sw
192.168.230.122 techie iltwat
192.168.230.153 root iltwat
192.168.230.157 root iltwat
192.168.230.30 pawan iltwat
192.168.230.unknown satyanarayanab iltwat
192.168.230.70 ramakrishna iltwat
192.168.230.141 puneet iltwat
192.168.230.28 kanishta iltwat
192.168.17.235 swtn100 tn100sw
192.168.17.59 tj100rel reltj100
192.168.17.56 tj100rel reltj100
192.168.230.131 siofed Dell1401
192.168.230.135 satya iltwat
192.168.230.142 eswaran iltwat
10.124.0.22 root iltwat
192.168.230.143 siofed Dell1401
192.168.230.22 nittin iltwat
192.168.0.160 shivamr Iltwat123
192.168.220.95 manojk name2015
192.168.143.147 guest iltwat
192.168.230.86 ankit iltwat
192.168.240.11 Techie iltwat
192.168.242.93 shivamraj iltwat
192.168.242.20 vaisha iltwat
192.168.50.212 tj100reg regtj100
192.168.50.210 tj100reg regtj100
192.168.230.31 pramodmj 1iltwat1
" > $generated_scripts_output_path/myscripts/psm_file
echo "Generated $generated_scripts_output_path/myscripts/psm_file "

echo -n "#echo localhost;
#nmap --open -p U:3632,T:3632 192.168.230.1/24 |grep -v \"is closed\"|grep -o '[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}'
echo '--randomize' > \$HOME/.distcc/hosts
echo 'localhost' >> \$HOME/.distcc/hosts
avahi-browse _distcc._tcp -t -r | grep address | grep -v '10.0.0.2' | grep -v '192.168.230.60' |awk -F [ {'print \$2'} | awk -F ] {'print \$1'} | sed -e 's/\$/,cpp,lzo/g'| cat >> \$HOME/.distcc/hosts

cat \$HOME/.distcc/hosts

" > $generated_scripts_output_path/myscripts/distcc_hosts.sh
echo "Generated $generated_scripts_output_path/myscripts/distcc_hosts.sh "

echo -n "#!/usr/bin/expect -f
set force_conservative 0  ;# set to 1 to force conservative mode even if
                          ;# script wasn't run conservatively originally
if {\$force_conservative} {
        set send_slow {1 .1}
        proc send {ignore arg} {
                sleep .1
                exp_send -s -- \$arg
        }
}
if {[llength \$argv] <= 2} {
puts \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\
\\n               Usages: logs \\[Node_IP\\] \\[Card_Slot\\]\\n\\
\\
\\n               Node_IP : 102 will be treated as 192.168.143.102\\
\\n                         241.244 will be treated as 192.168.241.244\\
\\n                         169.200.100 will be treated as 192.169.200.100\\
\\n                         172.124.143.102 will be Taken as complete IP as it is given.\\
\\
\\n               Card_Slot:First it will copy card logs to xcc then from xcc to your system.\\
\\n                         Script will try to get ethicc ip automatically.Ex:For BR_10_0_2 its 127.7.1.slot but for BR_8_0_1 its 127.1.1.slot\\n
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {[llength \$argv] < 2} { exit;
}
}

   set ip_part [lindex \$argv 0];
   set slot [lindex \$argv 1];
#   set icc_ip_second_byte [lindex \$argv 2];
   set user \"guest\";
   set user_pass \"iltwat\";
   set su_user \"root\";
   set su_user_pass \"swtn100tj\";
   set tempdir \"temp_cef5logs\";
   set local_dir_last \"cef5_logs\";
   set null_value \"\";
   set my_username \"$your_pc_username\"; #<#<#$(whoami)#>#>#
   set udsc \"_\";
   set port \"2023\";
#flexible IP addressing
#So that u can provide 102 or 241.244 or 169.143.102 or 172.124.36.102 as IP.
    regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$ip_part all first second third fourth
if { \$fourth != \$null_value } {
   set ip \"\$all\"
} elseif { \$third != \$null_value } {
   set ip \"192\\.\$first\\.\$second\\.\$third\"
} elseif { \$second != \$null_value } {
   set ip \"192\\.168\\.\$first\\.\$second\"
} elseif { \$first != \$null_value } {
   set ip \"192\\.168\\.143\\.\$first\"
} else { puts \"Invalid IP\"; exit; }
puts \"\\n\\nNODE IP is \$ip \\n\"
set local_dir [concat \$ip\$udsc\$slot\$udsc\$local_dir_last];

#Copying logs from cef5 to xcc.
#spawn ssh \$user@\$ip
#set node_spawn_id_2 \$spawn_id
#expect {
#    \"*yes/no*\" {
#        send \"yes\\r\"
#        exp_continue
#    }
#
#    \"*asswor*:\" {
#        send \"\$user_pass\\r\"
#    }
#}
spawn telnet \$ip \$port
set node_spawn_id_2 \$spawn_id
expect \"*login*\"
send \"\$user\\r\"
expect \"*assword*\"
send \"\$user_pass\\r\"
expect \"*>\"
send \"su\\r\";
expect \"*asswor*:\" 
send \"\$su_user_pass\\r\";
expect \"*#\"
send -i \$node_spawn_id_2 \"\\
total_icc=\`route|grep icc|wc -l\`;echo \\\$total_icc;\\r\\
basic_icc=\`route|grep icc|grep 127.\\[0-1\\]|wc -l\`;echo \\\$basic_icc;\\r\\
special_icc=\\\$(( \\\$total_icc - \\\$basic_icc ))\\r\\
if \\[ \\\"\\\$special_icc\\\" == \\\"0\\\" \\]; then\\r\\
route|grep icc|grep 127\\.1\\r\\
else\\r\\
route|grep icc|grep 127\\.\\[2-9\\]\\r\\
fi\\r\\
\\r\"
       expect {
               -re {127\\.(\\S+)\\.1\\.[0-9]} {
                                         set icc_ip_string \$expect_out(1,string)
                                         regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$icc_ip_string icc_ip_second_byte
                                      }
              }
send \"cd /tmp\\r\";
expect \"*#\"
send \"mkdir \$tempdir\\r\";
expect \"*#\"
send \"ncftpget -R -u\$su_user -p\$su_user_pass 127.\$icc_ip_second_byte.1.\$slot /tmp/\$tempdir /etc/name/log/\\r\";
#expect \"*#\"
#send \"cd \$tempdir\\r\";
#expect \"*#\"
#send \"ftp 127.\$icc_ip_second_byte.1.\$slot\\r\";
#expect \"*):\"
#send \"root\\r\";
#expect \"*asswor*\" 
#send \"\$su_user_pass\\r\";
#expect \"*>\"
#send \"cd /etc/name/log/\\r\";
#expect \"*>\" 
#send \"prompt\\r\";
#expect \"*>\"       
#send \"mget *\\r\";
#expect \"*>\" 
#send \"exit\\r\";
expect \"*#\"
send \"ls -l\\r\";
expect \"*#\"
send \"exit\\r\";
expect \"*>\"       
send \"exit\\r\";

#Downloading the logs from Xcc to local machine
spawn \$env(SHELL)
expect \"*\$ \"
send \"cd /home/\$my_username/\\r\";
expect \"*\$ \"
send \"rm -rf /home/\$my_username/\$local_dir\\r\";
expect \"*\$ \"
send \"mkdir \$local_dir\\r\";
expect \"*\$ \"
send \"cd \$local_dir;pwd\\r\";
expect \"*\$ \"
send \"echo \$tempdir\\r\";
expect \"*\$ \"
send \"ls -l\\r\";
expect \"*\$ \"
send \"echo ncftpget -R -u\$user -p\$user_pass \$ip /home/\$my_username/\$local_dir /tmp/\$tempdir\\r\";
expect \"*\$ \"
send \"ncftpget -R -u\$user -p\$user_pass \$ip /home/\$my_username/\$local_dir /tmp/\$tempdir/\\r\";
expect \"*\$ \"
send \"ls -lR\\r\";
expect \"*\$ \"
send \"ls -lR\\r\";
expect \"*\$ \"
send \"logout\\r\";

#Cleaning logs from xcc
#spawn ssh \$user@\$ip
#set node_spawn_id \$spawn_id
#expect {
#    \"*yes/no*\" {
#        send \"yes\\r\"
#        exp_continue
#    }
#
#    \"assword:\" {
#        send \"\$user_pass\\r\"
#    }
#}
spawn telnet \$ip \$port
set node_spawn_id_2 \$spawn_id
expect \"*login*\"
send \"\$user\\r\"
expect \"*assword*\"
send \"\$user_pass\\r\"
expect \"*>\"
send \"su\\r\";
expect \"*asswor*:\"
send \"\$su_user_pass\\r\";
expect \"*#\"
send \"cd /tmp\\r\";
expect \"*#\"
send \"rm -rf \$tempdir\\r\";
expect \"*#\"
send \"exit\\r\";
expect \"*>\"
send \"exit\\r\";
expect eof
exit

" > $generated_scripts_output_path/myscripts/logs
echo "Generated $generated_scripts_output_path/myscripts/logs "

echo -n "#!/usr/bin/env expect 
##########################################################Generic Auto Telnet (gat)###########################################################
if {[llength \$argv] < 4} {
puts \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\
\\n               Usages: gat \\[IP_or_IP_part\\]   Username      Password     Super_User_Password\\(Optional\\)\\n 
\\
\\n               Node_IP : 102 will be treated as 192.168.143.102\\
\\n                         241.244 will be treated as 192.168.241.244\\
\\n                         169.200.100 will be treated as 192.169.200.100\\
\\n                         172.124.143.102 will be Taken as complete IP as it is given.\\n
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {[llength \$argv] < 3} { exit;
}
}
 # timeout -1 means infinite
    set timeout 600
    set ip_part [lindex \$argv 0];
    set user [lindex \$argv 1];
    set user_pass [lindex \$argv 2];
    set remote_release_details_path [lindex \$argv 3];
    set null_value \"\";
#    set release_details_path \"/tmp/releases_details.txt\"
    set release_images_path \"/home/swtn100/releases/\"
#flexible IP addressing
#So that u can provide 102 or 241.244 or 169.143.102 or 172.124.36.102 as IP.
    regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$ip_part all first second third fourth
if { \$fourth != \$null_value } {
   set ip \"\$all\"
} elseif { \$third != \$null_value } {
   set ip \"192\\.\$first\\.\$second\\.\$third\"
} elseif { \$second != \$null_value } {
   set ip \"192\\.168\\.\$first\\.\$second\"
} elseif { \$first != \$null_value } {
   set ip \"192\\.168\\.143\\.\$first\"
} else { puts \"Invalid IP\"; exit; }
puts \"\\nEntity IP is \$ip \\n\"

if {[llength \$argv] == 4} {
        spawn telnet \$ip
        set node_spawn_id \$spawn_id
        expect \"*login*\"
        send \"\$user\\r\"
	expect  {
		\"*asswor*\" {
				send \"\$user_pass\\r\"
				exp_continue
			   }
     \"*command not found*\" {
				send \"\\r\"
				exp_continue
			   }
 
             \"*incorrect*\" {
                                return 1
                           }

		     \"*\$*\" {
			         send \"stty -echo \\r rel_det=\\\"\$remote_release_details_path\\\" ; echo -n \\> \\\$rel_det ; pushd \$release_images_path ; for direc in \\\$\\(ls -d1 REL\\*\\); do pushd \\\$direc/a_x/ 2\\>/dev/null ;suc=\\\$\\? ;if \\[ \\\$suc == 0 \\];then echo \\\"\\\$direc\\\" \\>\\> \\\$rel_det ; ls -1d a\\* \\>\\> \\\$rel_det 2\\>/dev/null ;echo \\\"end\\\$direc\\\" \\>\\> \\\$rel_det; popd >/dev/null ;fi; done ; popd ; echo \\\"DONE\\\" \\r\"
                     expect \"*DONE\"
                     #interact
                     exit ;
			       }

		   default {
				interact
			   }
		}
}

" > $generated_scripts_output_path/myscripts/relinfo
echo "Generated $generated_scripts_output_path/myscripts/relinfo "

echo -n "#!/usr/bin/expect
#   exp_internal 1
#   this option is for detailed debugging.
    set timeout 30
    set ip_part [lindex \$argv 0];
    set image_path [lindex \$argv 1];
#   set image_type [lindex \$argv 2];
    set user \"guest\";
    set user_pass \"iltwat\";
    set su_user \"root\";
    set su_user_pass \"swtn100tj\";
    set my_pc_user \"$your_pc_username\"; #<#<#$(whoami)#>#>#
    set my_pc_user_pass \"$your_pc_password\";
    set null_value \"\";
    set half_ip \"192.168.\";
    set port \"2023\";
    set release_build_server_ip \"192.168.0.14\";
    set release_build_server_username \"swtn100\";
    set release_build_server_password \"tn100sw\";
    set release_base_dir \"/home/swtn100/releases\";
    set release_build_mode_string \"rel\";
    set release_build_branch_name [lindex \$argv 2];
    set release_build_tag [lindex \$argv 3];
    set release_build_type [lindex \$argv 4];
    set image_extension \".squash.img\"
    set image_name_delimeters \"-_\"
    set control_card_image_types {xcc360g tj1700 teraxc}
    set control_card_current_image_dir \"/etc/bin/name\";
    set control_card_previous_image_dir \"/etc/bin/namePrevious\";
    set control_card_next_image_dir \"/etc/bin/nameNext\";
    set intelligent_card_image_types {cef5 plc01 cef4 pcpe01}
#   set intelligent_card_image_dir \"/etc/name/builds/\$image_type\";
#   shifted after the \$image_type is detected.
    set custom_card_image_types1 {for_future_use}
    set custom_card_image_types1_dir \"/etc/name/custom1\"
    set custom_card_image_types2 {for_future_use}
    set custom_card_image_types2_dir \"/etc/name/custom2\"
    set execution_shell \"bash\"

if {(\$ip_part != \$release_build_mode_string) && (\$ip_part != \$null_value)} {
         #flexible IP addressing
         #So that u can provide 102 or 241.244 or 169.143.102 or 172.124.36.102 as IP.
         regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$ip_part all first second third fourth
         if { \$fourth != \$null_value } {
            set ip \"\$all\"
         } elseif { \$third != \$null_value } {
            set ip \"192\\.\$first\\.\$second\\.\$third\"
         } elseif { \$second != \$null_value } {
            set ip \"192\\.168\\.\$first\\.\$second\"
         } elseif { \$first != \$null_value } {
            set ip \"192\\.168\\.143\\.\$first\"
         } else { puts \"Invalid IP\"; exit; }
         puts \"\\nNODE IP is \$ip \\n\"
}

if {((\$image_path != \$release_build_mode_string) && ([llength \$argv] < 2)) && ((\$ip_part != \$release_build_mode_string) && ([llength \$argv] < 2)) } {
puts \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\
\\n               Usages:   1. up \\[Node_IP\\] \\[Image\\]\\
\\n                         2. up rel \\n\\
\\
\\n               Node_IP : 102 will be treated as 192.168.143.102\\
\\n                         241.244 will be treated as 192.168.241.244\\
\\n                         169.200.100 will be treated as 192.169.200.100\\
\\n                         172.124.143.102 will be Taken as complete IP as it is given.\\
\\
\\n               Image :   You can give in any manner. You can even use relative path or just the image name from the directory where image is.\\
\\n                         script will automatically calculate the complete path of image.\\
\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {((\$image_path != \$release_build_mode_string) && ([llength \$argv] < 2)) && ((\$ip_part != \$release_build_mode_string) && ([llength \$argv] < 2)) } {
 exit;
}
}

if { \$image_path != \$release_build_mode_string && \$ip_part != \$release_build_mode_string } {
    puts \"\\nScript will try to upload image from your pc.\\n\"

    #Get system IP
    spawn hostname -I
    expect \"192*\"
    set my_ipaddr \$expect_out(buffer)
    #other method to get IP.If above fails
    if { \$my_ipaddr == \$null_value } {
        spawn ifconfig
        expect -re {inet addr:192\\.168\\.(\\S+)}
        set my_ipaddr [concat \$half_ip\$expect_out(1,string)]
    }
    puts \"\\nMy PC IP is \$my_ipaddr\\n\"

#Trimming newline & return carriage from IP
set my_ipaddr [string trimright \"\$my_ipaddr\" '\\n']
set my_ipaddr [string trimright \"\$my_ipaddr\" '\\r']

#To handle the case when dir is NULL. so to get the pwd of image.
regexp \"^(\\.*/)?(\\[^/\\]*)\$\" \$image_path full_image_path dir_path file_name
if { \$dir_path == \$null_value } {
	   spawn pwd
	   expect \"/*\"
	   set img_pwd \$expect_out(buffer)
	   set dir_path [string trimright \"\$img_pwd\" '\\n']
	   set dir_path [string trimright \"\$dir_path\" '\\r']
}

#To handle addresses like ../../CEF5/tj100mc/../cef5.img
spawn readlink -e \$dir_path
expect \"/*\"
set dir_path \$expect_out(buffer)
if { \$dir_path == \$null_value } {
puts \"Invalid Image Path\"
exit;
}

#Trimming the existing newline & return carriage from dir_path & making it concatable.
set dir_path [string trimright \"\$dir_path\" '\\n']
set dir_path [string trimright \"\$dir_path\" '\\r']
set full_image_path [concat \$dir_path/\$file_name]

#After finishing the full_image_path final check if file exists or not.
if {[file exists \$full_image_path]} {
    puts \"File path seems ok!\"
} else {
    puts \"File doesn't exist. Please check the given Path\"; exit;
}

#Detecting the image type
if { \$file_name == \$null_value } {
puts \"File Name should not be NULL\";
exit;
}
set get_image_type_script \"image=\\\"\$file_name\\\";if \\[\\[ \\\$image =~ \$image_extension\\\$ \\]\\];then imgtype=\\\$\\{image%%\\[\$image_name_delimeters\\]*\\}; echo \\\"\\\$imgtype\\\"; else echo \\\"invalid\\\"; fi\"
set image_type [exec \$execution_shell -c \$get_image_type_script]
puts \"Image Type Detected is \$image_type\"

if { \$image_type == \"invalid\" } {
     puts \"It seems that this image's extension is not \$image_extension. So its invalid.\";
     exit;
}
if {[lsearch -exact \$control_card_image_types \$image_type] >= 0} {
    puts \"\$image_type is a control_card_type_image!!!\"
    set card_type \"control_card\"
} elseif {[lsearch -exact \$intelligent_card_image_types \$image_type] >= 0} {
    puts \"\$image_type is a intelligent_card_type_image!!!\"
    set card_type \"intelligent_card\"
} elseif {[lsearch -exact \$custom_card_image_types1 \$image_type] >= 0} {
    puts \"\$image_type is a custom_card_image_types1!!!\"
    set card_type \"custom_card1\"
} elseif {[lsearch -exact \$custom_card_image_types2 \$image_type] >= 0} {
    puts \"\$image_type is a custom_card_image_types2!!!\"
    set card_type \"custom_card2\"
} else { puts \"Unable to decide wheather its intelligent_card or control_card or any custom_type Type of image. Please add this to script.\"; exit;}
######
     set intelligent_card_image_dir \"/etc/name/builds/\$image_type\";
######
puts \"\\nFull image path is \$full_image_path \\nDirectory Path is \$dir_path \\nFile Name is \$file_name\"
#Will check the card type and accordingly upload the image.

if { \$card_type == \"intelligent_card\" } {
puts \"Uploading \$image_type image. Card Type : \$card_type\"
spawn telnet \$ip \$port
set node_spawn_id \$spawn_id
expect \"*login*\"
send \"\$user\\r\"
expect \"*asswor*\"
send \"\$user_pass\\r\"
expect  \"*>\"
send \"su\\r\"
expect \"*asswor*:\" 
send \"\$su_user_pass\\r\";
expect \"*#\"
send \"mkdir -p \$intelligent_card_image_dir ; cd \$intelligent_card_image_dir \\r\";
expect {
    \"*No such file or directory*\" {
        send \"mkdir -p \$intelligent_card_image_dir ; cd \$intelligent_card_image_dir; pwd;\\r\"
    }

    \"*#\" {
        send \"rm -rf \$intelligent_card_image_dir/*;\\r ls -lrt ; pwd\\r\"
    }
}
expect \"*#\"
send \"ncftpget -u\$my_pc_user -p\$my_pc_user_pass \$my_ipaddr . \$full_image_path\\.md5\\r\"
expect \"*#\"
send \"ncftpget -u\$my_pc_user -p\$my_pc_user_pass \$my_ipaddr . \$full_image_path\\r\"
expect \"*#\"
send \"ls;pwd\\r\"
expect \"*#\"
interact
} elseif { \$card_type == \"control_card\" } {
puts \"Uploading \$image_type image. Card Type : \$card_type\"
spawn telnet \$ip \$port
set node_spawn_id \$spawn_id
expect \"*login*\"
send \"\$user\\r\"
expect \"*asswor*\"
send \"\$user_pass\\r\"
expect  \"*>\"
send \"su\\r\"
expect \"*asswor*:\"
send \"\$su_user_pass\\r\";
expect \"*#\"
send \"cd \$control_card_current_image_dir\\r\"
expect \"*#\"
send \"stty -echo ; image=\\\$\\(ls -1t --color=never \\*\$image_extension\\);\\r\"
expect \"*#\"
send \"if \\[\\[ \\\$image =~ \$image_extension\\\$ \\]\\];then imgtype=\\\$\\{image%%\\[\$image_name_delimeters\\]*\\}; echo \\\"\\\$imgtype\\\"; else echo \\\"invalid\\\"; fi \\r\"
expect -re {(\\S+)\\r\\n}
set existing_image_type \$expect_out(1,string)
if { \$image_type != \$existing_image_type } {
puts \"\\n\\nThe current image type being used at node is different than what u r uploading.\\n\\
 Please retry with correct image.\\n Current image being used is \$existing_image_type \\n You are trying to upload \$image_type\"
#exit;
send \"stty echo\\r\"
expect \"*#\"
interact
}
send \"mount -o remount rw \$control_card_next_image_dir/.. 2\\>/dev/null; mount -o remount rw \$control_card_next_image_dir 2\\>/dev/null\\r\"
expect \"*#\"
send \"cd \$control_card_next_image_dir\\r\"
expect \"*#\"
send \"rm -rf \$control_card_next_image_dir/*;\\r pwd;\\rls\\r\"
expect \"*#\"
send \"ncftpget -u\$my_pc_user -p\$my_pc_user_pass \$my_ipaddr . \$full_image_path\\r\"
expect \"*#\"
send \"ls;pwd\\r\"
expect \"*#\"
send \"stty echo\\r\"
interact
} elseif { \$card_type == \"custom_card1\" } {
puts \"Uploading \$image_type image. Card Type : \$card_type\"
spawn telnet \$ip \$port
set node_spawn_id \$spawn_id
expect \"*login*\"
send \"\$user\\r\"
expect \"*asswor*\"
send \"\$user_pass\\r\"
expect  \"*>\"
send \"su\\r\"
expect \"*asswor*:\"
send \"\$su_user_pass\\r\";
expect \"*#\"
send \"mount -o remount rw \$custom_card_image_types1_dir/.. 2\\>/dev/null; mkdir -p \$custom_card_image_types1_dir ; cd \$custom_card_image_types1_dir\\r\"
expect \"*#\"
send \"mount -o remount rw \$custom_card_image_types1_dir 2\\>/dev/null\\r\"
expect \"*#\"
send \"cd \$custom_card_image_types1_dir\\r\"
expect \"*#\"
send \"rm -rf \$custom_card_image_types1_dir/*;\\r pwd;\\rls\\r\"
expect \"*#\"
send \"ncftpget -u\$my_pc_user -p\$my_pc_user_pass \$my_ipaddr . \$full_image_path\\r\"
expect \"*#\"
send \"ls;pwd\\r\"
expect \"*#\"
interact
}  elseif { \$card_type == \"custom_card2\" } {
puts \"Uploading \$image_type image. Card Type : \$card_type\"
spawn telnet \$ip \$port
set node_spawn_id \$spawn_id
expect \"*login*\"
send \"\$user\\r\"
expect \"*asswor*\"
send \"\$user_pass\\r\"
expect  \"*>\"
send \"su\\r\"
expect \"*asswor*:\"
send \"\$su_user_pass\\r\";
expect \"*#\"
send \"mount -o remount rw \$custom_card_image_types2_dir/.. 2\\>/dev/null; mkdir -p \$custom_card_image_types2_dir ; cd \$custom_card_image_types2_dir\\r\"
expect \"*#\"
send \"mount -o remount rw \$custom_card_image_types2_dir 2\\>/dev/null \\r\"
expect \"*#\"
send \"cd \$custom_card_image_types2_dir\\r\"
expect \"*#\"
send \"rm -rf \$custom_card_image_types2_dir/*;\\r pwd;\\rls\\r\"
expect \"*#\"
send \"ncftpget -u\$my_pc_user -p\$my_pc_user_pass \$my_ipaddr . \$full_image_path\\r\"
expect \"*#\"
send \"ls;pwd\\r\"
expect \"*#\"
interact
}

} elseif { (\$image_path == \$release_build_mode_string) || (\$ip_part == \$release_build_mode_string)} {
if {[llength \$argv] < 4} {
puts \"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\
\\n        Usages: up \\[Node_IP\\] \\[rel\\] \\[Release Branch Name(without BR)\\] \\[Branch Tag\\] \\[Image Type(Optional. Automatically detects if not give)\\]\\n\\
\\
\\n        Example : up 102 rel 10_0_2 a3 tj1700(this is Optional. script will automatically detect if its xcc360g or whatever.)\\
\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {[llength \$argv] < 4} { exit;
}
}

puts \"\\nScript will try to upload from release build server: \$release_build_server_ip\\n\";
puts \"Uploading image\"
spawn telnet \$ip \$port
set node_spawn_id \$spawn_id
expect \"*login*\"
send \"\$user\\r\"
expect \"*asswor*\"
send \"\$user_pass\\r\"
expect  \"*>\"
send \"su\\r\"
expect \"*asswor*:\"
send \"\$su_user_pass\\r\";
expect \"*#\"
send \"cd \$control_card_current_image_dir\\r\"
expect \"*#\"
send \"stty -echo ; image=\\\$\\(ls -1t --color=never \\*\$image_extension\\);\\r\"
expect \"*#\"
send \"if \\[\\[ \\\$image =~ \$image_extension\\\$ \\]\\];then imgtype=\\\$\\{image%%\\[\$image_name_delimeters\\]*\\}; echo \\\"\\\$imgtype\\\"; else echo \\\"invalid\\\"; fi \\r\"
expect -re {(\\S+)\\r\\n}
set existing_image_type \$expect_out(1,string)
if { \$release_build_type == \$null_value } {
	set release_build_type \$existing_image_type
	puts \"Script found that release_build_type is null so setting it to \$existing_image_type\";
}
if {\$release_build_type != \$existing_image_type} {
puts \"\\n\\nThe current image type being used at node is different than what u r uploading(\$release_build_type).\\n\\
Please retry with correct image.\\n Current image being used is \$existing_image_type\"
#exit;
send \"stty echo\\r\"
interact
}
set full_image_path \${release_base_dir}/REL_\${release_build_branch_name}/a_x/\${release_build_tag}/builds/\${release_build_type}-ppc-REL_\${release_build_branch_name}_\${release_build_tag}.squash.img
expect \"*#\"
send \"stty echo\\r\"
expect \"*#\"
send \"mount -o remount rw \$control_card_next_image_dir/.. 2\\>/dev/null ; mount -o remount rw \$control_card_next_image_dir 2\\>/dev/null \\r\"
expect \"*#\"
send \"cd \$control_card_next_image_dir\\r\"
expect \"*#\"
send \"rm -rf \$control_card_next_image_dir/*;\\r pwd;\\rls\\r\"
expect \"*#\"
send \"ncftpget -u\$release_build_server_username -p\$release_build_server_password \$release_build_server_ip . \$full_image_path\\.md5\\r\"
expect \"*#\"
send \"ncftpget -u\$release_build_server_username -p\$release_build_server_password \$release_build_server_ip . \$full_image_path\\r\"
expect \"*#\"
send \"ls;pwd\\r\"
puts \"\\nRelease builds are mostly unified tarkit. That means you have to delete image from /etc/name/builds/*\\n\";
expect \"*#\"
puts \"\\nRelease builds are mostly unified tarkit. That means you have to delete image from /etc/name/builds/*\\n\";
send \"cd /etc/name/builds ; ls * ;\\r\"
expect \"*#\"
interact
} else { puts \"\\nInvalid Usages :( \\n\"; exit;}
" > $generated_scripts_output_path/myscripts/supload
echo "Generated $generated_scripts_output_path/myscripts/supload "

echo -n "#!/usr/bin/env expect 
##########################################################Generic Auto Telnet (gat)###########################################################
if {[llength \$argv] < 3} {
puts \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\
\\n               Usages: gat \\[IP_or_IP_part\\]   Username      Password     Super_User_Password\\(Optional\\)\\n 
\\
\\n               Node_IP : 102 will be treated as 192.168.143.102\\
\\n                         241.244 will be treated as 192.168.241.244\\
\\n                         169.200.100 will be treated as 192.169.200.100\\
\\n                         172.124.143.102 will be Taken as complete IP as it is given.\\n
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";
if {[llength \$argv] < 3} { exit;
}
}
 # timeout -1 means infinite
    set timeout 300
    set ip_part [lindex \$argv 0];
    set user [lindex \$argv 1];
    set user_pass [lindex \$argv 2];
    set su_user_pass [lindex \$argv 3];
    set null_value \"\";

#flexible IP addressing
#So that u can provide 102 or 241.244 or 169.143.102 or 172.124.36.102 as IP.
    regexp \"(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\\.?(\\[0-9]{1,3})?\" \$ip_part all first second third fourth
if { \$fourth != \$null_value } {
   set ip \"\$all\"
} elseif { \$third != \$null_value } {
   set ip \"192\\.\$first\\.\$second\\.\$third\"
} elseif { \$second != \$null_value } {
   set ip \"192\\.168\\.\$first\\.\$second\"
} elseif { \$first != \$null_value } {
   set ip \"192\\.168\\.143\\.\$first\"
} else { puts \"Invalid IP\"; exit; }
puts \"\\nEntity IP is \$ip \\n\"

if {[llength \$argv] == 3} {
        spawn telnet \$ip
        set node_spawn_id \$spawn_id
        expect \"*login*\"
        send \"\$user\\r\"
	expect  {
		\"*asswor*\" {
				send \"\$user_pass\\r\"
				exp_continue
			   }
     \"*command not found*\" {
				send \"\\r\"
				exp_continue
			   }
 
             \"*incorrect*\" {
                                return 1
                           }

		     \"*\$*\" {
				interact
			   }

		   default {
				interact
			   }
		}
}

if {[llength \$argv] == 4} {
spawn telnet \$ip
       set node_spawn_id_2 \$spawn_id
       expect \"*login*\"
       send \"\$user\\r\"
       expect \"*assword*\"
       send \"\$user_pass\\r\"
       expect \"*\\[\$>]\"
       send \"su\\r\"
       expect \"*assword*\"
       send \"\$su_user_pass\\r\"
       expect \"*#\"
       interact
}
" > $generated_scripts_output_path/myscripts/gat
echo "Generated $generated_scripts_output_path/myscripts/gat "

echo -n "current_user=\$(whoami)
if [ \"\$current_user\" == \"root\" ]; then
    echo \"Can not run with root priviledge\";
    exit;
fi
scripts_path=\"$your_scripts_path\"; #<#<#$HOME/myscripts#>#>#
if ! [ -e \$scripts_path ];then
	mkdir -p \$scripts_path
fi
bashrctoken=\"#&&&&^^^^BASHRCIDTOKEN^^^^&&&&#\"
echo \"Copying \$(pwd)/* to \$scripts_path\"
cp -r ./* \$scripts_path
echo \"Setting up ~/.psm_file using ./psm_file\"
cp ./psm_file ~/.psm_file
echo \"Setting up ~/.name_nph using ./name_nph\"
cp ./name_nph ~/.name_nph
echo \"Setting up ~/.name_phone using ./name_phone\"
cp ./name_phone ~/.name_phone
echo \"Now going for ~/.bashrc changes.\"
already_there=\$(cat ~/.bashrc | grep \"\$bashrctoken\" | wc -l)
if [ \"\$already_there\" != \"1\" ];then
    echo \"Seems. bashrc don't have these changes. Updating ~/.bashrc\"
    cat ./bashrc >> ~/.bashrc
else
    echo \"These changes appears to be there in bashrc.\"
    echo \"What should we do?\"
    echo \"Enter : update ,to update these changes.\"
    echo \"Enter : delete ,to delete whatever these kind of changes present from bashrc\"
    echo \"Enter : exit ,to exit & do nothing.\"

while true
do
    read choice
    case \"\$choice\" in 
        update)
                sed -i '/#&&&&^^^^BASHRCIDTOKEN^^^^&&&&#/,\$d' ~/.bashrc
                cat ./bashrc >> ~/.bashrc
                exit ;
            ;;
        delete)
                sed -i '/#&&&&^^^^BASHRCIDTOKEN^^^^&&&&#/,\$d' ~/.bashrc
                exit ;
            ;;
        exit)
                exit ;
            ;;
        *)
                echo \"Invalid choice entered. Enter again.\"
    esac
done

fi
echo \"Updated bashrc\"
source ./bashrc
pe
" > $generated_scripts_output_path/myscripts/automate_all.sh
echo "Generated $generated_scripts_output_path/myscripts/automate_all.sh "

echo -n "#! /bin/bash
THIS_SCRIPT_NAME=\$0 #storing the string name.
TOTAL_PARAMETERS=\$#
if [ \$TOTAL_PARAMETERS -lt \"3\" ];then # if passed argument is not 1 then
echo \"USAGE: \$THIS_SCRIPT_NAME  SEPARATE_SCRIPTS(1:create separate scripts wrt X_VARIABLE, 0:single graph script.)   X_VARIABLE    ALL_Y_AXIS_VARIABLES\"
exit;
fi
#######################################################DEF SECTION################################################
PASSED_PARAMETERS=( \"\$@\" )
SEPARATE_SCRIPTS=\$1
X_AXIS_VARIABLE=\$2
Y_AXIS_VARIABLES=\${PASSED_PARAMETERS[@]:2}
Y_AXIS_VARIABLE_STARTING_NO=2
INPUT_FILENAME=\"finput.txt\"
COMBINED_SOURCING_SCRIPT=\"source_all_other_octave_scripts.m\"
ALL_GRAPHS_TOGETHER_SCRIPT=\"all_variables_in_one_graph.m\"
IMAGE_TYPE=\"jpg\"
echo -n > \$COMBINED_SOURCING_SCRIPT

#######################################################COMMON PART USED###########################################
DEFAULT_HEADER=\"#! /usr/bin/octave -qf
fig = figure;
data = dlmread(\\\"\$INPUT_FILENAME\\\",\\\" \\\");
size(data);
set(fig, \\\"visible\\\", \\\"off\\\");\"
#######################################################PROCEED TO GENERATE########################################

if [ \"\$SEPARATE_SCRIPTS\" == 1 ];then

	for VARIABLE in \${Y_AXIS_VARIABLES[@]}
	do
		echo \$VARIABLE
		echo \"\$DEFAULT_HEADER\" > \$VARIABLE.m;
		echo \"\$X_AXIS_VARIABLE = data(:,1);\" >> \$VARIABLE.m
		Y_AXIS_VARIABLE_STARTING_NO=2

		for INNER_VARIABLE in \${Y_AXIS_VARIABLES[@]}
		do
			echo \"\$INNER_VARIABLE = data(:,\$Y_AXIS_VARIABLE_STARTING_NO);\" >> \$VARIABLE.m
			let Y_AXIS_VARIABLE_STARTING_NO=Y_AXIS_VARIABLE_STARTING_NO+1
		done

		echo \"
plot(\$X_AXIS_VARIABLE,\$VARIABLE,\\\";\$VARIABLE;\\\"), grid
xlabel(\\\"\$X_AXIS_VARIABLE\\\");
ylabel(\\\"\$VARIABLE\\\");
print(\\\"\$VARIABLE.\$IMAGE_TYPE\\\", \\\"-d\$IMAGE_TYPE\\\");
		\" >> \$VARIABLE.m

	echo \"source \$VARIABLE.m\" >> \$COMBINED_SOURCING_SCRIPT
	done

elif [ \"\$SEPARATE_SCRIPTS\" == 0 ];then

	echo \"\$DEFAULT_HEADER\" > \$ALL_GRAPHS_TOGETHER_SCRIPT;
	echo \"\$X_AXIS_VARIABLE = data(:,1);\" >> \$ALL_GRAPHS_TOGETHER_SCRIPT
	
	for VARIABLE in \${Y_AXIS_VARIABLES[@]}
	do
		echo \$VARIABLE
		echo \"\$VARIABLE = data(:,\$Y_AXIS_VARIABLE_STARTING_NO);\" >> \$ALL_GRAPHS_TOGETHER_SCRIPT
		let Y_AXIS_VARIABLE_STARTING_NO=Y_AXIS_VARIABLE_STARTING_NO+1
	done
	FLAG_FOR_FIRST_ITERATION=1
	echo -n \"plot(\" >> \$ALL_GRAPHS_TOGETHER_SCRIPT
	for VARIABLE in \${Y_AXIS_VARIABLES[@]}
	do
		if [ \"\$FLAG_FOR_FIRST_ITERATION\" == 1 ];then
			echo -n \"\$X_AXIS_VARIABLE,\$VARIABLE,\\\";\$VARIABLE;\\\"\" >> \$ALL_GRAPHS_TOGETHER_SCRIPT
			FLAG_FOR_FIRST_ITERATION=0
		else
			echo -n \",\$X_AXIS_VARIABLE,\$VARIABLE,\\\";\$VARIABLE;\\\"\" >> \$ALL_GRAPHS_TOGETHER_SCRIPT
		fi
	done
	echo -n \"), grid\" >> \$ALL_GRAPHS_TOGETHER_SCRIPT

	echo \"
xlabel(\\\"\$X_AXIS_VARIABLE\\\");
ylabel(\\\"ALL_VARIABLES\\\");
print(\\\"ALL.\$IMAGE_TYPE\\\", \\\"-d\$IMAGE_TYPE\\\");
	\" >> \$ALL_GRAPHS_TOGETHER_SCRIPT
else
	echo \"Invalid Value of SEPARATE_SCRIPTS. Renter\"
	exit
fi
" > $generated_scripts_output_path/myscripts/generic_octave_script_generator.sh
echo "Generated $generated_scripts_output_path/myscripts/generic_octave_script_generator.sh "

echo -n "user=\$(whoami)
if [ \"\$user\" != \"root\" ]; then
    echo \"Can not run with non-root priviledge use su or sudo\";
    exit;
fi

snmp_pids=\`ps -ef | grep -iw \"[s]nmpd\" | awk '{print \$2}'\`
nm_pids=\`ps -ef| grep -iw \"[n]m\\.d\" | awk '{print \$2}'\`

echo Checking and killing snmpd if already running
if [ \"\$snmp_pids\" != \"\" ]; then
for signal in \"-15\" \"-1\" \"-9\"
do
  pids=\`ps -ef | grep -iw \"[s]nmpd\" | awk '{print \$2}'\`
  kill \$signal \$pids 2> /dev/null
  echo Trying to Kill pid \$pids with signal \$signal
done
fi

echo Checking if nm.d is already running and killing it.
if [ \"\$nm_pids\" !=  \"\" ]; then
for signal in \"-15\" \"-1\" \"-9\"
do
  pids=\`ps -ef| grep -iw \"[n]m\\.d\" | awk '{print \$2}'\`
  kill \$signal \$pids 2> /dev/null
  echo Trying to Kill pid \$pids with signal \$signal
done
fi
echo No snmp or nm.d is running!!! 
" > $generated_scripts_output_path/myscripts/kill_snmp_nm.sh
echo "Generated $generated_scripts_output_path/myscripts/kill_snmp_nm.sh "

echo -n "run_as=\$(whoami)
if [[ \"\$#\" != \"1\" ]] || [[ \"\$run_as\" != \"root\" ]];then
    echo \"Usage: \$0 package_list_file (run in root previledge mode)\"
    exit
fi
packages_to_be_installed=\$1
for i in \`cat \$packages_to_be_installed\`
do
#aptitude -y install \$i
DEBIAN_FRONTEND=noninteractive aptitude -y install \$i
done
" > $generated_scripts_output_path/myscripts/install.sh
echo "Generated $generated_scripts_output_path/myscripts/install.sh "

echo -n "current_user=\$(whoami)
if [ \"\$current_user\" == \"root\" ]; then
    echo \"Can not run with root priviledge\";
    exit;
fi
bashrctoken=\"#&&&&^^^^BASHRCIDTOKEN^^^^&&&&#\"
already_there=\$(cat ~/.bashrc | grep \"\$bashrctoken\" | wc -l)
if [ \"\$already_there\" != \"1\" ];then
	echo \"Seems. bashrc don't have these changes. Updating ~/.bashrc\"
	cat ./bashrc >> ~/.bashrc
else
	echo \"These changes appears to be there in bashrc.\"
	echo \"What should we do?\"
	echo \"Enter : update ,to update these changes.\"
	echo \"Enter : delete ,to delete whatever these kind of changes from bashrc.\"
	echo \"Enter : exit ,to exit & do nothing.\"

while true
do
	read choice
	case \"\$choice\" in
		update)
				sed -i '/#&&&&^^^^BASHRCIDTOKEN^^^^&&&&#/,\$d' ~/.bashrc
				cat ./bashrc >> ~/.bashrc
				exit ;
			;;
		delete)
				sed -i '/#&&&&^^^^BASHRCIDTOKEN^^^^&&&&#/,\$d' ~/.bashrc
				exit ;
			;;
		exit)
				exit ;
			;;
		*)
				echo \"Invalid choice entered. Enter again.\"
	esac
done

fi
echo \"Updated bashrc\"
" > $generated_scripts_output_path/myscripts/update_bashrc_only.sh
echo "Generated $generated_scripts_output_path/myscripts/update_bashrc_only.sh "

mkdir -p $generated_scripts_output_path/myscripts/python
echo -n "from selenium import webdriver
from selenium.webdriver.common.keys import Keys
import sys

ipaddr = (sys.argv[1])
http_port_no = \"20080\"

# initiate
driver = webdriver.Firefox() # initiate a driver, in this case Firefox
driver.get('http://'+ipaddr+':'+http_port_no+'/EMSRequest/Welcome') # go to the url
# log in
username_field = driver.find_element_by_name(\"Username\") # get the username field
password_field = driver.find_element_by_name(\"Password\") # get the password field
username_field.send_keys(\"name\") # enter in your username
password_field.send_keys(\"password\") # enter in your password

submit_field = driver.find_element_by_name(\"Submit\") # get the submit_field
submit_field.send_keys(Keys.RETURN) # Return it

#Kept For Debugging Purpose
#html = driver.page_source
#print html
" > $generated_scripts_output_path/myscripts/python/web_node.py
echo "Generated $generated_scripts_output_path/myscripts/python/web_node.py "

echo -n "#!/usr/bin/perl

use HTTP::Request::Common qw(GET);
use LWP::UserAgent;
use LWP::Simple;
use HTML::Parser;

find_name(@ARGV); 

sub find_name() {
	\$name = shift;
	\$key = (shift or \"name\");
	\$ua = new LWP::UserAgent;
		my \$p = HTML::Parser->new(api_version => 3);
		\$p->handler( start => \\&start_handler, \"tagname,self\");
		\$p->handler( end => \\&end_handler, \"tagname,self\" );  
		\$p->unbroken_text(1);
		print \"\\n\";
		\$p->parse_file(\"file2\") || die \"Dieing \$!\"; 
		print \"\\n\";

}

sub start_handler
{
        my \$tag = shift;
        my \$self = shift;
 
        if(\$tag eq \"tr\") { print \"\\n\"; }
        elsif (\$tag eq \"td\") {
                \$self->handler(text => sub { my \$t = shift; \$t =~ s/\\s+/ /g; print \"\$t\\t\"; }, \"dtext\");
        }
}

sub end_handler
{
        my \$tag = shift;
        my \$self = shift;
        if (\$tag eq \"td\") { \$self->handler(text => undef); }
}
" > $generated_scripts_output_path/myscripts/python/customparser.pl
echo "Generated $generated_scripts_output_path/myscripts/python/customparser.pl "

echo -n "from __future__ import absolute_import
import cookielib
import urllib2, urllib, urlparse
import urllib2, urllib
import urllib2, urllib
import urllib2, urllib
import urllib2, urllib, urlparse
import urllib2, urllib
import sys

script_name = (sys.argv[0])
totalargs = len(sys.argv)
if totalargs != 2:
	print u\"Usages: %s ip\" % script_name
	sys.exit(0)
ipaddr = (sys.argv[1])
http_port_no = \"20080\"

cj = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
opener.open(u'http://'+ipaddr+':'+http_port_no+'/EMSRequest/Welcome')
opener.addheaders.append((u'User-agent', u'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:37.0) Gecko/20100101 Firefox/10.0.1'))
opener.addheaders.append( (u'Referer', u'http://'+ipaddr+':'+http_port_no+'/EMSRequest/Welcome') )
#Username=NAME&Password=j72e%2305t&Domain=1&Submit=Submit
login_data = urllib.urlencode({
u'Username' : u'NAME',
u'Password' : u\"password\",
u'Domain' : u'1',
u'Submit' : u'Submit',
})
binary_data = login_data.encode(u'ascii')
opener.open(u'http://'+ipaddr+':'+http_port_no+'/EMSRequest/Welcome', binary_data)

#######Different URL Strings#########
base_URL = 'http://'+ipaddr+':'+http_port_no
nodeInventory_URL = base_URL + '/EMSRequest/nodeInventory?'
cardInfo_URL = base_URL + '/EMSRequest/cardInfo'
nodeBody_URL = base_URL + '/EMSRequest/nodeBody?'
print \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\"

resp = opener.open(nodeBody_URL)
print resp.read()
resp.close()
print \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\"
print \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\"

resp = opener.open(nodeInventory_URL)
print resp.read()
resp.close()
print \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\"
print \"\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\"
resp = opener.open(cardInfo_URL)
print resp.read()
resp.close()

#resp = opener.open(base_URL + '/EMSRequest/L2InterfaceParams?serviceSwitch=ServiceSwitch-0-0-11')
#print resp.read()
#resp.close()
" > $generated_scripts_output_path/myscripts/python/autologin.py
echo "Generated $generated_scripts_output_path/myscripts/python/autologin.py "

echo -n "#!/bin/env perl -w

\$VERSION = '0.003';

#------------------------------------------------------------------------------
#
# Pod
#
#------------------------------------------------------------------------------

=head1 NAME

html2text.pl - script for generating formatted text from HTML

=head1 SYNOPSIS

    html2text.pl <filename>
    cat <filename> | html2text.pl

=head1 DESCRIPTION

B<html2text.pl> generated simple formatted text from HTML. It uses
HTML::Element to traverse an HTML tree built by HTML::TreeBuilder, and formats
the output text using Text::Format. It is I<very> simple at the moment. The
type of things it does are:

=over 4

=item Headings

All headings are underlined. <H1>s are double underlined. Headings are
numbered, by using the heading levels, and previous heading levels.

=item Paragraphs

Paragraph text is formatted with the paragraph method of Text::Format.

=item Lists

List items are indented by 4 spaces, and preceded with an asterisk.

=item Definition Lists

<DT>s are intented by 4 spaces; <DD>s are indented by 8 spaces.

=back

=head1 PREREQUISITES

Text::Format
HTML::TreeBuilder

=head1 OSNAMES

any

=head1 AUTHOR

Ave Wrigley E<lt>Ave.Wrigley@itn.co.ukE<gt>

=head1 COPYRIGHT

This script is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 SCRIPT CATEGORIES

Web

=cut

#------------------------------------------------------------------------------
#
# End of pod
#
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
#
# Standard pragmas
#
#------------------------------------------------------------------------------

use strict;
require 5.004;

#------------------------------------------------------------------------------
#
# CPAN modules
#
#------------------------------------------------------------------------------

use Text::Format;
use HTML::TreeBuilder;

#------------------------------------------------------------------------------
#
# Constants
#
#------------------------------------------------------------------------------

use constant IGNORE_TEXT => 1;

#------------------------------------------------------------------------------
#
# Public global varables
#
#------------------------------------------------------------------------------

use vars qw(
    \$html_tree
    \$text_formatter
);

#------------------------------------------------------------------------------
#
# set autoflushing
#
#------------------------------------------------------------------------------

\$|++;

#------------------------------------------------------------------------------
#
# BEGIN block - create global objects
#
#------------------------------------------------------------------------------

BEGIN {
    \$html_tree = new HTML::TreeBuilder;
    \$text_formatter = new Text::Format;
    \$text_formatter->firstIndent( 0 );
}

#------------------------------------------------------------------------------
#
# prefixes to convert tags into - some are converted bachk to Text::Format
# formatting later
#
#------------------------------------------------------------------------------

my %prefix = (
    'li'        => '* ',
    'dt'        => '+ ',
    'dd'        => '- ',
);

my %underline = (
    'h1'        => '+',
    'h2'        => '=',
    'h3'        => '-',
    'h4'        => '-',
    'h5'        => '-',
    'h6'        => '-',
);

my @heading_number = ( 0, 0, 0, 0, 0, 0 );

#------------------------------------------------------------------------------
#
# get_text - get all the text under a node
#
#------------------------------------------------------------------------------

sub get_text
{
    my \$this = shift;
    my \$text = '';

    defined( \$this->content ) || return( '' );
    # iterate though my children ...
    for my \$child ( @{ \$this->content } )
    {
        # if the child is also non-text ...
        if ( ref( \$child ) )
        {
            # traverse it ...
            \$child->traverse(
                # traveral callback
                sub {
                    my( \$node, \$startflag, \$depth ) = @_;
                    # only visit once
                    return 0 unless \$startflag;
                    # if it is non-text ...
                    if ( ref( \$node ) )
                    {
                        # recurse get_text
                        \$text .= get_text( \$node );
                    }
                    # if it is text
                    else
                    {
                        # add it to \$text
                        \$text .= \$node if \$node =~ /\\S/;
                    }
                    return 0;
                },
                not IGNORE_TEXT
            );
        }
        # if it is text
        else
        {
            # add it to \$text
            \$text .= \$child if \$child =~ /\\S/;
        }
    }
    return \$text;
}

#------------------------------------------------------------------------------
#
# get_paragraphs - routine for generating an array of paras from a given node
#
#------------------------------------------------------------------------------

sub get_paragraphs
{
    my \$this = shift;

    # array to save paragraphs in
    my @paras = ();
    # avoid -w warning for .= operation on undefined
    \$paras[ 0 ] = '';

    defined( \$this->content ) || return( @paras );
    # iterate though my children ...
    for my \$child ( @{ \$this->content } )
    {
        # if the child is also non-text ...
        if ( ref( \$child ) )
        {
            # traverse it ...
            \$child->traverse(
                # traveral callback
                sub {
                    my( \$node, \$startflag, \$depth ) = @_;
                    # only visit once
                    return 0 unless \$startflag;
                    # if it is non-text ...
                    if ( ref( \$node ) )
                    {
                        # if it is a list element ...
                        if ( \$node->tag =~ /^(?:li|dd|dt)\$/ )
                        {
                            # recurse get_paragraphs
                            my @new_paras = get_paragraphs( \$node );
                            # pre-pend appropriate prefix for list
                            \$new_paras[ 0 ] =
                                \$prefix{ \$node->tag } . \$new_paras[ 0 ]
                            ;
                            # and update the @paras array
                            @paras = ( @paras, @new_paras );
                            # and traverse no more
                            return 0;
                        }
                        else
                        {
                            # any other element, just traverse
                            return 1;
                        }
                    }
                    else
                    {
                        # add text to the current paragraph ...
                        \$paras[ \$#paras ] = 
                            join( ' ', \$paras[ \$#paras ], \$node )
                            if \$node =~ /\\S/
                        ;
                        # and recurse no more
                        return 0;
                    }
                },
                not IGNORE_TEXT
            );
        }
        else
        {
            # add test to current paragraph ...
            \$paras[ \$#paras ] = join( ' ', \$paras[ \$#paras ], \$child )
                if \$child =~ /\\S/
            ;
        }
    }
    return @paras;
}

#------------------------------------------------------------------------------
#
# Main
#
#------------------------------------------------------------------------------

# parse the STDIN or ARGV

warn \"Starting \$0 ...\\n\";
\$html_tree->parse( join( '', <> ) );

# main tree traversal routine

\$html_tree->traverse(
    sub {
        my( \$node, \$startflag, \$depth ) = @_;
        # ignore what's in the <HEAD>
        return 0 if ref( \$node ) and \$node->tag eq 'head';
        # only visit nodes once
        return 0 unless \$startflag;
        # if this node is non-text ...
        if ( ref \$node )
        {
            # if this is a para  ...
            if ( \$node->tag eq 'p' )
            {
                # iterate sub-paragraphs (including lists) ...
                for ( get_paragraphs( \$node ) )
                {
                    # if it is a <LI> ...
                    if ( /^\\* / )
                    {
                        # indent first line by 4, rest by 6
                        \$text_formatter->firstIndent( 4 );
                        \$text_formatter->bodyIndent( 6 );
                    }
                    # if it is a <DT> ...
                    elsif ( s/^\\+ // )
                    {
                        # set left margin to 4
                        \$text_formatter->leftMargin( 4 );
                    }
                    # if it is a <DD> ...
                    elsif ( s/^- // )
                    {
                        # set left margin to 8
                        \$text_formatter->leftMargin( 8 );
                    }
                    # print formatted paragraphs ...
                    print \$text_formatter->paragraphs( \$_ );
                    # and reset formatter defaults
                    \$text_formatter->leftMargin( 0 );
                    \$text_formatter->firstIndent( 0 );
                    \$text_formatter->bodyIndent( 0 );
                }
                print \"\\n\";
                return 0;
            }
            # if this is a heading ...
            elsif ( \$node->tag =~ /^h(\\d)/ )
            {
                # get the heading level ...
                my \$level = \$1;
                # increment the number for this level ...
                \$heading_number[ \$level ]++;
                # reset lower level heading numbers ...
                for ( \$level+1 .. \$#heading_number )
                {
                    \$heading_number[ \$_ ] = 0;
                }
                # create heading number string
                my \$heading_number = join( 
                    '.', 
                    @heading_number[ 1 .. \$level ]
                );
                # generate heading from number string and heading text ...
                # my \$text = \"\$heading_number \" . get_text( \$node );
                my \$text = get_text( \$node ) . \"\\n\";
                # underline it with the appropriate underline character ...
                \$text =~ s{
                        (.*)
                    }
                    {
                        \"\$1\\n\" . \$underline{ \$node->tag } x length( \$1 )
                    }gex
                ;
                print \$text;
                return 0;
            }
            return 1;
        }
        # if it is text ...
        else
        {
            return 0 unless \$node =~ /\\S/;
            print \$text_formatter->format( \$node );
            return 0;
        }
    },
    not IGNORE_TEXT
);

#------------------------------------------------------------------------------
#
# End of main
#
#------------------------------------------------------------------------------
" > $generated_scripts_output_path/myscripts/python/html2text.pl
echo "Generated $generated_scripts_output_path/myscripts/python/html2text.pl "

echo -n "from __future__ import absolute_import
import cookielib
import urllib2, urllib, urlparse
import urllib2, urllib
import urllib2, urllib
import urllib2, urllib
import urllib2, urllib, urlparse
import urllib2, urllib
import sys

script_name = (sys.argv[0])
totalargs = len(sys.argv)
if totalargs != 2:
	print u\"Usages: %s ip\" % script_name
	sys.exit(0)
ipaddr = (sys.argv[1])
http_port_no = \"20080\"

cj = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
opener.open(u'http://'+ipaddr+':'+http_port_no+'/EMSRequest/Welcome')
opener.addheaders.append((u'User-agent', u'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:37.0) Gecko/20100101 Firefox/10.0.1'))
opener.addheaders.append( (u'Referer', u'http://'+ipaddr+':'+http_port_no+'/EMSRequest/Welcome') )
#Username=NAME&Password=j72e%2305t&Domain=1&Submit=Submit
login_data = urllib.urlencode({
u'Username' : u'NAME',
u'Password' : u\"password\",
u'Domain' : u'1',
u'Submit' : u'Submit',
})
binary_data = login_data.encode(u'ascii')
opener.open(u'http://'+ipaddr+':'+http_port_no+'/EMSRequest/Welcome', binary_data)

#######Different URL Strings#########
base_URL = 'http://'+ipaddr+':'+http_port_no
nodeInventory_URL = base_URL + '/EMSRequest/nodeInventory?'
cardInfo_URL = base_URL + '/EMSRequest/cardInfo'
nodeBody_URL = base_URL + '/EMSRequest/nodeBody?'
resp = opener.open(nodeInventory_URL)
print resp.read()
resp.close()
" > $generated_scripts_output_path/myscripts/python/inventory.py
echo "Generated $generated_scripts_output_path/myscripts/python/inventory.py "

echo -n "import urllib2
import cookielib
from getpass import getpass
import sys
import os
from stat import *

number = sys.argv[1]
message = sys.argv[2]
totalargs = len(sys.argv)
if totalargs != 3:
	print \"Total args :\"+ str(totalargs)
	message = raw_input(\"Enter text: \")
	number = raw_input(\"Enter number: \")

if __name__ == \"__main__\":    
                            way2sms_username=\"$way2sms_username\";
                            way2sms_password=\"$way2sms_password\";

message = \"+\".join(message.split(' '))

#logging into the sms site
url ='http://site24.way2sms.com/Login1.action?'
#data = 'username='+username+'&password='+passwd+'&Submit=Sign+in'
data = 'username='+way2sms_username+'&password='+way2sms_password

#For cookies

cj= cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))

#Adding header details
opener.addheaders=[('User-Agent','Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120')]
try:
    usock =opener.open(url, data)
except IOError:
               print \"error\"
#return()

jession_id =str(cj).split('~')[1].split(' ')[0]
send_sms_url = 'http://site24.way2sms.com/smstoss.action?'
send_sms_data = 'ssaction=ss&Token='+jession_id+'&mobile='+number+'&message='+message+'&msgLen=136'
opener.addheaders=[('Referer', 'http://site25.way2sms.com/sendSMS?Token='+jession_id)]
try:
    sms_sent_page = opener.open(send_sms_url,send_sms_data)
except IOError:
                    print \"error\"
#return()
print \"Success\" 
#return ()
" > $generated_scripts_output_path/myscripts/python/send_sms_way2sms.py
echo "Generated $generated_scripts_output_path/myscripts/python/send_sms_way2sms.py "

mkdir -p $generated_scripts_output_path/myscripts/perl
echo -n "#!/usr/bin/perl
use warnings;
  # will change, for example, a!!a to a\\!\\!a
open(DATA1,\"<file1\") or die \"Can't open data\";
@file = <DATA1>;
# Copy data from one file to another.
# Open new file to write
# my @file=<> || exit(0);
open(DATA2, \">result\");
print DATA2 \"echo -n \\\"\"; 
foreach my \$line (@file) {
     \$line =~ s/([\\[\\]\\(\\)\\?\\\$\"\`\\\\])/\\\\\$1/g;
   print DATA2 \$line;
     }
print DATA2 \"\\\" > generated_file; diff generated_file file1;\";
close( DATA2 );
close( DATA1 );
#full escape
#     \$line =~ s/([;<>\\*\\|\`&\\\$!#\\(\\)\\[\\]\\{\\}:'\"])/\\\\\$1/g;

" > $generated_scripts_output_path/myscripts/perl/escape.pl
echo "Generated $generated_scripts_output_path/myscripts/perl/escape.pl "

echo -n "#!/usr/bin/perl

use HTTP::Request::Common qw(POST);
use LWP::UserAgent;
use LWP::Simple;
use HTML::Parser;

find_name(@ARGV); 

sub find_name() {
	\$name = shift;
	\$key = (shift or \"name\");
	\$ua = new LWP::UserAgent;
	#my \$url = 'http://postfix/cgi-bin/name/tis.cgi';
	my \$url = 'http://192.168.0.8/cgi-bin/name/tis.cgi?action=searchUserInfo&key=name&keyval=';
	my \$res = \$ua->request(POST \$url,
			[ action => searchUserInfo,
			keyval => \$name,
			key => \$key],
		      );

	if(\$res->is_success)  {
		#print \$res->content;
		my \$p = HTML::Parser->new(api_version => 3);
		\$p->handler( start => \\&start_handler, \"tagname,self\");
		\$p->handler( end => \\&end_handler, \"tagname,self\" );  
		\$p->unbroken_text(1);
		print \"\\n\";
		\$p->parse(\$res->content) || die \"Dieing \$!\"; 
		print \"\\n\";

	} else {
		print \"Error: \" . \$res->status_line . \"\\n\";
	}                                                                                                                         
}

sub start_handler
{
        my \$tag = shift;
        my \$self = shift;
 
        if(\$tag eq \"tr\") { print \"\\n\"; }
        elsif (\$tag eq \"td\") {
                \$self->handler(text => sub { my \$t = shift; \$t =~ s/\\s+/ /g; print \"\$t\\t\"; }, \"dtext\");
        }
}

sub end_handler
{
        my \$tag = shift;
        my \$self = shift;
        if (\$tag eq \"td\") { \$self->handler(text => undef); }
}
" > $generated_scripts_output_path/myscripts/perl/phone
echo "Generated $generated_scripts_output_path/myscripts/perl/phone "

echo -n "#!/usr/bin/perl

use HTTP::Request::Common qw(POST);
use LWP::UserAgent;
use LWP::Simple;
use HTML::Parser;

find_name(@ARGV); 

sub find_name() {
	\$name = shift;
	\$key = (shift or \"name\");
	\$ua = new LWP::UserAgent;
	#my \$url = 'http://postfix/cgi-bin/name/tis.cgi';
	my \$url = 'http://192.168.0.8/cgi-bin/name/tis.cgi?action=searchUserInfo&key=name&keyval=';
	my \$res = \$ua->request(POST \$url,
			[ action => searchUserInfo,
			keyval => \$name,
			key => \$key],
		      );

	if(\$res->is_success)  {
	print \$res->content;
	#system(\"html2text\", print \$res->content);
	print \"\\n\";
	} else {
		print \"Error: \" . \$res->status_line . \"\\n\";
	}                                                                                                                         
}

" > $generated_scripts_output_path/myscripts/perl/nph.pl
echo "Generated $generated_scripts_output_path/myscripts/perl/nph.pl "

echo -n "#!/usr/bin/perl
############################################################# Mutater Perl Script ########################################
#the extra string used as #~!@# is for self protection(of mutation perl script) while mutating the orginal script file.
use warnings;
\$option=\$ARGV[0];
\$module_type=\$ARGV[1];
\$module_name=\$ARGV[2];
\$input_file_path=\$ARGV[3];
\$adding_module_file=\$ARGV[4];
\$output_file_path=\$input_file_path.\"_evolved\";
\$num_args = \$#ARGV + 1;
if ( ((\$num_args != 5) && (\$option !~ /delete/)) || ((\$option =~ /delete/) && (\$num_args != 4)) ) {
	print \"\\nUsage: mutate.pl add/update/delete module_type module_name input_file_path adding_module_file\\nIncase of delete only 3 args\\n\";
	exit;
}

open(DATA1,\"<\$input_file_path\") or die \"Can't open script_file\";
@file = <DATA1>;
open(DATA2, \">\$output_file_path\");
if(\$num_args == 5)
{
	open(DATA3,\"<\$adding_module_file\") or die \"Can't open module_file\";
	@module_file = <DATA3>;
}

if ( (\$option =~ /add/) )
{
	use Switch;
	switch(\$module_type){
		case \"tj100_mc\"     { print \"Calling add function for \$module_type\\n\"; add(); }
		case \"licence\"      { print \"Calling add function for \$module_type\\n\"; add(); }
		else                { print \"Unknown module_type\\n\" }
	}
}

elsif ( (\$option =~ /update/) )
{
	use Switch;
	switch(\$module_type){
		case \"tj100_mc\"     { print \"Calling update function for \$module_type\\n\"; update(); }
		case \"licence\"      { print \"Calling update function for \$module_type\\n\"; update(); }
		else                { print \"Unknown module_type\\n\" }
	}
}

elsif ( (\$option =~ /delete/) )
{
	use Switch;
	switch(\$module_type){
		case \"tj100_mc\"     { print \"Calling delete function for \$module_type\\n\"; delete_module(); }
		case \"licence\"      { print \"Calling delete function for \$module_type\\n\"; delete_module(); }
		else                { print \"Unknown module_type\\n\" }
	}
}

else
{
	print \"Unknown Option.\\n\";
}

close( DATA2 );
close( DATA1 );
if(\$num_args == 5)
{
	close( DATA3 );
}

sub add {

COPY: foreach my \$line (@file) 
      { 

	      if ( (\$line =~ /#modify#\$module_type#array#end/) && (\$line !~ /#~!@#/) ) #~!@#
	      {
		      print DATA2 \"\\\"\$module_name\\\"\\n\";
		      print DATA2 \$line;
	      }

	      elsif ( (\$line =~ /#modify#\$module_type#case#end/) && (\$line !~ /#~!@#/) ) #~!@#
	      {
     print DATA2 \"\\
#modify#\$module_type#case#\$module_name#start
  *\$module_name*)
    \${module_type}_diff_file_name=\\\"\${module_type}_\${module_name}.diff\\\";
    ;;
#modify#\$module_type#case#\$module_name#end

\";
              print DATA2 \$line;
	      }

	      elsif ( (\$line =~ /#modify#\$module_type#file#end/) && (\$line !~ /#~!@#/) ) #~!@#
	      {
print DATA2 \"\\
#modify#\$module_type#file#\$module_name#start
echo -n \\\"\";
			foreach my \$module_file_line (@module_file)
			{
			\$module_file_line =~ s/([\\\$\"\`\\\\])/\\\\\$1/g;
			print DATA2 \$module_file_line;
			}
		print DATA2 \"\\\" > \\\$\${module_type}_diff_file_path/\${module_type}_\$module_name.diff\";
		print DATA2 \"\\n#modify#\$module_type#file#\$module_name#end\\n\\n\";    
		print DATA2 \$line;
	      }
	      else
	      {
			print DATA2 \$line;
	      }
      }

}

sub update {
	\$my_flag=0;
COPY: foreach my \$line (@file)
      {
	      if ( (\$line =~ /#modify#\$module_type#file#\$module_name#start/) && (\$line !~ /#~!@#/) ) #~!@#
	      {
		      \$my_flag=1;
		      print DATA2 \"\\
#modify#\$module_type#file#\$module_name#start
echo -n \\\"\";
		      foreach my \$module_file_line (@module_file)
		      {
			      \$module_file_line =~ s/([\\\$\"\`\\\\])/\\\\\$1/g;
			      print DATA2 \$module_file_line;
		      }
		      print DATA2 \"\\\" > \\\$\${module_type}_diff_file_path/\${module_type}_\$module_name.diff\";
		      print DATA2 \"\\n#modify#\$module_type#file#\$module_name#end\\n\\n\";
	      }
	      elsif ((\$line !~ /#modify#\$module_type#file#\$module_name#end/) && (\$my_flag == 1) && (\$line !~ /#~!@#/)) #~!@#
	      {
		      next;
	      }

	      elsif ((\$line =~ /#modify#\$module_type#file#\$module_name#end/) && (\$my_flag == 1) && (\$line !~ /#~!@#/)) #~!@#
	      {
		      \$my_flag=0;
		      next;
	      }

	      else
	      {
		      print DATA2 \$line;
	      }

      }

}


sub delete_module {
	\$my_flag=0;
COPY: foreach my \$line (@file)
      {

	      if ( (\$line =~ /^#modify#\$module_type#array#start\$/) && (\$line !~ /#~!@#/) ) #~!@#
	      {
		      \$my_flag=1;
		      print DATA2 \$line;
		      next;
	      }
	      elsif ((\$line !~ /^\\\"\$module_name\\\"\$/) && (\$my_flag == 1) && (\$line !~ /#~!@#/)) #~!@#
	      {
		      print DATA2 \$line;
	      }

	      elsif ((\$line =~ /^\\\"\$module_name\\\"\$/) && (\$my_flag == 1) && (\$line !~ /#~!@#/)) #~!@#
	      {
		      \$my_flag=2;
		      next;
	      }

	      elsif ( (\$line =~ /#modify#\$module_type#case#\$module_name#start/) && (\$line !~ /#~!@#/) ) #~!@#
	      {
		      \$my_flag=4;
		      next;
	      }
	      elsif ((\$line !~ /#modify#\$module_type#case#\$module_name#end/) && (\$my_flag == 4) && (\$line !~ /#~!@#/)) #~!@#
	      {
		      next;
	      }

	      elsif ((\$line =~ /#modify#\$module_type#case#\$module_name#end/) && (\$my_flag == 4) && (\$line !~ /#~!@#/)) #~!@#
	      {
		      \$my_flag=2;
		      next;
	      }

	      elsif ( (\$line =~ /#modify#\$module_type#file#\$module_name#start/) && (\$line !~ /#~!@#/) ) #~!@#
	      {
		      \$my_flag=3;
		      next;
	      }

	      elsif ((\$line !~ /#modify#\$module_type#file#\$module_name#end/) && (\$my_flag == 3) && (\$line !~ /#~!@#/)) #~!@#
	      {
		      next;
	      }

	      elsif ((\$line =~ /#modify#\$module_type#file#\$module_name#end/) && (\$my_flag == 3) && (\$line !~ /#~!@#/)) #~!@#
	      {
		      \$my_flag=2;
		      next;
	      }
	      else
	      {
		      print DATA2 \$line;
	      }

      }

}

" > $generated_scripts_output_path/myscripts/perl/evolution.pl
echo "Generated $generated_scripts_output_path/myscripts/perl/evolution.pl "



chmod -R 777 $generated_scripts_output_path
