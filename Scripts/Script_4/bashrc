#&&&&^^^^BASHRCIDTOKEN^^^^&&&&#
#IF YOU WANT TO MAKE YOUR PERSONAL CHANGES(FXNS ETC.) PLEASE KEEP THEM BELOW THIS BASHRC TOKEN. OTHERWISE ABOVE THIS TOKEN THEY MIGHT GET DESTROYED.
####################################################################### MY ALIASES #####################################################################
# for pushd and popd
alias pu='pushd'
alias ,,='po'
alias clc='gnome-calculator'
alias lsl='ls -lrt'
alias cp7='chmod 777' #changes permissions to 777
#for checkout mirror
alias cout=~/cm-utils/checkout
alias mirr=~/cm-utils/mirror
#directly goto home
alias h='pushd $HOME >> /dev/null'
alias ms='pushd $HOME/myscripts >> /dev/null'
alias ccd='dirs -c'
alias dw='pushd $HOME/Downloads >> /dev/null'
alias dskt='pushd $HOME/Desktop >> /dev/null'
## get rid of command not found
alias cd..='cd ..'
alias cd-='cd -'
## a quick way to get out of current directory
alias ..='pushd .. >> /dev/null'
alias .2='pushd ../../ >> /dev/null'
alias ...='pushd ../../../ >> /dev/null'
alias ....='pushd ../../../../ >> /dev/null'
alias .....='pushd ../../../../../ >> /dev/null'
alias ......='pushd ../../../../../../ >> /dev/null'
alias .......='pushd ../../../../../../../ >> /dev/null'
alias ........='pushd ../../../../../../../../ >> /dev/null'
alias .........='pushd ../../../../../../../../../ >> /dev/null'
alias .3='pushd ../../../ >> /dev/null'
alias .4='pushd ../../../../ >> /dev/null'
alias .5='pushd ../../../../../ >> /dev/null'
alias .6='pushd ../../../../../../ >> /dev/null'
alias .7='pushd ../../../../../../../ >> /dev/null'
alias .8='pushd ../../../../../../../../ >> /dev/null'
####################################################################### OVERRIDES# ####################################################################
function c () {
#++# c : change dir using pushd.
    pushd $@ > /dev/null
}
function kt () {
#++# kt : kill tail
    kill -9 $(ps | grep [t]ail | awk '{print $1}' 2>/dev/null) 2>/dev/null
}
function gs () {
#++# gs : git status,overriding existing package ghostscript.
    git status
}
function gd () {
#++# gd : git diff.
    git diff
}
function po () {
#++# po : same as popdir, but extra thing is you can give how many times you want to popd.
     count=$1
     temp=1
    if [ "$count" == "" ];then
        count=1
    fi
    while [ $temp -le $count ]
    do
        popd >> /dev/null
        let temp=temp+1
    done
}
function sd () {
#++# sd : show dir stack.
    dirs
}

########################################################################## NOTE ########################################################################
#AVOID USING $* WITH fip. use $@ otherwise all args passed via $* will be considered in $1 only in fip fxn.
#  Special Parameters
#  The shell treats several parameters specially.   These  parameters  may only be referenced; assignment to them is not allowed.
#  *      Expands  to  the positional parameters, starting from one.  When the expansion occurs within double quotes, it expands to a  sin‐
#         gle word with the value of each parameter separated by the first character of the IFS special variable.  That is, "$*" is equiva‐
#         lent to "$1c$2c...", where c is the first character of the value of the IFS variable.  If IFS is unset, the parameters are  sepa‐
#         rated  by  spaces.   If  IFS  is null, the parameters are joined without intervening separators.
#  
#  @      Expands to the positional parameters, starting from  one.   When the  expansion  occurs  within  double  quotes,  each  parameter
#         expands to a separate word.  That is, "$@" is equivalent to "$1" "$2"  ...   If the double-quoted expansion occurs within a word,
#         the expansion of the first parameter is joined with  the  begin‐ning  part  of  the original word, and the expansion of the last
#         parameter is joined with the last part  of  the  original  word.When  there  are no positional parameters, "$@" and $@ expand to
#         nothing (i.e., they are removed).

######################################################################## DEFINATIONS ###################################################################
scripts_path="/home/ankit/myscripts"; #<#<#/home/ankit/myscripts#>#>#
user_bashrc=~/.bashrc  ## for root its in root/.bashrc for normal user will be $USER/.bashrc
my_mobile_no="7411199851";
sms_sending_script="$scripts_path/python/send_sms_way2sms.py"
modules_conf_path=~/cm-utils/modules.conf
tej_ph=~/.tejas_phone
tej_nph=~/.tejas_nph
tej_more=~/.tejas_phmore
tej_det=~/.tejas_phmore_details
reip='^[0-9\.]+$' ## regex for matching numerical with . inside // ip .
renum='^[0-9]+$' ## regex for matching numerical value only
retext='^[a-zA-Z0-9]+$' ## regex for matching text
password_manager_file=~/.psm_file
mirrors_of_checkout_file=".mirrors_list"
compile_for_type_file=".compile_for"
universal_mirrors_file=~/.universal_mirrors_list
universal_checkouts_file=~/.universal_checkouts_list
universal_orphan_mirrors_file=~/.universal_orphan_mirrors_list
universal_local_md5_file=~/.universal_local_md5_list
md5_temp_on_release_server="/tmp/.universal_release_md5_list"
universal_release_md5_file=~/.universal_release_md5_list
temp_on_release_server="/tmp/.release_details" #these names
universal_release_details=~/.release_details #should match otherwise will give touble
ems_nms_temp_on_release_server="/tmp/.ems_nms_release_details" #these names
universal_ems_nms_release_details=~/.ems_nms_release_details #should match otherwise will give touble
release_server_ip="192.168.0.14"
release_server_username="swtn100"
release_server_password="tn100sw"
up_ip_list=~/.upload_ip_list
uen_ip_list=~/.uen_ip_list
fip_ip_list=~/.fip_ips
fip143_ip_list=~/.fip143_ips
if ! [ -e $up_ip_list ] || ! [ -e $uen_ip_list ];then
touch $up_ip_list ;
touch $uen_ip_list ;
fi
outer_latest_image=".outer_latest_img"
inner_latest_image=".inner_latest_img"
image_name_delimeters="_-"
combined_image_keyword="unified"
outer_images=(xcc360g tj1700 tj14xx teraxc)
total_outer=${#outer_images[@]};
inner_images=(cef5 elan10)
total_inner=${#inner_images[@]};
timestamp_override_token=".my_priority_1"
final_outer=".combine_me_outer"
final_inner=".combine_me_inner"
image_extraction_dir="tejas"
all_nodes_dir=~/.all_nodes/
if ! [ -d $all_nodes_dir ];then
      mkdir $all_nodes_dir
fi
node_subnets=(143 241 50)
######################################################################## FUNCTIONS #####################################################################
function pe () {
#++# pe : prepare_essential. Take care of initial setup
touch $tej_ph
touch $tej_nph
touch $tej_more
touch $tej_det
touch $password_manager_file
touch $universal_mirrors_file
touch $universal_checkouts_file
touch $universal_orphan_mirrors_file
touch $universal_release_details
touch $universal_ems_nms_release_details
touch $up_ip_list
touch $uen_ip_list
touch $fip_ip_list
touch $fip143_ip_list
touch $universal_release_md5_file
touch $universal_local_md5_file
mkdir -p $all_nodes_dir
urd
uml
ulmd
urmd
update_all &
}
should_this_be_outer_image () {
   image=$1
   for ((index=0; index<$total_outer; index++))
   do
        if [ "${outer_images[$index]}" == "${image}" ]; then
            echo "yes"
            return
        fi
   done;
   echo "no"
}
should_this_be_inner_image () {
   image=$1
   for ((index=0; index<$total_inner; index++))
   do
        if [ "${inner_images[$index]}" == "${image}" ]; then
            echo "yes"
            return
        fi
   done;
   echo "no"
}
function compile () { 
#++# compile : compile function. takes care of complicated compile commands for different targets.
target=$1
thread=$2;
if [[ $target =~ $renum ]];then 
    thread=$target 
    target="" #so that we can fill up value of target from .compile_for file if it exists otherwise just print usage.
fi
rel_path=$(reverse_recursive_search taginfo)
if [[ "$rel_path" == "" ]]; then
     echo "Not able to locate taginfo. Doesn't seem to be checkout or mirror area."
     return
else
     if ! [ -L "$rel_path" ];then
          echo "You are trying to give Compile command in the checkout area. If still want to compile in checkout area write your own fxn."
          echo ";)"
          return
     else
          rel_path=${rel_path%/*}
     fi
fi

if [ -e ${rel_path}/$compile_for_type_file ];then
   temp_target=$(cat ${rel_path}/$compile_for_type_file)
   if [[ "$temp_target" != "" ]] && [ "$target" == "" ];then
       target=$temp_target
   fi
fi

if [ "$target" == "" ]; then
    echo "Usages: compile [ cef5 / xcc360g / tj1700 / plc01 / osmc / elan07 / teraxc / xa10g / elan10 / cef4 /cef4C / tj14xx / tj14xxN ] [No. of threads. Default : 1]";
    return;
fi
  
if ! [ -e './create_install' ]; then
    echo -n "$target" > ${rel_path}/$compile_for_type_file
    pushd $rel_path/tj100_mc/scripts >> /dev/null
fi

if [ "$thread" == "" ];then
    thread=1
fi
compile_dir=$PWD
compile_cmd=$(get_compile_command $target $compile_dir $thread)
if [ "$compile_cmd" == "" ];then
    echo "Unknown target Type. Please add this to the get_compile_command function."
    return
fi
echo $compile_cmd
eval $compile_cmd
}

function _compile() { ## autocompletion function for compile
words=(cef5 xcc360g tj1700 plc01 osmc elan07 teraxc xa10g elan10 cef4 cef4C tj14xx tj14xxN)
rel_path=$(reverse_recursive_search taginfo)
if [[ "$rel_path" == "" ]]; then
     COMPREPLY=( $(compgen -W "$(for word in ${words[@]}; do echo "$word"; done)" -- ${COMP_WORDS[COMP_CWORD]}) )
else
     rel_path=${rel_path%/*}
fi

if [ -e ${rel_path}/$compile_for_type_file ];then
   temp_target=$(cat ${rel_path}/$compile_for_type_file)
   if [[ "$temp_target" != "" ]];then
      COMPREPLY=( $(compgen -W "$temp_target" -- $cur) )
   else
      COMPREPLY=( $(compgen -W "$(for word in ${words[@]}; do echo "$word"; done)" -- ${COMP_WORDS[COMP_CWORD]}) )
   fi
else
   COMPREPLY=( $(compgen -W "$(for word in ${words[@]}; do echo "$word"; done)" -- ${COMP_WORDS[COMP_CWORD]}) )
fi
}
complete -F _compile compile mc
function update_ph () { #internal
    perl $scripts_path/perl/phone > $tej_ph
}
function update_nph () { #internal
    perl $scripts_path/perl/nph.pl $1 $2 $3 $4 | html2text | grep @ > $tej_nph
}
function update_more () { #internal
    GET "http://192.168.0.8/cgi-bin/tejas/tis.cgi?action=searchUserInfo&key=name&keyval=" | sed -e "s/<\/td><td>/ /g"  | sed -e "s/<TR>/\n/g" |sed -e "s/<td><a href=//g" | sed -e "s/<\/td>//g" | grep "tis.cgi?action=dispUserInfo&amp;id" > $tej_more
}

function update_det () { #internal
echo -n "" > $tej_det
for page_id in $(cat $tej_more | awk 'BEGIN { FS = "\"" } { print $2}' | cut -f3 -d '=')
do
    echo "page_id${page_id}start" >> $tej_det
    GET "http://192.168.0.8/cgi-bin/tejas/tis.cgi?action=dispUserInfo&amp;id=$page_id" | html2text | grep -v "Search\|SUBMIT\|Edit\|oExtn\|^$" >> $tej_det
    echo "page_id${page_id}end" >> $tej_det
done
}

function update_all () { 
#++# update_all : update tejas user search info.
    update_ph
    update_nph
    update_more
    update_det &
}
function tejph () { #interal
    cat $tej_ph
}
function tejnph () { # internal
    cat $tej_nph
}
function wht2und () { ## white spaces to underscore converter. internal
    echo "$*" | sed -e 's/ /_/g'
}
function und2wht () { ## white spaces to underscore converter. internal
    echo "$*" | sed -e 's/_/ /g'
}
function diag () {
#++# diag : open diag directly with killing if already someone else is using it.
    $scripts_path/diag $1 $2 $3 $4
}
function up () {
#++# up : upload a local image or release image directly to node.
    $scripts_path/supload $1 $2 $3 $4 $5 $6
    if  [[ $1 =~ $renum ]] ; then ## check if second arg is port or some numerical else it might be last name.
        if ! grep -Fxq "$1" $up_ip_list
        then
#           echo "$1" >> $up_ip_list
            echo "$1" > $up_ip_list # more lazy approach. single tab ip completion
        fi
    fi
}
function _up () { ##internal autocompletion fxn for up. specifically for up rel.
if [[ "$COMP_CWORD" -ge "2" ]] && [[ "${COMP_WORDS[2]}" == "rel" ]];then
case $COMP_CWORD in
        3) COMPREPLY=($(compgen -W "$(cat $universal_release_details |grep ^REL | sed -e 's/REL_//g')" -- ${COMP_WORDS[COMP_CWORD]}));;
        4) COMPREPLY=($(compgen -W "$(cat $universal_release_details |grep -A200 REL_${COMP_WORDS[COMP_CWORD-1]} | grep -B200 endREL_${COMP_WORDS[COMP_CWORD-1]} | grep -v REL)" -- ${COMP_WORDS[COMP_CWORD]}));;
    esac
else
case $COMP_CWORD in
        1) COMPREPLY=($(compgen -W "$(cat $up_ip_list)" -- ${COMP_WORDS[COMP_CWORD]}));;
        2)
        taginfo_relative_path=$(reverse_recursive_search taginfo)
        if [[ "$taginfo_relative_path" == "" ]];then
             COMPREPLY=($(compgen -o filenames -o dirnames -W "$(echo "rel" ; ls -1 )" -- ${COMP_WORDS[COMP_CWORD]}));
              return
        fi
        taginfo_absolute_path=$(readlink -e $taginfo_relative_path)
        taginfo_absolute_path=${taginfo_absolute_path%taginfo}

        if ! [[ -e ${taginfo_absolute_path}${mirrors_of_checkout_file} ]];then
              COMPREPLY=($(compgen -o filenames -o dirnames -W "$(echo "rel" ; ls -1 )" -- ${COMP_WORDS[COMP_CWORD]}));
              return
        fi

        readarray -t mirrors <<< "$(cat ${taginfo_absolute_path}${mirrors_of_checkout_file})"
         total_results=${#mirrors[@]}
        if [[ "$total_results" == "0" ]]; then
             COMPREPLY=($(compgen -o filenames -o dirnames -W "$(echo "rel" ; ls -1 )" -- ${COMP_WORDS[COMP_CWORD]}));
             return
        fi
        IFS=$'\n' tmp=( $(compgen -o dirnames -o filenames -W "$(echo "rel";for((index=0;index<$total_results;index++)); do ls -1rt ${mirrors[$index]}*.img 2>/dev/null | tail -n 1; done)" -- "${COMP_WORDS[$COMP_CWORD]}" ))
         COMPREPLY=( "${tmp[@]}" )
    esac
fi
}
complete -F _up up
function cph () {
#++# cph : compact User search. Can easily manpulate its output. Its mostly an internal bashrc fxn.
    perl $scripts_path/perl/nph.pl $1 $2 $3 $4 | html2text | grep @
}
function uph () { 
#++# uph : User search results with underscore. setting escape chars to spaces so that exact match happens.
    cph | grep -i $(wht2und "$*")    ### -i to ignore case
}
function ph () { 
#++# ph : User search. underscore to white spaces converted. better looking.
    echo "Name               EMail                Extension Cube No   Mobile No    Res Phone   Current        Designation                        Group"
    echo "                                                                         No          Location"
    cat $tej_nph | sed -e 's/_/ /g' | grep -i "$*"    ### -i to ignore case
}
function phm () {
#++# phm : More detailed ph(User Search) , will give more details about person.
for page_id in $(cat $tej_more | grep -i "$*" | awk 'BEGIN { FS = "\"" } { print $2}' | cut -f3 -d '=')
do
    echo " "
    cat $tej_det | grep -A20 "page_id${page_id}start" | grep -B20 "page_id${page_id}end" | grep -v "page_id${page_id}start\|page_id${page_id}end" | grep -i -C 300 "$*" 
done
}
function ei () { ## email initials, get using anything that is grepable, internal fxn
    cat $tej_ph| grep -i "$*" | grep @ | cut -f2 | cut -f1 -d '@'
}
function getemail () { ## email initials, get using anything that is grepable. internal fxn.
    names=( "$@" )
    for name in "${names[@]}"
    do
    cat $tej_ph| grep -i "$name" | grep @ | cut -f2 | cut -f1 -d '@' | sed -e 's/$/@india.tejasnetworks.com/g'
    done
}
function mail () {
#++# mail : mail to people using their email initial, complete name, partial info .cube etc.
    echo -n "" > .mailfifo
    names=( "$@" )
    for name in "${names[@]}"
    do
        cat $tej_ph| grep -i "$name" | grep @ | cut -f2 | cut -f1 -d '@' | sed -e 's/$/@india.tejasnetworks.com,/g' >> .mailfifo
    done
    thunderbird -compose "to='$(cat .mailfifo)'"
    rm .mailfifo
}
function bei () { ## email initials from bangalore office only. internal fxn
    cat $tej_ph|grep -i "$*" | grep @ |grep -i bangalore | cut -f2 | cut -f1 -d '@'
}
function n2i () { ## name to ip
#internal fxn
#declare -a email_initial=($(bei "$*")) ## just try for lookup in bangalore office only. local will work with them only.
    declare -a email_initial=($(cat $tej_ph|grep -i "$*" | grep @ |grep -i bangalore | cut -f2 | cut -f1 -d '@'))
## now loop through the above array
    for i in "${email_initial[@]}"
    do
        temp=`gethostip -d "$i-DT.local"`
        if [ "$?" == "0" ];then
        echo $temp
        fi
    done
}
function rd () {
#++# rd : opens term-eng automatically.
login_as=$1
domain="TEJAS"
if [ "$login_as" == "" ];then
    login_as="parmilk"
fi

    rdesktop -f -5 -K -r clipboard:CLIPBOARD term-eng -u$login_as -d$domain &
}

function node () {
#++# node : telnet to any node.
    $scripts_path/node $1 $2
}
function logs () {
#++# logs : get cef5 logs from any node.
    $scripts_path/logs $1 $2
}
function password_manager () { #internal fxn used by bashrc. stores passwords.
    ip=$1
    username=$(cat $password_manager_file | grep -w $ip |cut -f2 -d ' ')
    if ! [[ $username =~ $retext ]] ; then
        echo -n "login(username):";
        read  username
        echo -n "password:";
        read -s password
        echo "$ip $username $password" >> $password_manager_file
    fi
}
function fip () { #internal fxn used by bashrc
    only_string=($(echo "$*"|sed 's/[0-9]*//g'))
    if  [[ $1 =~ $reip ]] ; then ##    reip='^[0-9.]+$' ## regex for matching numerical with . inside // ip . defined above in definations
    echo "$1" > $fip_ip_list
    if [[ $1 = *.*.*.* ]] ; then
        echo $1
    elif [[ $1 = *.*.* ]] ; then
        echo 192.$1
    elif [[ $1 = *.* ]] ; then
        echo 192.168.$1
    elif [[ $1 -lt 255 ]] ; then
        echo 192.168.230.$1
    else
        possible_ip=($(n2i "$@"))
        printf '%s\n' "${possible_ip[@]}" | grep -vi "Unknown"
    fi

    else
        possible_ip=($(n2i "${only_string[@]}"))
        printf '%s\n' "${possible_ip[@]}" | grep -vi "Unknown"
    fi
}

function _fip () { #completion fxn for fip
case $COMP_CWORD in
        1) COMPREPLY=($(compgen -W "$(cat $fip_ip_list 2>/dev/null)" -- ${COMP_WORDS[COMP_CWORD]}));;
esac
}
complete -F _fip tt s ft pc p

function _fip143 () { #completion fxn for fip143
case $COMP_CWORD in
        1) COMPREPLY=($(compgen -W "$(cat $fip143_ip_list 2>/dev/null)" -- ${COMP_WORDS[COMP_CWORD]}));;
esac
}
complete -F _fip143 pn ni nis cef5

function fip143 () { #internal fxn by bashrc
echo "$1" > $fip143_ip_list
    if [[ $1 = *.*.*.* ]] ; then
        echo $1
    elif [[ $1 = *.*.* ]] ; then
        echo 192.$1
    elif [[ $1 = *.* ]] ; then
        echo 192.168.$1
    elif [[ $1 -lt 255 ]] ; then
        echo 192.168.143.$1
    fi
}

function tt () {
#++# tt : telnet, using ip part or complete ip, email initial, name, cube or phone no. Asks password for frist time, next time automatic login.
null_value=""
if [ "$1" == "$null_value" ];then
echo Input some part of ip or complete ip.
else
        possible_ip=($(fip "$@"))
        no_of_ip=${#possible_ip[@]}
        if [ $no_of_ip -gt "1" ];then
            echo "Multiple Host IP found for the name you gave. Please be more specific."
        elif [ $no_of_ip -lt "1" ];then
            echo "No IP Found for that. Please try again with more accurate info."
        else
            password_manager $possible_ip
            username=$(cat $password_manager_file | grep -w $ip |cut -f2 -d ' ')
            password=$(cat $password_manager_file | grep -w $ip |cut -f3 -d ' ')
            if  [[ $2 =~ $renum ]] ; then ## check if second arg is port or some numerical else it might be last name.
            telnet $possible_ip $2
            else
            # telnet $possible_ip
            $scripts_path/gat $possible_ip $username $password
            fi
        fi
fi
}
# function _tt () { #internal fxn for autocompletion
# COMPREPLY=($(compgen -W "$(cat $password_manager_file | cut -f1 -d ' ')" -- ${COMP_WORDS[COMP_CWORD]}))
# }
# complete -F _tt tt s ft pc

function s () {
#++# s : ssh -X , using ip part or complete ip, email initial, name, cube or phone no. Asks password for frist time, next time automatic login.
    null_value=""
        if [ "$1" == "$null_value" ];then
            echo Usages : s  ip_part/email_initial/cube_no./anything.
        else
             possible_ip=($(fip "$@"))
             no_of_ip=${#possible_ip[@]}
             if [ $no_of_ip -gt "1" ];then
                  echo "Multiple Host IP found for the name you gave. Please be more specific."
             elif [ $no_of_ip -lt "1" ];then
                 echo "No IP Found for that. Please try again with more accurate info."
             else
                 password_manager $possible_ip
                 username=$(cat $password_manager_file | grep -w $ip |cut -f2 -d ' ')
                 password=$(cat $password_manager_file | grep -w $ip |cut -f3 -d ' ')
                 $scripts_path/gas $possible_ip $username $password
             fi
        fi
}

function pc () {
#++# pc : open pc using remote-desktop from ip part or complete ip, email initial, name, cube or phone no.(subnet 230 hardcoded in fip)
null_value=""
vnc_port="5900"
if [ "$1" == "$null_value" ];then
echo Input some part of ip or complete ip or name_of_person/email_initial/cube_no./anything..
else
             possible_ip=($(fip "$@"))
             no_of_ip=${#possible_ip[@]}
             if [ $no_of_ip -gt "1" ];then
                 echo "Multiple Host IP found for the name you gave. Please be more specific."
             elif [ $no_of_ip -lt "1" ];then
                 echo "No IP Found for that. Please try again with more accurate info."
             else
                 vinagre -f --vnc-scale $possible_ip:$vnc_port
             fi

fi
}

function ft () {
#++# ft : ftp, using ip part or complete ip, email initial, name, cube or phone no. Asks password for frist time, next time automatic login.
null_value=""
if [ "$1" == "$null_value" ];then
echo Input some part of ip or complete ip or name_of_person/email_initial/cube_no./anything..
else
             possible_ip=($(fip "$@"))
             no_of_ip=${#possible_ip[@]}
             if [ $no_of_ip -ne "1" ];then
                 echo "Multiple Host IP found for the name you gave. Please be more specific."
             elif [ $no_of_ip -lt "1" ];then
                 echo "No IP Found for that. Please try again with more accurate info."
             else
                password_manager $possible_ip
                username=$(cat $password_manager_file | grep -w $ip |cut -f2 -d ' ')
                password=$(cat $password_manager_file | grep -w $ip |cut -f3 -d ' ')
                if  [[ $2 =~ $renum ]] ; then ## check if second arg is port or some numerical else it might be last name.
                ftp $possible_ip $2
                else
                $scripts_path/gaf $possible_ip $username $password
                fi  
             fi
fi
}

function sbc () {
#++# sbc : source bashrc.
    echo "Sourcing $user_bashrc of user $USER";
    source $user_bashrc
}

function ebc () {
#++# ebc : open bashrc from anywhere and source it after closing.
        echo "Opening $user_bashrc of user $USER";
            vi $user_bashrc +$
        #calling sbc() to source it
        sbc
}

function rbc () {
#++# rbc : open bashrc but don't source on closing it. form anywhere.
            echo "Opening $user_bashrc of user $USER";
                        vi $user_bashrc +$
                                    
}
function gat () {
#++# gat : generic automated telnet. mostly used by other bashrc fxns.
null_value=""
if [ "$1" == "$null_value" ];then
echo Input some part of ip or complete ip or name_of_person/email_initial/cube_no./anything..
else
             possible_ip=($(fip "$1"))
             no_of_ip=${#possible_ip[@]}
             if [ $no_of_ip -ne "1" ];then
                 echo "Multiple Host IP found for the name you gave. Please be more specific."
             elif [ $no_of_ip -lt "1" ];then
                 echo "No IP Found for that. Please try again with more accurate info."
             else
                  $scripts_path/gat $possible_ip $2 $3 $4
             fi
fi
}
function reg () {
#++# reg : automatic telnet to regression server. 240.11 in this case.
    $scripts_path/gas 240.11 Techie iltwat iltwat
}

function rel () {
#++# rel : automatic telnet to release server 0.14.
    $scripts_path/gat $release_server_ip $release_server_username $release_server_password
}

function urd () {
#++# urd : update releases details
    echo "Sending commands to release server so that it will create $temp_on_release_server."
    $scripts_path/relinfo $release_server_ip $release_server_username $release_server_password $temp_on_release_server
    echo "Server has created $temp_on_release_server"
    echo "Downloading that to $universal_release_details"
    echo -n > $universal_release_details
    ncftpget -u$release_server_username -p$release_server_password $release_server_ip ~/ $temp_on_release_server
    echo "Done. Updated Release Details to latest."    
}

function uen () {
#++# uen : update ems nms

        if ! grep -Fxq "$1 $2 $3 $4 $5 $6 $7" $uen_ip_list
        then
           echo "$1 $2 $3 $4 $5 $6 $7" >> $uen_ip_list
        fi

    $scripts_path/uen $1 $2 $3 $4 $5 $6 $7 $8 $9 ${10}
}
function _uen () { ##internal autocompletion fxn for uen.
case $COMP_CWORD in
        1)COMPREPLY=($(compgen -W "$(cat $uen_ip_list | awk 'BEGIN {FS=" "} {print $1}' )" -- ${COMP_WORDS[COMP_CWORD]}));;
        2)COMPREPLY=($(compgen -W "$(cat $uen_ip_list | awk 'BEGIN {FS=" "} {print $2}' )" -- ${COMP_WORDS[COMP_CWORD]}));;
        3)COMPREPLY=($(compgen -W "$(cat $uen_ip_list | awk 'BEGIN {FS=" "} {print $3}' )" -- ${COMP_WORDS[COMP_CWORD]}));;
        4)COMPREPLY=($(compgen -W "$(cat $uen_ip_list | awk 'BEGIN {FS=" "} {print $4}' )" -- ${COMP_WORDS[COMP_CWORD]}));;
        5)COMPREPLY=($(compgen -W "$(cat $uen_ip_list | awk 'BEGIN {FS=" "} {print $5}' )" -- ${COMP_WORDS[COMP_CWORD]}));;
        6)COMPREPLY=($(compgen -W "$(cat $uen_ip_list | awk 'BEGIN {FS=" "} {print $6}' )" -- ${COMP_WORDS[COMP_CWORD]}));;
        7)COMPREPLY=($(compgen -W "$(cat $uen_ip_list | awk 'BEGIN {FS=" "} {print $7}' )" -- ${COMP_WORDS[COMP_CWORD]}));;
        8) COMPREPLY=($(compgen -W "$(cat $universal_ems_nms_release_details |grep ^REL | sed -e 's/REL_//g')" -- ${COMP_WORDS[COMP_CWORD]}));;
        9) COMPREPLY=($(compgen -W "$(cat $universal_ems_nms_release_details |grep -A200 REL_${COMP_WORDS[COMP_CWORD-1]} | grep -B200 endREL_${COMP_WORDS[COMP_CWORD-1]} | grep -v REL)" -- ${COMP_WORDS[COMP_CWORD]}));;
    esac
}
complete -F _uen uen

function uend () {
#++# uend : update ems nms details
    echo "Sending commands to release server so that it will create $ems_nms_temp_on_release_server."
    $scripts_path/emsnmsinfo $release_server_ip $release_server_username $release_server_password $ems_nms_temp_on_release_server
    echo "Server has created $ems_nms_temp_on_release_server"
    echo "Downloading that to $universal_ems_nms_release_details"
    echo -n > $universal_ems_nms_release_details
    ncftpget -u$release_server_username -p$release_server_password $release_server_ip ~/ $ems_nms_temp_on_release_server
    echo "Done. Updated EMS NMS Release Details to latest."    
}


function pf () {
#++# pf : open password file managed by password_manager function. to directly open file and edit any worng info.
    vi $password_manager_file +$
}
function bct () { 
#++# bct : build cscope & ctags. generates cscope.files and build symbol database & tags file also.
    echo "Building cscope.files & cscope database."
    find -name *.cpp -o -name *.[ch] > cscope.files
    echo "cscope.files written."
    cscope -R -b -q -k &
    echo "cscope symbol database building. In Background."
    echo "Building CTAGS database."
    ctags -R *
    echo "ctag & cscope build completed."
}
function cs () { 
#++# cs : run cscope,cscope file is required
    cscope -d
}

function p () { 
#++# p : ping,generally to ping my 3rd floor pcs (subnet 230 is used or name cube no. email initial can be used)
null_value=""
if [ "$1" == "$null_value" ];then
echo Input some part of ip or complete ip or name_of_person/email_initial/cube_no./anything..
else
             possible_ip=($(fip "$@"))
             no_of_ip=${#possible_ip[@]}
             if [ $no_of_ip -ne "1" ];then
                 echo "Multiple Host IP found for the name you gave. Please be more specific."
             elif [ $no_of_ip -lt "1" ];then
                 echo "No IP Found for that. Please try again with more accurate info."
             else
                ping $possible_ip
             fi
fi
}
function pn () { 
#++# pn : pingnode, shorten ping commands, hardcoded fip143 function. all my nodes are in 143 subnet.
null_value=""
if [ "$1" == "$null_value" ];then
echo Input some part of ip or complete ip or name_of_person/email_initial/cube_no./anything..
else
             possible_ip=($(fip143 "$@"))
             no_of_ip=${#possible_ip[@]}
             if [ $no_of_ip -ne "1" ];then
                 echo "Multiple Host IP found for the name you gave. Please be more specific."
             elif [ $no_of_ip -lt "1" ];then
                 echo "No IP Found for that. Please try again with more accurate info."
             else
                ping $possible_ip
             fi
fi
}


function ni () { 
#++# ni : complete node info # mostly card info 
if [ "$1" == "" ];then
echo Input some part of ip or complete ip.
else
             possible_ip=($(fip143 "$@"))
             no_of_ip=${#possible_ip[@]}
             if [ $no_of_ip -ne "1" ];then
                 echo "Multiple Host IP found for the name you gave. Please be more specific."
             elif [ $no_of_ip -lt "1" ];then
                 echo "No IP Found for that. Please try again with more accurate info."
             else
                #python $scripts_path/python/autologin.py $possible_ip |html2text |html2text |sed -e 's/_/ /g' | sed -e 's/Â//g' | sed -e 's/|\ .*|//g'
                 python $scripts_path/python/autologin.py $possible_ip |html2text |html2text
                 fi
fi
}
function nis () {
#++# nis : node info simplified.
if [ "$1" == "" ];then
echo Input some part of ip or complete ip.
else
             possible_ip=($(fip143 "$@"))
             no_of_ip=${#possible_ip[@]}
             if [ $no_of_ip -ne "1" ];then
                 echo "Multiple Host IP found for the name you gave. Please be more specific."
             elif [ $no_of_ip -lt "1" ];then
                 echo "No IP Found for that. Please try again with more accurate info."
             else
                #python $scripts_path/python/autologin.py $possible_ip |html2text |html2text |sed -e 's/_/ /g' | sed -e 's/Â//g' | sed -e 's/|\ .*|//g'
                #python $scripts_path/python/autologin.py $possible_ip |html2text |html2text
#python /home/parmil/myscripts/python/inventory.py $possible_ip | html2text | html2text  | grep ^\|....\|.*________________\| | sed -e 's/_/ /g' | sed -e 's/|/ /g'|column -t
python $scripts_path/python/inventory.py $possible_ip | html2text | html2text  | grep ^\|....\|\[^\ ]*\| |column -t |sed -e 's/_/ /g'

python $scripts_path/python/inventory.py $possible_ip | grep -A 100 "<CAPTION><B>SFP</B></CAPTION>" | grep "TH" | sed -e 's/<TH >//g' | sed -e 's/<\/TH>//g' | sed -e 's/<INPUT TYPE=BUTTON VALUE=.*(.*)" \?>//g'  | sed -e 's/&nbsp;//g' | sed -e 's/<TD >//g' |sed -e 's/<\/TD>/  /g'|sed -e 's/<BR>/  /g' | grep -v "Name Port Operational Status" |column -t
                 fi
fi
}

function cef5 () { 
#++# cef5 : gives slot numbers in which CEF5 are up from UI.Its being used by nall function.
if [ "$1" == "" ];then
echo Input some part of ip or complete ip.
else
             possible_ip=($(fip143 "$@"))
             no_of_ip=${#possible_ip[@]}
             if [ $no_of_ip -ne "1" ];then
                 echo "Multiple Host IP found for the name you gave. Please be more specific."
             elif [ $no_of_ip -lt "1" ];then
                 echo "No IP Found for that. Please try again with more accurate info."
             else
                #python $scripts_path/python/autologin.py $possible_ip |html2text |html2text |sed -e 's/_/ /g' | sed -e 's/Â//g' | sed -e 's/|\ .*|//g'
                 python $scripts_path/python/inventory.py $possible_ip |html2text |html2text|sed -e s/_//g | grep CEF-5 | grep -v Not | cut -f2 -d '|' | tr '\n' ' '
             fi
fi
}
function nodes () { 
#++# nodes : it will give you all live nodes in one ip range(subnet example 143 or 241 subnet)
    if [[ $1 = *.*.*.* ]] ; then
        ip_range=$1
    elif [[ $1 = *.*.* ]] ; then
        ip_range=$1.1
    elif [[ $1 = *.* ]] ; then
        ip_range=192.$1.1
    elif [[ $1 -lt 255 ]] ; then
        ip_range=192.168.$1.1
    fi
if [ "$1" == "" ];then
echo Input IP_Range
else
nmap --open -p U:20080,T:20080 $ip_range/24 |grep -v "is closed"|grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}'
fi
}
function goct () { 
#++# goct : generates octave scripts for creating graphs wrt different variables
    $scripts_path/generic_octave_script_generator.sh $@
}
function cmc () { 
#++# cmc : checkout mirror compile for given targets.
local total_args=$#
local all_args=$@
if [[ "$total_args" -lt "3" ]]; then
    echo "Usage: cmc -dir=<path to checkout> Branch-Name -tag=(optional) -target=cef5 xcc360g etc..(Optional. But -target= should be last parameter)"
    return
fi

 checkout_command=${all_args%%-target=*}
if [[ $all_args =~ "target" ]]; then
     targets=${all_args##*target=}
    else
     targets="xcc360g cef5"
fi
 checkout_path=${all_args##*-dir=}
checkout_path=${checkout_path%% *}
 mirror_path=${checkout_path%/*}
echo "Targets are : $targets"
echo "Checkout path is : $checkout_path"
echo "Mirroring path is : $mirror_path"
echo "Checkout command is : $checkout_command"
if [[ -e "$checkout_path" ]]; then
    echo "$checkout_path Exists Already. Skipping the checkout process."
else
    ~/cm-utils/checkout $checkout_command
fi

for target in $targets; do
    if [[ -e "${mirror_path}/${target}mirror" ]]; then
        echo "${mirror_path}/${target}mirror Already Exists. No need to mirror for this."
    else
        ~/cm-utils/mirror $checkout_path ${mirror_path}/${target}mirror
    fi
done

local chain_of_commands=""

for target in $targets; do

if [ "$thread" == "" ];then
    thread=1
fi

 compile_dir=${mirror_path}/${target}mirror/tj100_mc/scripts
 compile_cmd=$(get_compile_command $target $compile_dir $thread)
if [ "$compile_cmd" == "" ];then
    echo "Unknown target Type. Please add this to the get_compile_command function."
    return
fi
       tab="--tab --title=$target"
       cmd="bash -c 'echo -en \"\033\]0;$target\a\" && cd ${mirror_path}/${target}mirror/tj100_mc/scripts && $compile_cmd ; bash ; echo -en \"\033\]0;$target\a\" ; '"
      chain_of_commands+=($tab -e "$cmd")         
done

gnome-terminal --maximize "${chain_of_commands[@]}"
}

function _cmc()
{ ## autocompletion function for cmc
words=(cef5 xcc360g tj1700 plc01 osmc elan07 teraxc xa10g elan10 cef4 cef4C tj14xx tj14xxN -dir= -target= -tag=)
COMPREPLY=( $(compgen -o dirnames -o filenames -W "$(for word in ${words[@]}; do echo "$word"; done)" -- ${COMP_WORDS[COMP_CWORD]}) )
}
complete -o nospace -F _cmc cmc cout


function kgcc () { 
#++# kgcc : kernelgcc, for compiling kernel modules writes the Makefile for all c file in that dir. Bit of hardcoded things. 
 present_c_files=$(ls ./*.c 2> /dev/null | grep -v ".mod.c")
if [[ "$present_c_files" -eq "" ]]; then
    echo "Unable to find any eligible c file. Make sure you haven't named you c file with *.mod.c extention. By default we ignore these files."
    return 1;
fi
echo -n > Makefile
for filename in $present_c_files
do
     filename=${filename%.*}
    echo  "obj-m += $filename.o" >> Makefile
done

echo -n "
all:
    make -C /lib/modules/2.6.32-38-generic/build M=\$(PWD) modules
clean:
    make -C /lib/modules/2.6.32-38-generic/build M=\$(PWD) clean
" >> Makefile
make
chmod 777 *.ko
}

function st() { 
#++# st : set-title, it will set title of a terminal.
  if [[ -z "$ORIG" ]]; then
    ORIG=$PS1
  fi
  TITLE="\[\e]2;$@\a\]"
  PS1=${ORIG}${TITLE}
}

function nall() { 
#++# nall : nodeall, it will start tailing all logs of a node. including xcc and cef5 also.
 possible_cef5_slots=($(cef5 "$@"))
 chain_of_commands=""

 tab="--tab --title=NODE-$@-XCC"
 node_cmd="$scripts_path/node $@"
# cmd="bash -c 'echo -en \"\033\]0;$@\a\" && $node_cmd ; bash ; echo -en \"\033\]0;$@\a\" ; '"
 cmd="bash -c ' $node_cmd ; bash ;'"
chain_of_commands+=($tab -e "$cmd")
 slot_cmd=""
if [[ "$possible_cef5_slots" -ne "" ]];then
    for slot in ${possible_cef5_slots[@]}
    do
        slot_cmd="$scripts_path/node $@ $slot"
        tab="--tab --title=NODE-$@-SLOT-$slot"
        # cmd="bash -c 'echo -en \"\033\]0;node$@slot$slot\a\" && $slot_cmd ; bash ; echo -en \"\033\]0;node$@slot$slot\a\" ; '"
         cmd="bash -c ' $slot_cmd ; bash ; '"
        chain_of_commands+=($tab -e "$cmd")
    done
fi
gnome-terminal  --maximize "${chain_of_commands[@]}"
}


function mgc() 
#++# mgc : modified gcc, compile c file and generate .out file with same name and run it.
{
     null_value="";
     least_no_of_arguments="1";
     source_code_file_to_be_compiled=$1;
     generated_output_file=$2;
     extension=${source_code_file_to_be_compiled##*.}
    if [[ $generated_output_file -eq $null_value ]]; then
        {
            generated_output_file=${source_code_file_to_be_compiled/%.*/.out};
        }
    fi

    if [[ $# -lt $least_no_of_arguments ]]; then
        {
            echo "Usages: mgc src_code output(optional)"
            return;
        }
    fi
    if [[ "$extension" == "c" ]];then
       gcc $source_code_file_to_be_compiled -g -o $generated_output_file
    elif [[ "$extension" == "cpp" ]];then
       g++ $source_code_file_to_be_compiled -g -o $generated_output_file
    else
       echo "Unknown extension type. Please add in the fxn."
    fi
#     ./$generated_output_file
}

function gts() 
{
#++# gts : git status for all the modules from dir where taginfo is present
    #putting gta so that it can goto tagfile
    gta
     temp=$(readlink -e ./taginfo)
    temp=${temp%taginfo}
    cd $temp
    if ! [ -e './taginfo' ]; then
        echo "No taginfo file found in current directory."
        return
    else
         checkout_path=$(readlink -e ./)
    fi
 tagfile=$checkout_path/taginfo
 versionfile=$checkout_path/versioninfo
 current_branch_name=$(cat $versionfile | grep module_name | cut -f2 -d ' ')
 current_branch_tag=$(cat $versionfile | grep tag | cut -f2 -d ' ')
echo "Your current_branch_name is : $current_branch_name"
echo "Your current_branch_tag is : $current_branch_tag"
declare -a all_modules=$(cat $tagfile | awk '{OFS="\t"; print $2}' | grep -v -- "----\|Component\|LINUX")
for module in ${all_modules[@]}
    do
        pushd ${checkout_path}/$module* 2>/dev/null > /dev/null #have added * so that it will go to min. matching module.
         module_push_status=$?
        if [ $module_push_status -eq 0 ]; then

             pwdmodule=$(pwd)
            pwdmodule=${pwdmodule#$(echo "$checkout_path")/}
            echo "Module $pwdmodule"
            git status
            popd > /dev/null
        else
            echo "Not able to go to module : ${checkout_path}/$module";
        fi
done

}

function gtsp()
{
#++# gtsp : git status & pull, frist will goto module git status , git stash , git pull, git stash pop.
    #putting gta so that it can goto tagfile
    gta
     temp=$(readlink -e ./taginfo)
    temp=${temp%taginfo}
    cd $temp
    if ! [ -e './taginfo' ]; then
        echo "No taginfo file found in current directory."
        return
    else
         checkout_path=$(readlink -e ./)
    fi
 tagfile=$checkout_path/taginfo
 versionfile=$checkout_path/versioninfo
 current_branch_name=$(cat $versionfile | grep module_name | cut -f2 -d ' ')
 current_branch_tag=$(cat $versionfile | grep tag | cut -f2 -d ' ')
echo "Your current_branch_name is : $current_branch_name"
echo "Your current_branch_tag is : $current_branch_tag"
declare -a all_modules=$(cat $tagfile | awk '{OFS="\t"; print $2}' | grep -v -- "----\|Component\|LINUX")
for module in ${all_modules[@]}
    do
        pushd ${checkout_path}/$module* 2>/dev/null > /dev/null #have added * so that it will go to min. matching module.
         module_push_status=$?
        if [ $module_push_status -eq 0 ]; then

             pwdmodule=$(pwd)
            pwdmodule=${pwdmodule#$(echo "$checkout_path")/}
            echo "Module $pwdmodule"
            git status
            git stash
            git pull
            git stash pop
            popd > /dev/null
        else
            echo "Not able to go to module : ${checkout_path}/$module";
        fi
done

}


function reverse_recursive_search () { 
#++# reverse_recursive_search : search recursively backwards for certain file. return null if not found else will return relative path.
   slashes=${PWD//[^\/]/}
   directory="$PWD"
  for (( n=${#slashes}; n>=0; --n ))
  do
    test -e "$directory/$1" && echo "$directory/$1" && return 
    directory="$directory/.."
  done
}

function mkc () { 
#++# mkc : will mkeenv so that can run make clean in any dir.
if [[ "$#" -lt 1 ]]; then
    echo "Usage: mkc target building_for_type(Optional: host(for simulator) or target, default is target)"
    return
fi
 target=$1
 building_for_type=$2
if [ "$building_for_type" == "" ];then
    building_for_type="target"
fi
 rel_path=$(reverse_recursive_search taginfo)

if [[ "$rel_path" == "" ]]; then
    echo "Not able to locate taginfo. Doesn't seem to be checkout or mirror area."
    return
else
    rel_path=${rel_path%/*}
    echo "rel_path is $rel_path"
fi

pushd $rel_path > /dev/null
 taginfo_path=$(pwd)
popd > /dev/null

 src_path=${taginfo_path}
 src_path=${src_path}/tj100_mc/src
echo "src path is $src_path"
case "$target" in
  cef5|xcc360g|tj1700|plc01|osmc|elan07|teraxc|xa10g|elan10|cef4|cef4C|tj14xx|tj14xxN)
  echo "Changing Dir to $src_path"
  echo "Target is $target"
  pushd $src_path > /dev/null
  export SOFTWARE_ROOT=$PWD/
  source $SOFTWARE_ROOT/../scripts/makeenv
  makeenv $target $building_for_type LINUX26 $SOFTWARE_ROOT NO NO
  export SMART_TIDL=YES
  export DEBUG_SMART=YES
  popd > /dev/null
  echo "Ready for make clean commands for target."
    ;;
    *)
    echo "Unknown target Type. Please add this to the mkc function."
    return;
esac

}


function _mkc()
{ ## autocompletion function for mkc
     targets=(cef5 xcc360g tj1700 plc01 osmc elan07 teraxc xa10g elan10 cef4 cef4C tj14xx tj14xxN)
case $COMP_CWORD in
        1) COMPREPLY=( $(compgen -W "$(for target in ${targets[@]}; do echo "$target"; done)" -- ${COMP_WORDS[COMP_CWORD]}) );;
        2) COMPREPLY=( $(compgen -W "$(echo host ; echo target)" -- ${COMP_WORDS[COMP_CWORD]}) );;
esac

}
complete -o nospace -F _mkc mkc

function mk () {
#++# mk : make daemons for uml(not talking about the bashrc internal fxn uml.).
if [[ "$#" -lt 1 ]]; then 
    echo "Usage: mk daemon target(Optional: will automatically detect.inputs:tj1700 or tj160032. Just given in case if not able to detect.)"
    return
fi
echo "Please do makeenv before proceeding further. Timer is running use ctrl + C if makeenv not done."
for tick in 3 2 1
do
   echo $tick
   sleep 1s
done
echo "Lets Do This!!!"

gta # trying to locate the taginfo.
if [ -e taginfo ];then
    echo "Proceeding to do make"
else
    echo "It don't seems to be anykind of checkout area or mirror."
    return
fi

if [ -L taginfo ];then #checking its checkout area or mirror.
    cd tj100_mc/src  #can replace cd with pushd if want to.
else
    echo "It seems you are trying to do make in checkout area. If still want to proceed. I will not proceed. Write your own new fxn to do so :)"
    return
fi

 daemon_name=$1
if [ "$daemon_name" == "nm" ];then #if1
 target=$2
    if [ "$target" == "" ];then #if2
        pushd app/tj1700/nm >> /dev/null
         lo_count=$(ls -lrt *.lo | wc -l)
        popd >> /dev/null
        if [ "$lo_count" != "0" ];then
            echo "Seems target is tj1700"
            target="tj1700"
        else
            echo "Seems target is tj160032"
            target="tj160032"
        fi
    fi #if2   
fi #if1

case "$daemon_name" in
  gmpls|net|init)
    echo "daemon dir app/common/$daemon_name"
    make -C app/common/$daemon_name
    ;;
  nm)
    echo "daemon dir app/$target/nm"
    make -C app/$target/nm
    ;;
  ccs)
    echo "daemon dir app/common/nm/ccs"
    make -C app/common/nm/$daemon_name
    ;;
  interfaces)
    echo "dir interfaces"
    make -C $daemon_name
    ;;
    *)   
    echo "Unknown daemon Type. Please add this to the mk function."
    return;
esac
}

function _mk()
{ ## autocompletion function for mk
     words=(gmpls net init nm ccs interfaces tj1700 tj160032)
     COMPREPLY=( $(compgen -W "$(for word in ${words[@]}; do echo "$word"; done)" -- ${COMP_WORDS[COMP_CWORD]}) )
}
complete -F _mk mk

function gta () {
#++# gta : goto_taginfo_area, pushd the taginfo dir. basically search for taginfo recursively and goto that.
 target=$1
 rel_path=$(reverse_recursive_search taginfo)

if [[ "$rel_path" == "" ]]; then
    echo "Not able to locate taginfo. Doesn't seem to be checkout or mirror area."
    return 1
else
    rel_path=${rel_path%/*}
fi
pushd $rel_path > /dev/null

}

function gca () {
#++# gca : goto_checkout_area , pushd checkout area for same mirror.
 path_relative_to_taginfo=$(crp taginfo)
path_relative_to_taginfo=${path_relative_to_taginfo#\/}
gta
if [[ "$?" == "0" ]];then
  temp=$(readlink -e ./taginfo)
  temp=${temp%taginfo}
  popd > /dev/null
  pushd ${temp}${path_relative_to_taginfo} >> /dev/null
else
    rcd
fi
}

function gma () {
#++# gma : goto_mirror_area, pushd mirror area using mirror_list. first have generate mirrorlist.
 goto_mirror=$@
 path_relative_to_taginfo=$(crp taginfo)
#path_relative_to_taginfo=${path_relative_to_taginfo#\/} #not sure what will _gma will send. path//other_path works.

if [ "$goto_mirror" == "" ];then
    taginfo_relative_path=$(reverse_recursive_search taginfo)
    if [[ "$taginfo_relative_path" == "" ]];then
         echo "It doesn't seem to be a checkout area. Reading Universal Mirror List."
         mirrors=($(cat ${universal_mirrors_file}))
         total_results=${#mirrors[@]}
         echo "Found $total_results Mirrors. Which one to pursue?"
         for((index=0;index<$total_results;index++))
          do
             echo "$index  ${mirrors[$index]}"
          done
         echo "Please Enter index no. That would be selected to navigate."
         read choice
         while (( choice < 0 || choice >= total_results ))
          do
              echo "Invalid index. Enter again."
              read choice
          done
         pushd ${mirrors[$choice]} >>/dev/null
         return
    fi
     taginfo_absolute_path=$(readlink -e $taginfo_relative_path)
    taginfo_absolute_path=${taginfo_absolute_path%taginfo}

    if ! [[ -e ${taginfo_absolute_path}${mirrors_of_checkout_file} ]];then
          echo "It seems you haven't created/updated mirrors_list file. Please Run fxn -> uml (=update_mirror_list)"
          return
    fi

    readarray -t mirrors <<< "$(cat ${taginfo_absolute_path}${mirrors_of_checkout_file})"
     total_results=${#mirrors[@]}

    if [[ "$total_results" != "1" ]]; then
        echo "Found $total_results Mirrors. Which one to pursue?"
           for((index=0;index<$total_results;index++))
           do
               echo "$index  ${mirrors[$index]}"
           done
        echo "Please Enter index no. That would be selected to navigate."
        read choice
            while (( choice < 0 || choice >= total_results ))
            do
                echo "Invalid index. Enter again."
                read choice
            done
        pushd ${mirrors[$choice]}${path_relative_to_taginfo} >>/dev/null

    elif [[ "$total_results" == "1" ]] && [[ "${mirrors}" != "" ]]; then
         pushd ${mirrors}${path_relative_to_taginfo} >>/dev/null
    else
         echo "No mirrors found for this checkout area."
         return
    fi
else
    pushd ${goto_mirror}${path_relative_to_taginfo} >> /dev/null
    if [ "$?" != "0" ];then
        echo "Unable to change to mirror."
        return
    fi
fi
}
function _gma()
{ ## autocompletion function for gma
         taginfo_relative_path=$(reverse_recursive_search taginfo)
        if [[ "$taginfo_relative_path" == "" ]];then
              echo "It doesn't seem to be a checkout area."
              return
        fi
         taginfo_absolute_path=$(readlink -e $taginfo_relative_path)
        taginfo_absolute_path=${taginfo_absolute_path%taginfo}

        if ! [[ -e ${taginfo_absolute_path}${mirrors_of_checkout_file} ]];then
              echo "It seems you haven't created/updated mirrors_list file. Please Run fxn -> uml (=update_mirror_list)"
              return
        fi

        readarray -t mirrors <<< "$(cat ${taginfo_absolute_path}${mirrors_of_checkout_file})"
         total_results=${#mirrors[@]}
        if [[ "$total_results" == "0" ]]; then
             echo "No mirrors found for this checkout area."
             return
        fi
        IFS=$'\n' tmp=( $(compgen -o dirnames -W "$(for((index=0;index<$total_results;index++)); do echo "${mirrors[$index]}"; done)" -- "${COMP_WORDS[$COMP_CWORD]}" ))
         COMPREPLY=( "${tmp[@]}" )
}
complete -o nospace -F _gma gma

function uml () {
#++# uml : update_mirror_list, update the mirrors list in checkout areas and create if don't exist.
readarray -t taginfo_files <<< "$(locate -b '\taginfo' | grep -v "CVSROOT")"
 total_results=${#taginfo_files[@]}
if [[ "$total_results" == "0" ]]; then
    echo "NO Checkout or mirror area found."
    return
fi
echo "Resetting Universal Checkout, Mirrors & Orphan Mirrors List."
echo -n > $universal_mirrors_file
echo -n > $universal_checkouts_file
echo -n > $universal_orphan_mirrors_file

for taginfo_file in ${taginfo_files[@]}
do
    if ! [ -L $taginfo_file ];then
         checkout_area=${taginfo_file%taginfo}
        echo "Resetting mirror_list for $checkout_area"
        echo -n > ${checkout_area}${mirrors_of_checkout_file}
        if [ "$?" == "0" ];then
        	echo "$checkout_area" >> $universal_checkouts_file
		fi
    fi
done

for taginfo_file in ${taginfo_files[@]}
do
    if [ -L $taginfo_file ];then
         mirror_name=${taginfo_file%taginfo}
        echo "Creating Entry of mirror $mirror_name to proper mirror list."
        local corresponding_checkout_area=$(readlink -e $taginfo_file)
        readlink -e $taginfo_file >> /dev/null
        if [ "$?" == "0" ];then
             corresponding_checkout_area=${corresponding_checkout_area%taginfo}
             echo "$mirror_name" >> ${corresponding_checkout_area}${mirrors_of_checkout_file}
             if [ "$?" == "0" ];then
                 echo "$mirror_name" >> $universal_mirrors_file
             fi
        else
             echo "Found Orphan Mirror $mirror_name. Saving it to Universal Mirrors Without Checkout List."
             echo "$mirror_name" >> $universal_orphan_mirrors_file
        fi
    fi
done
}

function cmpl () {
#++# cmpl : Start compilation for all targets or current target.Can give no. of threads also.
 thread=$1
local rel_path=$(reverse_recursive_search taginfo)

if [[ "$rel_path" == "" ]]; then
    echo "Not able to locate taginfo. Doesn't seem to be checkout or mirror area."
    return
else
    rel_path=${rel_path%/*}
fi

pushd $rel_path/.. > /dev/null

targets=$(ls -1 | grep mirror)
mirror_path=$(pwd)

local chain_of_commands=""

for target in $targets; do

if [ "$thread" == "" ];then
    thread=1
fi

 compile_dir=${mirror_path}/${target}/tj100_mc/scripts
local compile_cmd=$(get_compile_command ${target%%mirror*} $compile_dir $thread)
if [ "$compile_cmd" == "" ];then
    echo "Unknown target Type. Please add this to the get_compile_command function."
    return
fi
     local  tab="--tab --title=$target"
       cmd="bash -c 'echo -en \"\033\]0;$target\a\" && cd ${mirror_path}/${target}/tj100_mc/scripts && ($compile_cmd) ; bash ; echo -en \"\033\]0;$target\a\" ; '"
      chain_of_commands+=($tab -e "$cmd")
done
gnome-terminal --maximize "${chain_of_commands[@]}"
}

function pbc () {
#++# pbc : Print .bashrc changes, It will print all custom bashrc fxn & all.
        cat $user_bashrc | sed '0,/#%%%%#/d'
}
function pfs () {
#++# pfs : Password File Search, search in password file & print the result.
    cat $password_manager_file | awk '{print $1 " " $2 }' | grep -i "$*"
}
function ems () {
#++# ems : ssh -X to ems server(230.153).
     ems_ip="192.168.230.153"
    echo "Login to EMS Server $ems_ip Username: root, Password: tejas . Run : "
    echo "java -jar /opt/ems/release/ems.jar"
    s $ems_ip
}
function nms () {
#++# nms : Open NMS in Firefox.
     nms_ip="192.168.230.157"
    echo NMS: Username: administrator Password: iltwat@123
    firefox "http://$nms_ip:8080/webnms/"
}
function crp () {
#++# crp : Current Relative Path, Show current path from taginfo file.
 search_for=$1
if [[ "$search_for" == "" ]]; then
    echo "Usage : crp searchkeyword(dir/filename)"
    return
fi
     current_path=$(pwd)
    #do gsd
     gsd_status=$(gsd $search_for)
    gsd_status_word_count=$(echo -n $gsd_status | wc -w)
    if [ $gsd_status_word_count -eq 0 ];then
        gsd $search_for
         result_path=$(pwd)
        popd >> /dev/null
        relative_path=${current_path#$result_path}
        echo $relative_path
    fi
}
function rcd () {
#++# rcd : Relative cd , goto same code area taken reference from taginfo file.
     keyword=$1
     current_path=$(pwd)
     path_relative_to_taginfo=$(crp taginfo)
if [ "$keyword" != "" ];then
#        echo "Usage: rcd anykeyword(file/dir) relative to that we will try to change dir."
#        return
#    fi
     gsd_status=$(gsd $keyword)
     gsd_status_word_count=$(echo -n $gsd_status | wc -w)
    if [ $gsd_status_word_count -ne 0 ];then
        echo $gsd_status
        return
    fi
    gsd $keyword
     temp_path1=$(pwd)
    readarray -t currarr <<< "$(current_path=${current_path#\/} ; echo $current_path  | sed -e 's/\//\n/g')"
     currlen=${#currarr[*]}
    readarray -t temparr <<< "$(temp_path1=${temp_path1#\/} ; echo $temp_path1  | sed -e 's/\//\n/g')"
     templen=${#temparr[*]}
    for ((dir_no=0;dir_no<$currlen;dir_no++)) #can't decide how long the dir will be so starting from 0
    do
        cd ${currarr[$dir_no]} 2> /dev/null
    done
    status=$?
    if [ "$status" != "0" ];then
        echo "Not able to change properly. You can still do popd."
    fi
else
    readarray -t results <<< "$(cat $universal_checkouts_file)"
     total_results=${#results[@]}
    if [[ "$total_results" != "1" ]]; then
        echo "Found $total_results Checkout Areas in Your PC. Which one to pursue?"
        for((index=0;index<$total_results;index++))
        do
            echo "$index  ${results[$index]}"
        done
        echo "Please Enter index no. That would be selected to navigate."
        read choice
        while (( choice < 0 || choice >= total_results ))
        do
            echo "Invalid index. Enter again."
            read choice
        done
        pushd ${results[$choice]}${path_relative_to_taginfo} >>/dev/null
    elif [[ "$total_results" == "1" ]] && [[ "${results}" != "" ]]; then
         pushd ${results}${path_relative_to_taginfo} >>/dev/null
    else
        echo "Found Nothing in Universal Checkout file. Please run uml"
        return
    fi

fi
}

function _rcd()
{ ## autocompletion function for rcd
         taginfo_relative_path=$(reverse_recursive_search taginfo)
        if [[ "$taginfo_relative_path" == "" ]];then
             cur=${COMP_WORDS[COMP_CWORD]}
             COMPREPLY=( $(compgen -o dirnames  -- $cur) )
            return
        fi
         taginfo_absolute_path=$(readlink -e $taginfo_relative_path)
        taginfo_absolute_path=${taginfo_absolute_path/taginfo/..}
        IFS=$'\n' tmp=( $(compgen -o dirnames -W "$(ls "$taginfo_absolute_path")" -- "${COMP_WORDS[$COMP_CWORD]}" ))
        COMPREPLY=( "${tmp[@]// /\ }" )
}
complete -o nospace -F _rcd rcd

function gsd () {
#++# gsd : Goto Selected Directory , pass a keyword(dir/filename) reverse lookup will be done & dir change accordingly.
 search_for=$1
if [[ "$search_for" == "" ]]; then
    echo "Usage : gsd keyword(dir/filename)"
    return
fi

 rel_path=$(reverse_recursive_search $search_for)
if [[ "$rel_path" == "" ]]; then
    echo "Not able to locate $search_for recursively."
    return
else
    if [ -f $rel_path ];then
        rel_path=${rel_path%/*}
    fi    
fi
pushd $rel_path > /dev/null
}

function lcd () {
#++# lcd : Locate & cd, Pass some keyword/filename & it will be searched in current dir context & goto that dir.
 search_for=$1
if [[ "$search_for" == "" ]]; then
    echo "Usage : lcd keyword(dir/filename)"
    return
fi
readarray -t results <<< "$(locate $(pwd)*${search_for})"
 total_results=${#results[@]}
if [[ "$total_results" != "1" ]]; then
    echo "Found $total_results results. Which one to pursue?"
    for((index=0;index<$total_results;index++))
    do
        echo "$index  ${results[$index]}"
    done
    echo "Please Enter index no. That would be selected to navigate."
    read choice
    while (( choice < 0 || choice >= total_results ))
    do
        echo "Invalid index. Enter again."
        read choice
    done
    gsd ${results[$choice]}
elif [[ "$total_results" == "1" ]]; then
     gsd ${results}
else
    echo "Found Nothing related to $search_for"
    return
fi
}

function get_compile_command () { #internal fxn.
if [ "$#" -ne "3" ];then
    echo "Usage : get_compile_command \$target \$compile_dir \$thread"
    return
fi

 target=$1
 compile_dir=$2
 thread=$3

case "$target" in
  cef5)
local compile_cmd="./create_install -dir=$compile_dir/../.. -swimg -cpu=ppc -target=$target -kernel=LINUX26 -noupdate -nocheckout -db -pkt_switching=YES -l2_switching=YES -parallel=$thread"
    ;;
  xcc360g)
local compile_cmd="./create_install -dir=$compile_dir/../.. -swimg -cpu=ppc -target=$target -kernel=LINUX26 -noupdate -nocheckout -db -pkt_switching=YES -l2_switching=YES -parallel=$thread"
    ;;
  tj1700)
local compile_cmd="./create_install -dir=$compile_dir/../.. -swimg -cpu=ppc -target=$target -kernel=LINUX26 -noupdate -nocheckout -db -pkt_switching=YES -l2_switching=YES -parallel=$thread"
    ;;
  plc01)
local compile_cmd="./create_install -target=$target -cpu=ppc -swimg -db -noupdate -dir=$compile_dir/../../ -pkt_switching=YES -l2_switching=NO -kernel=LINUX26 -parallel=$thread"
    ;;
  osmc)
local compile_cmd="./create_install -dir=$compile_dir/../../ -swimg -cpu=ppc -target=$target -kernel=LINUX26 -noupdate -nocheckout -db -pkt_switching=YES -l2_switching=YES -parallel=$thread"
    ;;
  elan07)
local compile_cmd="./create_install -dir=$compile_dir/../../ -target=$target -swimg -cpu=ppc -nocheckout -maps -noupdate -smart=YES -kernel=LINUX24 -parallel=$thread"
    ;;
  teraxc)
local compile_cmd="./create_install -dir=$compile_dir/../../ -swimg -cpu=ppc -target=$target -kernel=LINUX26 -noupdate -nocheckout -db -maps -pkt_switching=YES -l2_switching=YES -gmpls=YES -otn=YES -parallel=$thread"
    ;;
  xa10g)
local compile_cmd="./create_install -dir=$compile_dir/../../ -l2_switching=NO -verbose=5 -cpu=ppc -noupdate -pkt_switching=YES -target=$target -kernel=LINUX26 -swimg -ssmgr=YES -db -build -parallel=$thread"
    ;;
  elan10)
local compile_cmd="./create_install -dir=$compile_dir/../../ -l2_switching=NO -verbose=5 -cpu=ppc -noupdate -pkt_switching=YES -target=$target -kernel=LINUX26 -swimg -ssmgr=YES -db -build -parallel=$thread"
    ;;
  cef4)
local compile_cmd="./create_install -dir=$compile_dir/../../ -l2_switching=NO -verbose=5 -cpu=ppc -noupdate -pkt_switching=YES -target=$target -kernel=LINUX26 -swimg -ssmgr=YES -db -build -parallel=$thread"
    ;;
  cef4C)
local compile_cmd="./create_install -dir=$compile_dir/../../ -l2_switching=NO -verbose=5 -cpu=ppc -noupdate -pkt_switching=YES -target=$target -kernel=LINUX26 -swimg -ssmgr=YES -db -build -parallel=$thread"
    ;;
  tj14xx)
local compile_cmd="./create_install -dir=$compile_dir/../../ -l2_switching=NO -verbose=5 -cpu=ppc -noupdate -pkt_switching=YES -target=$target -kernel=LINUX26 -swimg -ssmgr=YES -db -build -parallel=$thread"
    ;;
  tj14xxN)
local compile_cmd="./create_install -dir=$compile_dir/../../ -noupdate -cpu=ppc -swimg -target=$target -l2_switching=NO -nocheckout -db -pkt_switching=YES -kernel=LINUX26 -parallel=$thread"
    ;;
    *)
#    echo "Unknown target Type. Please add this to the compile function."
#     should return null if target not found
    return;
esac
compilation_log="$compile_dir/../../${target}_compilation.log"
cftf="$compile_dir/../../$compile_for_type_file"
echo "echo $target > $cftf ; echo -n > $compilation_log ; tail -f $compilation_log & backgroundPID=\$! ; onINT() { kill -9 \$backgroundPID 2>/dev/null; }; trap "onINT" SIGINT ; $compile_cmd >> $compilation_log 2>&1 && python $sms_sending_script $my_mobile_no \"BUILD READY FOR TARGET ${target} IN ${compile_dir%/tj100_mc*} \" || python $sms_sending_script $my_mobile_no \"BUILD BREAK FOR TARGET ${target} IN ${compile_dir%/tj100_mc*}\""
#echo "$compile_cmd"
}

function mc () {
#++# mc : Mirror & Compile, cmc does checkout also. but written so that mirror and compile only be done.
if [ "$#" -lt "1" ];then
    echo "Usage : mc targets (example cef5 xcc360g etc.)"
    return
fi
 targets="$@"
    gta
     temp=$(readlink -e ./taginfo)
    temp=${temp%taginfo}
    cd $temp
     checkout_path=$(readlink -e ./)
     rel_path=$(reverse_recursive_search taginfo)
if [[ "$rel_path" == "" ]]; then
    echo "Not able to locate taginfo. Doesn't seem to be checkout or mirror area."
    return
else
    rel_path=${rel_path%/*}
fi
pushd $rel_path/.. > /dev/null
mirror_path=$(pwd)

for target in $targets; do
    if [[ -e "${mirror_path}/${target}mirror" ]]; then
        echo "${mirror_path}/${target}mirror Already Exists. No need to mirror for this."
    else
        ~/cm-utils/mirror $checkout_path ${mirror_path}/${target}mirror
    fi
done
popd > /dev/null
cmpl
}

cimg () 
{ 
#++# cimg : Combine_latest of images.
    fresh_token=$1
    taginfo_relative_path=$(reverse_recursive_search taginfo);
    if [[ "$taginfo_relative_path" == "" ]]; then
        echo "It doesn't seem to be a checkout area.";
        return;
    fi;
    taginfo_absolute_path=$(readlink -e $taginfo_relative_path);
    taginfo_absolute_path=${taginfo_absolute_path%taginfo};
    if ! [[ -e ${taginfo_absolute_path}${mirrors_of_checkout_file} ]]; then
        echo "It seems you haven't created/updated mirrors_list file. Please Run fxn -> uml (=update_mirror_list)";
        return;
    fi;
    readarray -t mirrors <<< "$(cat ${taginfo_absolute_path}${mirrors_of_checkout_file})";
    echo "Resetting $outer_latest_image & $inner_latest_image"
    echo -n > ${taginfo_absolute_path}/$outer_latest_image
    echo -n > ${taginfo_absolute_path}/$inner_latest_image
    echo -n > ${taginfo_absolute_path}/$final_inner
    echo -n > ${taginfo_absolute_path}/$final_outer
    timestamp_override_outer="0"
    timestamp_override_inner="0"
    total_results=${#mirrors[@]};
    if [[ "$total_results" != "1" ]]; then
        echo "Found $total_results Mirrors. Creating list of latest builds present in them.";
        for ((index=0; index<$total_results; index++))
        do
            this_mirror_latest=$(ls -1rt ${mirrors[$index]}*.img |grep -v "download\|$combined_image_keyword"| tail -n 1)
            this_mirror_latest_type=${this_mirror_latest##*\/}
            this_mirror_latest_type=${this_mirror_latest_type%%[$image_name_delimeters]*}
            if [[ "$(should_this_be_outer_image $this_mirror_latest_type)" == "yes" ]];then
            	echo "$this_mirror_latest" >> ${taginfo_absolute_path}/$outer_latest_image
            	if [ -e ${mirrors[$index]}/$timestamp_override_token ];then
            		echo "$this_mirror_latest" > ${taginfo_absolute_path}/$final_outer
            		let timestamp_override_outer=timestamp_override_outer+1
            	fi
            else
            	echo "$this_mirror_latest" >> ${taginfo_absolute_path}/$inner_latest_image
            	if [ -e ${mirrors[$index]}/$timestamp_override_token ];then
            		echo "$this_mirror_latest" > ${taginfo_absolute_path}/$final_inner
            		let timestamp_override_inner=timestamp_override_inner+1
            	fi
            fi
        done;

        if [[ "$timestamp_override_outer" == "0" ]];then
        	ls -1rt $(cat ${taginfo_absolute_path}/$outer_latest_image) | tail -n 1 > ${taginfo_absolute_path}/$final_outer
        fi

        if [[ "$timestamp_override_inner" == "0" ]];then
        	ls -1rt $(cat ${taginfo_absolute_path}/$inner_latest_image) | tail -n 1 > ${taginfo_absolute_path}/$final_inner
        fi
        
        temp_outer=$(cat ${taginfo_absolute_path}/$final_outer)
        outer_dir=${temp_outer%\/*}
        outer_file=${temp_outer##*\/}
        temp_inner=$(cat ${taginfo_absolute_path}/$final_inner)
        inner_dir=${temp_inner%\/*}
        inner_file=${temp_inner##*\/}
        inner_type=${inner_file%%[$image_name_delimeters]*}
        outer_type=${outer_file%%[$image_name_delimeters]*}
        path_to_mksquashfs="$outer_dir/tj100_mc/scripts"
        if [[ "$fresh_token" == "t" ]];then
        	epoch_timestamp=$(date +%s)
            combined_image_name="${outer_type}-${combined_image_keyword}-${inner_type}-${epoch_timestamp}.squash.img"
        elif [[ "$fresh_token" == "" ]];then
        	combined_image_name="${outer_type}-${combined_image_keyword}-${inner_type}-constant_name.squash.img"
        else
        	combined_image_name="${outer_type}-${combined_image_keyword}-${inner_type}-${$fresh_token}.squash.img"
        fi
        pushd $outer_dir >/dev/null
        rm -rf $outer_dir/$image_extraction_dir 2>/dev/null
        echo "Extracting $outer_file"
        tar -xzvf ${outer_file/.squash.img/.tgz}
        mkdir -p $outer_dir/$image_extraction_dir/$inner_type
        cp ${temp_inner} $outer_dir/$image_extraction_dir/$inner_type/${inner_type}.squash.img
        cp ${temp_inner}.md5 $outer_dir/$image_extraction_dir/$inner_type/${inner_type}.squash.img.md5
        tj100_mc/scripts/create_squashfsimg.sh $image_extraction_dir $combined_image_name tj100_mc/scripts
        echo "Combined the images successfully."
        ls -lrt
    else
        if [[ "$total_results" == "1" ]] && [[ "${mirrors}" != "" ]]; then
            echo "Only Single Mirror is there. At least one Control Card & one Line Card Image is needed to combine."
            return;
        else
            echo "No mirrors found for this checkout area.";
            return;
        fi;
    fi;
}
function him () {
#++# him : ssh -X to himalya build server
$scripts_path/gas 192.168.17.59 tj100rel reltj100
}

function sms () {
#++# sms : send sms to anyone.
echo "Usage: sms Mobile_NO   Message."
mobile_no=$1
if ! [[ $mobile_no =~ $renum ]];then
     echo "Seems to be invalid MObile NO."
     return
fi

if  [[ ${#mobile_no} -ne 10 ]];then
     echo "Enter without 0 or +91 in front of no. Only 10 digit no. is acceptable."
     return
fi
all_arg=$@
message=${all_arg#${mobile_no} }
echo "Mobile NO : $mobile_no"
echo ""
echo "Message : $message"
echo "Message Length : ${#message}"
if [[ "${#message}" -gt "135" ]];then
   echo "Message lenght should not exceed 135 chars."
   return
fi

python $sms_sending_script "$mobile_no" "$message"

}
function ulmd () {
#++# ulmd : update local md5 database.
echo "Updating mirror database."
uml
echo "Resetting $universal_local_md5_file"
echo -n "" > $universal_local_md5_file
for mirror_area in $(cat $universal_mirrors_file)
do
   all_images=($(ls -1rt ${mirror_area}*.squash.img 2>/dev/null| grep -v "download" ))
   if [ ${#all_images[@]} -eq 0 ];then
      echo "$mirror_area seems to be Host build area. No image found."
   else
   for image in ${all_images[@]}
   do
       if [ -e ${image}.md5 ];then
          echo "Found md5 for $image"
          img_md5=$(cat ${image}.md5)
          echo "$img_md5 $image" >> $universal_local_md5_file
       else
          echo "Have to calculate md5sum of image $image"
          md5sum $image >> $universal_local_md5_file
       fi
   done
   fi
done
}

function urmd () {
#++# urmd : update release md5 database
    echo "Sending commands to release server so that it will create $md5_temp_on_release_server";
    $scripts_path/md5relinfo $release_server_ip $release_server_username $release_server_password $md5_temp_on_release_server;
    echo "Server has created $md5_temp_on_release_server";
    echo "Downloading that to $universal_release_md5_file";
    echo -n > $universal_release_md5_file;
    ncftpget -u$release_server_username -p$release_server_password $release_server_ip ~/ $md5_temp_on_release_server;
    echo "Done. Updated Release MD5 Details to latest."
}

function unidb () {
#++# unidb : update nodes inventory database for predefined subnets in $node_subnets. Store it at $all_nodes_dir .
for subnet in ${node_subnets[@]}
do
     echo "Subnet $subnet"
     for node_ip in $(nodes $subnet)
     do
          echo "Node : $node_ip"
          nis $node_ip > ${all_nodes_dir}/$node_ip
     done
done
echo "Node Inventory Database Updated. Stored at $all_nodes_dir"
}
function ca () {
#++# ca : crash analysis.
$scripts_path/ca.sh $1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11}
}
function slat () {
#++# slat : fully slat the given node.
$scripts_path/slat $1 $2
}
function wl () {
#++# wl : web login, give ip of node will open new window for that node and login.
possible_ip=($(fip143 "$@"))
if ping -c 1 $possible_ip >/dev/null ;then echo "Opening Web UI"; else  echo "Node is down. Retry again..." ; return ; fi
python $scripts_path/python/web_node.py $possible_ip
}
############################################Keep New Functions Above This Line#################################################
function ? () {
#++# ? : Show all custom written functions from bashrc.
    cat $user_bashrc | grep "#++#" | grep -v "#--#" |tr -d "#++#" | grep -i "$*" |grep .*:
}

